{"language":"Solidity","sources":{"/home/max/Desktop/Ethereum/polymath-core/contracts/FeatureRegistry.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ReclaimTokens.sol\";\nimport \"./interfaces/IFeatureRegistry.sol\";\n\n/**\n * @title Registry for managing polymath feature switches\n */\ncontract FeatureRegistry is IFeatureRegistry, ReclaimTokens {event __CoverageFeatureRegistry(string fileName, uint256 lineNumber);\nevent __FunctionCoverageFeatureRegistry(string fileName, uint256 fnId);\nevent __StatementCoverageFeatureRegistry(string fileName, uint256 statementId);\nevent __BranchCoverageFeatureRegistry(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageFeatureRegistry(string fileName, uint256 branchId);\nevent __AssertPostCoverageFeatureRegistry(string fileName, uint256 branchId);\n\n\n    mapping (bytes32 => bool) public featureStatus;\n\n    event ChangeFeatureStatus(string _nameKey, bool _newStatus);\n\n    /**\n     * @notice Get the status of a feature\n     * @param _nameKey is the key for the feature status mapping\n     * @return bool\n     */\n    function getFeatureStatus(string _nameKey) external  returns(bool) {emit __FunctionCoverageFeatureRegistry('./contracts/FeatureRegistry.sol',1);\n\nemit __CoverageFeatureRegistry('./contracts/FeatureRegistry.sol',21);\n        emit __StatementCoverageFeatureRegistry('./contracts/FeatureRegistry.sol',1);\nbytes32 key = keccak256(bytes(_nameKey));\nemit __CoverageFeatureRegistry('./contracts/FeatureRegistry.sol',22);\n        emit __StatementCoverageFeatureRegistry('./contracts/FeatureRegistry.sol',2);\nreturn featureStatus[key];\n    }\n\n    /**\n     * @notice change a feature status\n     * @dev feature status is set to false by default\n     * @param _nameKey is the key for the feature status mapping\n     * @param _newStatus is the new feature status\n     */\n    function setFeatureStatus(string _nameKey, bool _newStatus) public onlyOwner {emit __FunctionCoverageFeatureRegistry('./contracts/FeatureRegistry.sol',2);\n\nemit __CoverageFeatureRegistry('./contracts/FeatureRegistry.sol',32);\n        emit __StatementCoverageFeatureRegistry('./contracts/FeatureRegistry.sol',3);\nbytes32 key = keccak256(bytes(_nameKey));\nemit __CoverageFeatureRegistry('./contracts/FeatureRegistry.sol',33);\n        emit __AssertPreCoverageFeatureRegistry('./contracts/FeatureRegistry.sol',1);\nemit __StatementCoverageFeatureRegistry('./contracts/FeatureRegistry.sol',4);\nrequire(featureStatus[key] != _newStatus, \"Status unchanged\");emit __AssertPostCoverageFeatureRegistry('./contracts/FeatureRegistry.sol',1);\n\nemit __CoverageFeatureRegistry('./contracts/FeatureRegistry.sol',34);\n        emit __StatementCoverageFeatureRegistry('./contracts/FeatureRegistry.sol',5);\nemit ChangeFeatureStatus(_nameKey, _newStatus);\nemit __CoverageFeatureRegistry('./contracts/FeatureRegistry.sol',35);\n        emit __StatementCoverageFeatureRegistry('./contracts/FeatureRegistry.sol',6);\nfeatureStatus[key] = _newStatus;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/ReclaimTokens.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./interfaces/IERC20.sol\";\n\n/**\n * @title Utility contract to allow owner to retreive any ERC20 sent to the contract\n */\ncontract ReclaimTokens is Ownable {event __CoverageReclaimTokens(string fileName, uint256 lineNumber);\nevent __FunctionCoverageReclaimTokens(string fileName, uint256 fnId);\nevent __StatementCoverageReclaimTokens(string fileName, uint256 statementId);\nevent __BranchCoverageReclaimTokens(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageReclaimTokens(string fileName, uint256 branchId);\nevent __AssertPostCoverageReclaimTokens(string fileName, uint256 branchId);\n\n\n    /**\n    * @notice Reclaim all ERC20Basic compatible tokens\n    * @param _tokenContract The address of the token contract\n    */\n    function reclaimERC20(address _tokenContract) external onlyOwner {emit __FunctionCoverageReclaimTokens('./contracts/ReclaimTokens.sol',1);\n\nemit __CoverageReclaimTokens('./contracts/ReclaimTokens.sol',16);\n        emit __AssertPreCoverageReclaimTokens('./contracts/ReclaimTokens.sol',1);\nemit __StatementCoverageReclaimTokens('./contracts/ReclaimTokens.sol',1);\nrequire(_tokenContract != address(0), \"Invalid address\");emit __AssertPostCoverageReclaimTokens('./contracts/ReclaimTokens.sol',1);\n\nemit __CoverageReclaimTokens('./contracts/ReclaimTokens.sol',17);\n        emit __StatementCoverageReclaimTokens('./contracts/ReclaimTokens.sol',2);\nIERC20 token = IERC20(_tokenContract);\nemit __CoverageReclaimTokens('./contracts/ReclaimTokens.sol',18);\n        emit __StatementCoverageReclaimTokens('./contracts/ReclaimTokens.sol',3);\nuint256 balance = token.balanceOf(address(this));\nemit __CoverageReclaimTokens('./contracts/ReclaimTokens.sol',19);\n        emit __AssertPreCoverageReclaimTokens('./contracts/ReclaimTokens.sol',2);\nemit __StatementCoverageReclaimTokens('./contracts/ReclaimTokens.sol',4);\nrequire(token.transfer(owner, balance), \"Transfer failed\");emit __AssertPostCoverageReclaimTokens('./contracts/ReclaimTokens.sol',2);\n\n    }\n}\n"},"openzeppelin-solidity/contracts/ownership/Ownable.sol":{"content":"pragma solidity ^0.4.23;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/interfaces/IERC20.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {event __CoverageIERC20(string fileName, uint256 lineNumber);\nevent __FunctionCoverageIERC20(string fileName, uint256 fnId);\nevent __StatementCoverageIERC20(string fileName, uint256 statementId);\nevent __BranchCoverageIERC20(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageIERC20(string fileName, uint256 branchId);\nevent __AssertPostCoverageIERC20(string fileName, uint256 branchId);\n\n    function decimals() external  returns (uint8);\n    function totalSupply() external  returns (uint256);\n    function balanceOf(address _owner) external  returns (uint256);\n    function allowance(address _owner, address _spender) external  returns (uint256);\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\n    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/interfaces/IFeatureRegistry.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Interface for managing polymath feature switches\n */\ninterface IFeatureRegistry {event __CoverageIFeatureRegistry(string fileName, uint256 lineNumber);\nevent __FunctionCoverageIFeatureRegistry(string fileName, uint256 fnId);\nevent __StatementCoverageIFeatureRegistry(string fileName, uint256 statementId);\nevent __BranchCoverageIFeatureRegistry(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageIFeatureRegistry(string fileName, uint256 branchId);\nevent __AssertPostCoverageIFeatureRegistry(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice Get the status of a feature\n     * @param _nameKey is the key for the feature status mapping\n     * @return bool\n     */\n    function getFeatureStatus(string _nameKey) external  returns(bool);\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/Migrations.sol":{"content":"pragma solidity ^0.4.24;\n\n\ncontract Migrations {\n\n    address public owner;\n\n    uint public lastCompletedMigration;\n\n    modifier restricted() {\n        require(msg.sender == owner, \"Sender must be owner\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setCompleted(uint _completed)public  restricted {\n        lastCompletedMigration = _completed;\n    }\n\n    function upgrade(address _newAddress)public  restricted {\n        Migrations upgraded = Migrations(_newAddress);\n        upgraded.setCompleted(lastCompletedMigration);\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/ModuleRegistry.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./interfaces/IModuleRegistry.sol\";\nimport \"./interfaces/IModuleFactory.sol\";\nimport \"./interfaces/ISecurityTokenRegistry.sol\";\nimport \"./interfaces/IPolymathRegistry.sol\";\nimport \"./interfaces/IFeatureRegistry.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./libraries/VersionUtils.sol\";\nimport \"./storage/EternalStorage.sol\";\nimport \"./libraries/Encoder.sol\";\nimport \"./interfaces/IOwnable.sol\";\nimport \"./interfaces/ISecurityToken.sol\";\n\n/**\n* @title Registry contract to store registered modules\n* @notice Only Polymath can register and verify module factories to make them available for issuers to attach.\n*/\ncontract ModuleRegistry is IModuleRegistry, EternalStorage {event __CoverageModuleRegistry(string fileName, uint256 lineNumber);\nevent __FunctionCoverageModuleRegistry(string fileName, uint256 fnId);\nevent __StatementCoverageModuleRegistry(string fileName, uint256 statementId);\nevent __BranchCoverageModuleRegistry(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageModuleRegistry(string fileName, uint256 branchId);\nevent __AssertPostCoverageModuleRegistry(string fileName, uint256 branchId);\n\n    /*\n        // Mapping used to hold the type of module factory corresponds to the address of the Module factory contract\n        mapping (address => uint8) public registry;\n\n        // Mapping used to hold the reputation of the factory\n        mapping (address => address[]) public reputation;\n\n        // Mapping containing the list of addresses of Module Factories of a particular type\n        mapping (uint8 => address[]) public moduleList;\n\n        // Mapping to store the index of the Module Factory in the moduleList\n        mapping(address => uint8) private moduleListIndex;\n\n        // contains the list of verified modules\n        mapping (address => bool) public verified;\n\n    */\n\n    ///////////\n    // Events\n    //////////\n\n    // Emit when network becomes paused\n    event Pause(uint256 _timestammp);\n     // Emit when network becomes unpaused\n    event Unpause(uint256 _timestamp);\n    // Emit when Module is used by the SecurityToken\n    event ModuleUsed(address indexed _moduleFactory, address indexed _securityToken);\n    // Emit when the Module Factory gets registered on the ModuleRegistry contract\n    event ModuleRegistered(address indexed _moduleFactory, address indexed _owner);\n    // Emit when the module gets verified by Polymath\n    event ModuleVerified(address indexed _moduleFactory, bool _verified);\n    // Emit when a ModuleFactory is removed by Polymath\n    event ModuleRemoved(address indexed _moduleFactory, address indexed _decisionMaker);\n    // Emit when ownership gets transferred\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    ///////////////\n    //// Modifiers\n    ///////////////\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',1);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',65);\n        emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',1);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',1);\nrequire(msg.sender == owner(),\"sender must be owner\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',1);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',66);\n        _;\n    }\n\n    /**\n     * @notice Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPausedOrOwner() {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',2);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',73);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',2);\nif (msg.sender == owner())\n            {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',2,0);emit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',74);\n_;}\n        else {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',2,1);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',76);\n            emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',3);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',3);\nrequire(!isPaused(), \"Already paused\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',3);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',77);\n            _;\n        }\n    }\n\n    /**\n     * @notice Modifier to make a function callable only when the contract is not paused and ignore is msg.sender is owner.\n     */\n    modifier whenNotPaused() {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',3);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',85);\n        emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',4);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',4);\nrequire(!isPaused(), \"Already paused\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',4);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',86);\n        _;\n    }\n\n    /**\n     * @notice Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',4);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',93);\n        emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',5);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',5);\nrequire(isPaused(), \"Should not be paused\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',5);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',94);\n        _;\n    }\n\n    /////////////////////////////\n    // Initialization\n    /////////////////////////////\n\n    // Constructor\n    constructor () public\n    {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',5);\n\n\n    }\n\n    function initialize(address _polymathRegistry, address _owner) external payable {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',6);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',108);\n        emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',6);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',6);\nrequire(!getBoolValue(Encoder.getKey(\"initialised\")),\"already initialized\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',6);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',109);\n        emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',7);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',7);\nrequire(_owner != address(0) && _polymathRegistry != address(0), \"0x address is invalid\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',7);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',110);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',8);\nset(Encoder.getKey(\"polymathRegistry\"), _polymathRegistry);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',111);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',9);\nset(Encoder.getKey(\"owner\"), _owner);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',112);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',10);\nset(Encoder.getKey(\"paused\"), false);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',113);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',11);\nset(Encoder.getKey(\"initialised\"), true);\n    }\n\n    /**\n     * @notice Called by a SecurityToken to check if the ModuleFactory is verified or appropriate custom module\n     * @dev ModuleFactory reputation increases by one every time it is deployed(used) by a ST.\n     * @dev Any module can be added during token creation without being registered if it is defined in the token proxy deployment contract\n     * @dev The feature switch for custom modules is labelled \"customModulesAllowed\"\n     * @param _moduleFactory is the address of the relevant module factory\n     */\n    function useModule(address _moduleFactory) external {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',7);\n\n        // This if statement is required to be able to add modules from the token proxy contract during deployment\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',125);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',12);\nif (ISecurityTokenRegistry(getAddressValue(Encoder.getKey(\"securityTokenRegistry\"))).isSecurityToken(msg.sender)) {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',8,0);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',126);\n            emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',13);\nif (IFeatureRegistry(getAddressValue(Encoder.getKey(\"featureRegistry\"))).getFeatureStatus(\"customModulesAllowed\")) {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',9,0);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',127);\n                emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',10);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',14);\nrequire(getBoolValue(Encoder.getKey(\"verified\", _moduleFactory)) || IOwnable(_moduleFactory).owner() == IOwnable(msg.sender).owner(),\"ModuleFactory must be verified or SecurityToken owner must be ModuleFactory owner\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',10);\n\n            } else {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',9,1);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',129);\n                emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',11);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',15);\nrequire(getBoolValue(Encoder.getKey(\"verified\", _moduleFactory)), \"ModuleFactory must be verified\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',11);\n\n            }\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',131);\n            emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',12);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',16);\nrequire(_isCompatibleModule(_moduleFactory, msg.sender), \"Version should within the compatible range of ST\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',12);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',132);\n            emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',17);\npushArray(Encoder.getKey(\"reputation\", _moduleFactory), msg.sender);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',133);\n            emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',18);\nemit ModuleUsed(_moduleFactory, msg.sender);\n        }else { emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',8,1);}\n\n    }\n\n    function _isCompatibleModule(address _moduleFactory, address _securityToken) internal  returns(bool) {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',8);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',138);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',19);\nuint8[] memory _latestVersion = ISecurityToken(_securityToken).getVersion();\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',139);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',20);\nuint8[] memory _lowerBound = IModuleFactory(_moduleFactory).getLowerSTVersionBounds();\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',140);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',21);\nuint8[] memory _upperBound = IModuleFactory(_moduleFactory).getUpperSTVersionBounds();\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',141);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',22);\nbool _isLowerAllowed = VersionUtils.compareLowerBound(_lowerBound, _latestVersion);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',142);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',23);\nbool _isUpperAllowed = VersionUtils.compareUpperBound(_upperBound, _latestVersion);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',143);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',24);\nreturn (_isLowerAllowed && _isUpperAllowed);\n    }\n\n    /**\n     * @notice Called by the ModuleFactory owner to register new modules for SecurityTokens to use\n     * @param _moduleFactory is the address of the module factory to be registered\n     */\n    function registerModule(address _moduleFactory) external whenNotPausedOrOwner {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',9);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',151);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',25);\nif (IFeatureRegistry(getAddressValue(Encoder.getKey(\"featureRegistry\"))).getFeatureStatus(\"customModulesAllowed\")) {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',13,0);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',152);\n            emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',14);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',26);\nrequire(msg.sender == IOwnable(_moduleFactory).owner() || msg.sender == owner(),\"msg.sender must be the Module Factory owner or registry curator\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',14);\n\n        } else {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',13,1);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',154);\n            emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',15);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',27);\nrequire(msg.sender == owner(), \"Only owner allowed to register modules\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',15);\n\n        }\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',156);\n        emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',16);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',28);\nrequire(getUintValue(Encoder.getKey(\"registry\", _moduleFactory)) == 0, \"Module factory should not be pre-registered\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',16);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',157);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',29);\nIModuleFactory moduleFactory = IModuleFactory(_moduleFactory);\n        //Enforce type uniqueness\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',159);\n        uint256 i;\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',160);\n        uint256 j;\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',161);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',30);\nuint8[] memory moduleTypes = moduleFactory.getTypes();\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',162);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',31);\nfor (i = 1; i < moduleTypes.length; i++) {\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',163);\n            emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',32);\nfor (j = 0; j < i; j++) {\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',164);\n                emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',17);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',33);\nrequire(moduleTypes[i] != moduleTypes[j], \"Type mismatch\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',17);\n\n            }\n        }\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',167);\n        emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',18);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',34);\nrequire(moduleTypes.length != 0, \"Factory must have type\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',18);\n\n        // NB - here we index by the first type of the module.\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',169);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',35);\nuint8 moduleType = moduleFactory.getTypes()[0];\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',170);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',36);\nset(Encoder.getKey(\"registry\", _moduleFactory), uint256(moduleType));\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',171);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',37);\nset(\n            Encoder.getKey(\"moduleListIndex\", _moduleFactory),\n            uint256(getArrayAddress(Encoder.getKey(\"moduleList\", uint256(moduleType))).length)\n        );\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',175);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',38);\npushArray(Encoder.getKey(\"moduleList\", uint256(moduleType)), _moduleFactory);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',176);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',39);\nemit ModuleRegistered (_moduleFactory, IOwnable(_moduleFactory).owner());\n    }\n\n    /**\n     * @notice Called by the ModuleFactory owner or registry curator to delete a ModuleFactory from the registry\n     * @param _moduleFactory is the address of the module factory to be deleted from the registry\n     */\n    function removeModule(address _moduleFactory) external whenNotPausedOrOwner {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',10);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',184);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',40);\nuint256 moduleType = getUintValue(Encoder.getKey(\"registry\", _moduleFactory));\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',186);\n        emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',19);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',41);\nrequire(moduleType != 0, \"Module factory should be registered\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',19);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',187);\n        emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',20);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',42);\nrequire(\n            msg.sender == IOwnable(_moduleFactory).owner() || msg.sender == owner(),\n            \"msg.sender must be the Module Factory owner or registry curator\"\n        );emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',20);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',191);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',43);\nuint256 index = getUintValue(Encoder.getKey(\"moduleListIndex\", _moduleFactory));\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',192);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',44);\nuint256 last = getArrayAddress(Encoder.getKey(\"moduleList\", moduleType)).length - 1;\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',193);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',45);\naddress temp = getArrayAddress(Encoder.getKey(\"moduleList\", moduleType))[last];\n\n        // pop from array and re-order\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',196);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',46);\nif (index != last) {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',21,0);\n            // moduleList[moduleType][index] = temp;\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',198);\n            emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',47);\nsetArrayIndexValue(Encoder.getKey(\"moduleList\", moduleType), index, temp);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',199);\n            emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',48);\nset(Encoder.getKey(\"moduleListIndex\", temp), index);\n        }else { emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',21,1);}\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',201);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',49);\ndeleteArrayAddress(Encoder.getKey(\"moduleList\", moduleType), last);\n\n        // delete registry[_moduleFactory];\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',204);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',50);\nset(Encoder.getKey(\"registry\", _moduleFactory), uint256(0));\n        // delete reputation[_moduleFactory];\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',206);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',51);\nsetArray(Encoder.getKey(\"reputation\", _moduleFactory), new address[](0));\n        // delete verified[_moduleFactory];\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',208);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',52);\nset(Encoder.getKey(\"verified\", _moduleFactory), false);\n        // delete moduleListIndex[_moduleFactory];\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',210);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',53);\nset(Encoder.getKey(\"moduleListIndex\", _moduleFactory), uint256(0));\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',211);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',54);\nemit ModuleRemoved(_moduleFactory, msg.sender);\n    }\n\n    /**\n    * @notice Called by Polymath to verify Module Factories for SecurityTokens to use.\n    * @notice A module can not be used by an ST unless first approved/verified by Polymath\n    * @notice (The only exception to this is that the author of the module is the owner of the ST)\n    * @notice -> Only if Polymath enabled the feature.\n    * @param _moduleFactory is the address of the module factory to be verified\n    * @return bool\n    */\n    function verifyModule(address _moduleFactory, bool _verified) external onlyOwner {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',11);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',223);\n        emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',22);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',55);\nrequire(getUintValue(Encoder.getKey(\"registry\", _moduleFactory)) != uint256(0), \"Module factory must be registered\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',22);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',224);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',56);\nset(Encoder.getKey(\"verified\", _moduleFactory), _verified);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',225);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',57);\nemit ModuleVerified(_moduleFactory, _verified);\n    }\n\n    /**\n     * @notice Returns all the tags related to the a module type which are valid for the given token\n     * @param _moduleType is the module type\n     * @param _securityToken is the token\n     * @return list of tags\n     * @return corresponding list of module factories\n     */\n    function getTagsByTypeAndToken(uint8 _moduleType, address _securityToken) external  returns(bytes32[], address[]) {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',12);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',236);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',58);\naddress[] memory modules = getModulesByTypeAndToken(_moduleType, _securityToken);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',237);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',59);\nreturn _tagsByModules(modules);\n    }\n\n    /**\n     * @notice Returns all the tags related to the a module type which are valid for the given token\n     * @param _moduleType is the module type\n     * @return list of tags\n     * @return corresponding list of module factories\n     */\n    function getTagsByType(uint8 _moduleType) external  returns(bytes32[], address[]) {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',13);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',247);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',60);\naddress[] memory modules = getModulesByType(_moduleType);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',248);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',61);\nreturn _tagsByModules(modules);\n    }\n\n    /**\n     * @notice Returns all the tags related to the modules provided\n     * @param _modules modules to return tags for\n     * @return list of tags\n     * @return corresponding list of module factories\n     */\n    function _tagsByModules(address[] _modules) internal  returns(bytes32[], address[]) {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',14);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',258);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',62);\nuint256 counter = 0;\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',259);\n        uint256 i;\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',260);\n        uint256 j;\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',261);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',63);\nfor (i = 0; i < _modules.length; i++) {\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',262);\n            emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',64);\ncounter = counter + IModuleFactory(_modules[i]).getTags().length;\n        }\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',264);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',65);\nbytes32[] memory tags = new bytes32[](counter);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',265);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',66);\naddress[] memory modules = new address[](counter);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',266);\n        bytes32[] memory tempTags;\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',267);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',67);\ncounter = 0;\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',268);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',68);\nfor (i = 0; i < _modules.length; i++) {\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',269);\n            emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',69);\ntempTags = IModuleFactory(_modules[i]).getTags();\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',270);\n            emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',70);\nfor (j = 0; j < tempTags.length; j++) {\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',271);\n                emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',71);\ntags[counter] = tempTags[j];\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',272);\n                emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',72);\nmodules[counter] = _modules[i];\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',273);\n                counter++;\n            }\n        }\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',276);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',73);\nreturn (tags, modules);\n    }\n\n    /**\n     * @notice Returns the reputation of the entered Module Factory\n     * @param _factoryAddress is the address of the module factory\n     * @return address array which contains the list of securityTokens that use that module factory\n     */\n    function getReputationByFactory(address _factoryAddress) external  returns(address[]) {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',15);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',285);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',74);\nreturn getArrayAddress(Encoder.getKey(\"reputation\", _factoryAddress));\n    }\n\n    /**\n     * @notice Returns the list of addresses of Module Factory of a particular type\n     * @param _moduleType Type of Module\n     * @return address array that contains the list of addresses of module factory contracts.\n     */\n    function getModulesByType(uint8 _moduleType) public  returns(address[]) {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',16);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',294);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',75);\nreturn getArrayAddress(Encoder.getKey(\"moduleList\", uint256(_moduleType)));\n    }\n\n    /**\n     * @notice Returns the list of available Module factory addresses of a particular type for a given token.\n     * @param _moduleType is the module type to look for\n     * @param _securityToken is the address of SecurityToken\n     * @return address array that contains the list of available addresses of module factory contracts.\n     */\n    function getModulesByTypeAndToken(uint8 _moduleType, address _securityToken) public  returns (address[]) {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',17);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',304);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',76);\nuint256 _len = getArrayAddress(Encoder.getKey(\"moduleList\", uint256(_moduleType))).length;\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',305);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',77);\naddress[] memory _addressList = getArrayAddress(Encoder.getKey(\"moduleList\", uint256(_moduleType)));\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',306);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',78);\nbool _isCustomModuleAllowed = IFeatureRegistry(getAddressValue(Encoder.getKey(\"featureRegistry\"))).getFeatureStatus(\"customModulesAllowed\");\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',307);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',79);\nuint256 counter = 0;\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',308);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',80);\nfor (uint256 i = 0; i < _len; i++) {\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',309);\n            emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',81);\nif (_isCustomModuleAllowed) {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',23,0);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',310);\n                emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',82);\nif (IOwnable(_addressList[i]).owner() == IOwnable(_securityToken).owner() || getBoolValue(Encoder.getKey(\"verified\", _addressList[i])))\n                    {emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',83);\nemit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',24,0);emit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',311);\nif(_isCompatibleModule(_addressList[i], _securityToken))\n                        {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',25,0);emit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',312);\ncounter++;}else { emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',25,1);}\n}else { emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',24,1);}\n\n            }\n            else {emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',84);\nemit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',23,1);if (getBoolValue(Encoder.getKey(\"verified\", _addressList[i]))) {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',26,0);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',315);\n                emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',85);\nif(_isCompatibleModule(_addressList[i], _securityToken))\n                    {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',27,0);emit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',316);\ncounter++;}else { emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',27,1);}\n\n            }else { emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',26,1);}\n}\n        }\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',319);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',86);\naddress[] memory _tempArray = new address[](counter);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',320);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',87);\ncounter = 0;\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',321);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',88);\nfor (uint256 j = 0; j < _len; j++) {\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',322);\n            emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',89);\nif (_isCustomModuleAllowed) {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',28,0);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',323);\n                emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',90);\nif (IOwnable(_addressList[j]).owner() == IOwnable(_securityToken).owner() || getBoolValue(Encoder.getKey(\"verified\", _addressList[j]))) {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',29,0);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',324);\n                    emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',91);\nif(_isCompatibleModule(_addressList[j], _securityToken)) {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',30,0);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',325);\n                        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',92);\n_tempArray[counter] = _addressList[j];\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',326);\n                        counter ++;\n                    }else { emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',30,1);}\n\n                }else { emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',29,1);}\n\n            }\n            else {emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',93);\nemit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',28,1);if (getBoolValue(Encoder.getKey(\"verified\", _addressList[j]))) {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',31,0);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',331);\n                emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',94);\nif(_isCompatibleModule(_addressList[j], _securityToken)) {emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',32,0);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',332);\n                    emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',95);\n_tempArray[counter] = _addressList[j];\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',333);\n                    counter ++;\n                }else { emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',32,1);}\n\n            }else { emit __BranchCoverageModuleRegistry('./contracts/ModuleRegistry.sol',31,1);}\n}\n        }\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',337);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',96);\nreturn _tempArray;\n    }\n\n    /**\n    * @notice Reclaims all ERC20Basic compatible tokens\n    * @param _tokenContract The address of the token contract\n    */\n    function reclaimERC20(address _tokenContract) external onlyOwner {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',18);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',345);\n        emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',33);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',97);\nrequire(_tokenContract != address(0), \"0x address is invalid\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',33);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',346);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',98);\nIERC20 token = IERC20(_tokenContract);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',347);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',99);\nuint256 balance = token.balanceOf(address(this));\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',348);\n        emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',34);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',100);\nrequire(token.transfer(owner(), balance),\"token transfer failed\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',34);\n\n    }\n\n    /**\n     * @notice Called by the owner to pause, triggers stopped state\n     */\n    function pause() external whenNotPaused onlyOwner {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',19);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',355);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',101);\nset(Encoder.getKey(\"paused\"), true);\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',357);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',102);\nemit Pause(now);\n    }\n\n    /**\n     * @notice Called by the owner to unpause, returns to normal state\n     */\n    function unpause() external whenPaused onlyOwner {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',20);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',364);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',103);\nset(Encoder.getKey(\"paused\"), false);\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',366);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',104);\nemit Unpause(now);\n    }\n\n    /**\n     * @notice Stores the contract addresses of other key contracts from the PolymathRegistry\n     */\n    function updateFromRegistry() external onlyOwner {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',21);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',373);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',105);\naddress _polymathRegistry = getAddressValue(Encoder.getKey(\"polymathRegistry\"));\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',374);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',106);\nset(Encoder.getKey(\"securityTokenRegistry\"), IPolymathRegistry(_polymathRegistry).getAddress(\"SecurityTokenRegistry\"));\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',375);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',107);\nset(Encoder.getKey(\"featureRegistry\"), IPolymathRegistry(_polymathRegistry).getAddress(\"FeatureRegistry\"));\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',376);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',108);\nset(Encoder.getKey(\"polyToken\"), IPolymathRegistry(_polymathRegistry).getAddress(\"PolyToken\"));\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address _newOwner) external onlyOwner {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',22);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',384);\n        emit __AssertPreCoverageModuleRegistry('./contracts/ModuleRegistry.sol',35);\nemit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',109);\nrequire(_newOwner != address(0), \"Invalid address\");emit __AssertPostCoverageModuleRegistry('./contracts/ModuleRegistry.sol',35);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',385);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',110);\nemit OwnershipTransferred(owner(), _newOwner);\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',386);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',111);\nset(Encoder.getKey(\"owner\"), _newOwner);\n    }\n\n    /**\n     * @notice Gets the owner of the contract\n     * @return address owner\n     */\n    function owner() public  returns(address) {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',23);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',394);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',112);\nreturn getAddressValue(Encoder.getKey(\"owner\"));\n    }\n\n    /**\n     * @notice Checks whether the contract operations is paused or not\n     * @return bool\n     */\n    function isPaused() public  returns(bool) {emit __FunctionCoverageModuleRegistry('./contracts/ModuleRegistry.sol',24);\n\nemit __CoverageModuleRegistry('./contracts/ModuleRegistry.sol',402);\n        emit __StatementCoverageModuleRegistry('./contracts/ModuleRegistry.sol',113);\nreturn getBoolValue(Encoder.getKey(\"paused\"));\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/mocks/MockModuleRegistry.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../ModuleRegistry.sol\";\n\n/**\n * @title Registry contract for issuers to register their security tokens\n */\ncontract MockModuleRegistry is ModuleRegistry {\n\n    /// @notice It is dummy functionality\n    /// Alert! Alert! Do not use it for the mainnet release\n    function addMoreReputation(address _moduleFactory, address[] _tokens) public onlyOwner {\n        for (uint8 i = 0; i < _tokens.length; i++) {\n            pushArray(Encoder.getKey(\"reputation\", _moduleFactory), _tokens[i]);\n        }\n    }\n\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/interfaces/IModuleRegistry.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Interface for the Polymath Module Registry contract\n */\ninterface IModuleRegistry {event __CoverageIModuleRegistry(string fileName, uint256 lineNumber);\nevent __FunctionCoverageIModuleRegistry(string fileName, uint256 fnId);\nevent __StatementCoverageIModuleRegistry(string fileName, uint256 statementId);\nevent __BranchCoverageIModuleRegistry(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageIModuleRegistry(string fileName, uint256 branchId);\nevent __AssertPostCoverageIModuleRegistry(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice Called by a security token to notify the registry it is using a module\n     * @param _moduleFactory is the address of the relevant module factory\n     */\n    function useModule(address _moduleFactory) external;\n\n    /**\n     * @notice Called by the ModuleFactory owner to register new modules for SecurityToken to use\n     * @param _moduleFactory is the address of the module factory to be registered\n     */\n    function registerModule(address _moduleFactory) external;\n\n    /**\n     * @notice Called by the ModuleFactory owner or registry curator to delete a ModuleFactory\n     * @param _moduleFactory is the address of the module factory to be deleted\n     */\n    function removeModule(address _moduleFactory) external;\n\n    /**\n    * @notice Called by Polymath to verify modules for SecurityToken to use.\n    * @notice A module can not be used by an ST unless first approved/verified by Polymath\n    * @notice (The only exception to this is that the author of the module is the owner of the ST - Only if enabled by the FeatureRegistry)\n    * @param _moduleFactory is the address of the module factory to be registered\n    */\n    function verifyModule(address _moduleFactory, bool _verified) external;\n\n    /**\n     * @notice Used to get the reputation of a Module Factory\n     * @param _factoryAddress address of the Module Factory\n     * @return address array which has the list of securityToken's uses that module factory\n     */\n    function getReputationByFactory(address _factoryAddress) external  returns(address[]);\n\n    /**\n     * @notice Returns all the tags related to the a module type which are valid for the given token\n     * @param _moduleType is the module type\n     * @param _securityToken is the token\n     * @return list of tags\n     * @return corresponding list of module factories\n     */\n    function getTagsByTypeAndToken(uint8 _moduleType, address _securityToken) external  returns(bytes32[], address[]);\n\n    /**\n     * @notice Returns all the tags related to the a module type which are valid for the given token\n     * @param _moduleType is the module type\n     * @return list of tags\n     * @return corresponding list of module factories\n     */\n    function getTagsByType(uint8 _moduleType) external  returns(bytes32[], address[]);\n\n    /**\n     * @notice Returns the list of addresses of Module Factory of a particular type\n     * @param _moduleType Type of Module\n     * @return address array that contains the list of addresses of module factory contracts.\n     */\n    function getModulesByType(uint8 _moduleType) external  returns(address[]);\n\n    /**\n     * @notice Returns the list of available Module factory addresses of a particular type for a given token.\n     * @param _moduleType is the module type to look for\n     * @param _securityToken is the address of SecurityToken\n     * @return address array that contains the list of available addresses of module factory contracts.\n     */\n    function getModulesByTypeAndToken(uint8 _moduleType, address _securityToken) external  returns (address[]);\n\n    /**\n     * @notice Use to get the latest contract address of the regstries\n     */\n    function updateFromRegistry() external;\n\n    /**\n     * @notice Get the owner of the contract\n     * @return address owner\n     */\n    function owner() external  returns(address);\n\n    /**\n     * @notice Check whether the contract operations is paused or not\n     * @return bool \n     */\n    function isPaused() external  returns(bool);\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/interfaces/IModuleFactory.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Interface that every module factory contract should implement\n */\ninterface IModuleFactory {event __CoverageIModuleFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageIModuleFactory(string fileName, uint256 fnId);\nevent __StatementCoverageIModuleFactory(string fileName, uint256 statementId);\nevent __BranchCoverageIModuleFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageIModuleFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageIModuleFactory(string fileName, uint256 branchId);\n\n\n    event ChangeFactorySetupFee(uint256 _oldSetupCost, uint256 _newSetupCost, address _moduleFactory);\n    event ChangeFactoryUsageFee(uint256 _oldUsageCost, uint256 _newUsageCost, address _moduleFactory);\n    event ChangeFactorySubscriptionFee(uint256 _oldSubscriptionCost, uint256 _newMonthlySubscriptionCost, address _moduleFactory);\n    event GenerateModuleFromFactory(\n        address _module,\n        bytes32 indexed _moduleName,\n        address indexed _moduleFactory,\n        address _creator,\n        uint256 _setupCost,\n        uint256 _timestamp\n    );\n    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);\n\n    //Should create an instance of the Module, or throw\n    function deploy(bytes _data) external returns(address);\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]);\n\n    /**\n     * @notice Get the name of the Module\n     */\n    function getName() external  returns(bytes32);\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns (string);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns (bytes32[]);\n\n    /**\n     * @notice Used to change the setup fee\n     * @param _newSetupCost New setup fee\n     */\n    function changeFactorySetupFee(uint256 _newSetupCost) external;\n\n    /**\n     * @notice Used to change the usage fee\n     * @param _newUsageCost New usage fee\n     */\n    function changeFactoryUsageFee(uint256 _newUsageCost) external;\n\n    /**\n     * @notice Used to change the subscription fee\n     * @param _newSubscriptionCost New subscription fee\n     */\n    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) external;\n\n    /**\n     * @notice Function use to change the lower and upper bound of the compatible version st\n     * @param _boundType Type of bound\n     * @param _newVersion New version array\n     */\n    function changeSTVersionBounds(string _boundType, uint8[] _newVersion) external;\n\n   /**\n     * @notice Get the setup cost of the module\n     */\n    function getSetupCost() external  returns (uint256);\n\n    /**\n     * @notice Used to get the lower bound\n     * @return Lower bound\n     */\n    function getLowerSTVersionBounds() external  returns(uint8[]);\n\n     /**\n     * @notice Used to get the upper bound\n     * @return Upper bound\n     */\n    function getUpperSTVersionBounds() external  returns(uint8[]);\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/interfaces/ISecurityTokenRegistry.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Interface for the Polymath Security Token Registry contract\n */\ninterface ISecurityTokenRegistry {event __CoverageISecurityTokenRegistry(string fileName, uint256 lineNumber);\nevent __FunctionCoverageISecurityTokenRegistry(string fileName, uint256 fnId);\nevent __StatementCoverageISecurityTokenRegistry(string fileName, uint256 statementId);\nevent __BranchCoverageISecurityTokenRegistry(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageISecurityTokenRegistry(string fileName, uint256 branchId);\nevent __AssertPostCoverageISecurityTokenRegistry(string fileName, uint256 branchId);\n\n\n   /**\n     * @notice Creates a new Security Token and saves it to the registry\n     * @param _name Name of the token\n     * @param _ticker Ticker ticker of the security token\n     * @param _tokenDetails Off-chain details of the token\n     * @param _divisible Whether the token is divisible or not\n     */\n    function generateSecurityToken(string _name, string _ticker, string _tokenDetails, bool _divisible) external;\n\n    /**\n     * @notice Adds a new custom Security Token and saves it to the registry. (Token should follow the ISecurityToken interface)\n     * @param _name Name of the token\n     * @param _ticker Ticker of the security token\n     * @param _owner Owner of the token\n     * @param _securityToken Address of the securityToken\n     * @param _tokenDetails Off-chain details of the token\n     * @param _deployedAt Timestamp at which security token comes deployed on the ethereum blockchain\n     */\n    function modifySecurityToken(\n        string _name,\n        string _ticker,\n        address _owner,\n        address _securityToken,\n        string _tokenDetails,\n        uint256 _deployedAt\n    )\n        external;\n\n    /**\n     * @notice Registers the token ticker for its particular owner\n     * @notice once the token ticker is registered to its owner then no other issuer can claim\n     * @notice its ownership. If the ticker expires and its issuer hasn't used it, then someone else can take it.\n     * @param _owner Address of the owner of the token\n     * @param _ticker Token ticker\n     * @param _tokenName Name of the token\n     */\n    function registerTicker(address _owner, string _ticker, string _tokenName) external;\n\n    /**\n    * @notice Changes the protocol version and the SecurityToken contract\n    * @notice Used only by Polymath to upgrade the SecurityToken contract and add more functionalities to future versions\n    * @notice Changing versions does not affect existing tokens.\n    * @param _STFactoryAddress Address of the proxy.\n    * @param _major Major version of the proxy.\n    * @param _minor Minor version of the proxy.\n    * @param _patch Patch version of the proxy\n    */\n    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) external;\n\n    /**\n    * @notice Check that Security Token is registered\n    * @param _securityToken Address of the Scurity token\n    * @return bool\n    */\n    function isSecurityToken(address _securityToken) external  returns (bool);\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address _newOwner) external;\n\n    /**\n     * @notice Get security token address by ticker name\n     * @param _ticker Symbol of the Scurity token\n     * @return address\n     */\n    function getSecurityTokenAddress(string _ticker) external  returns (address);\n\n     /**\n     * @notice Get security token data by its address\n     * @param _securityToken Address of the Scurity token.\n     * @return string Symbol of the Security Token.\n     * @return address Address of the issuer of Security Token.\n     * @return string Details of the Token.\n     * @return uint256 Timestamp at which Security Token get launched on Polymath platform.\n     */\n    function getSecurityTokenData(address _securityToken) external  returns (string, address, string, uint256);\n\n    /**\n     * @notice Get the current STFactory Address\n     */\n    function getSTFactoryAddress() external  returns(address);\n\n    /**\n     * @notice Get Protocol version\n     */\n    function getProtocolVersion() external  returns(uint8[]);\n\n    /**\n     * @notice Used to get the ticker list as per the owner\n     * @param _owner Address which owns the list of tickers\n     */\n    function getTickersByOwner(address _owner) external  returns(bytes32[]);\n\n    /**\n     * @notice Returns the list of tokens owned by the selected address\n     * @param _owner is the address which owns the list of tickers\n     * @dev Intention is that this is called off-chain so block gas limit is not relevant\n     */\n    function getTokensByOwner(address _owner) external  returns(address[]);\n\n    /**\n     * @notice Returns the owner and timestamp for a given ticker\n     * @param _ticker ticker\n     * @return address\n     * @return uint256\n     * @return uint256\n     * @return string\n     * @return bool\n     */\n    function getTickerDetails(string _ticker) external  returns (address, uint256, uint256, string, bool);\n\n    /**\n     * @notice Modifies the ticker details. Only polymath account has the ability\n     * to do so. Only allowed to modify the tickers which are not yet deployed\n     * @param _owner Owner of the token\n     * @param _ticker Token ticker\n     * @param _tokenName Name of the token\n     * @param _registrationDate Date on which ticker get registered\n     * @param _expiryDate Expiry date of the ticker\n     * @param _status Token deployed status\n     */\n    function modifyTicker(\n        address _owner,\n        string _ticker,\n        string _tokenName,\n        uint256 _registrationDate,\n        uint256 _expiryDate,\n        bool _status\n    )\n        external;\n\n     /**\n     * @notice Removes the ticker details and associated ownership & security token mapping\n     * @param _ticker Token ticker\n     */\n    function removeTicker(string _ticker) external;\n\n    /**\n     * @notice Transfers the ownership of the ticker\n     * @dev _newOwner Address whom ownership to transfer\n     * @dev _ticker Ticker\n     */\n    function transferTickerOwnership(address _newOwner, string _ticker) external;\n\n    /**\n     * @notice Changes the expiry time for the token ticker\n     * @param _newExpiry New time period for token ticker expiry\n     */\n    function changeExpiryLimit(uint256 _newExpiry) external;\n\n    /**\n    * @notice Sets the ticker registration fee in POLY tokens\n    * @param _tickerRegFee Registration fee in POLY tokens (base 18 decimals)\n    */\n   function changeTickerRegistrationFee(uint256 _tickerRegFee) external;\n\n   /**\n    * @notice Sets the ticker registration fee in POLY tokens\n    * @param _stLaunchFee Registration fee in POLY tokens (base 18 decimals)\n    */\n   function changeSecurityLaunchFee(uint256 _stLaunchFee) external;\n\n    /**\n     * @notice Change the PolyToken address\n     * @param _newAddress Address of the polytoken\n     */\n    function updatePolyTokenAddress(address _newAddress) external;\n\n    /**\n     * @notice Gets the security token launch fee\n     * @return Fee amount\n     */\n    function getSecurityTokenLaunchFee() external  returns(uint256);\n\n    /**\n     * @notice Gets the ticker registration fee\n     * @return Fee amount\n     */\n    function getTickerRegistrationFee() external  returns(uint256);\n\n    /**\n     * @notice Gets the expiry limit\n     * @return Expiry limit\n     */\n    function getExpiryLimit() external  returns(uint256);\n\n    /**\n     * @notice Checks whether the registry is paused or not\n     * @return bool\n     */\n    function isPaused() external  returns(bool);\n\n    /**\n     * @notice Gets the owner of the contract\n     * @return address owner\n     */\n    function owner() external  returns(address);\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/interfaces/IPolymathRegistry.sol":{"content":"pragma solidity ^0.4.24;\n\n    \ninterface IPolymathRegistry {event __CoverageIPolymathRegistry(string fileName, uint256 lineNumber);\nevent __FunctionCoverageIPolymathRegistry(string fileName, uint256 fnId);\nevent __StatementCoverageIPolymathRegistry(string fileName, uint256 statementId);\nevent __BranchCoverageIPolymathRegistry(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageIPolymathRegistry(string fileName, uint256 branchId);\nevent __AssertPostCoverageIPolymathRegistry(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice Returns the contract address\n     * @param _nameKey is the key for the contract address mapping\n     * @return address\n     */\n    function getAddress(string _nameKey) external  returns(address);\n\n}\n    "},"/home/max/Desktop/Ethereum/polymath-core/contracts/libraries/VersionUtils.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Helper library use to compare or validate the semantic versions\n */\n\nlibrary VersionUtils {event __CoverageVersionUtils(string fileName, uint256 lineNumber);\nevent __FunctionCoverageVersionUtils(string fileName, uint256 fnId);\nevent __StatementCoverageVersionUtils(string fileName, uint256 statementId);\nevent __BranchCoverageVersionUtils(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageVersionUtils(string fileName, uint256 branchId);\nevent __AssertPostCoverageVersionUtils(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice This function is used to validate the version submitted\n     * @param _current Array holds the present version of ST\n     * @param _new Array holds the latest version of the ST\n     * @return bool\n     */\n    function isValidVersion(uint8[] _current, uint8[] _new) internal  returns(bool) {emit __FunctionCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',1);\n\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',16);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',1);\nbool[] memory _temp = new bool[](_current.length);\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',17);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',2);\nuint8 counter = 0;\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',18);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',3);\nfor (uint8 i = 0; i < _current.length; i++) {\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',19);\n            emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',4);\nif (_current[i] < _new[i])\n                {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',5);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',1,0);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',20);\n_temp[i] = true;}\n            else\n                {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',6);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',1,1);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',22);\n_temp[i] = false;}\n        }\n\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',25);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',7);\nfor (i = 0; i < _current.length; i++) {\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',26);\n            emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',8);\nif (i == 0) {emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',2,0);\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',27);\n                emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',9);\nif (_current[i] <= _new[i])\n                    {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',10);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',3,0);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',28);\nif(_temp[0]) {emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',4,0);\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',29);\n                        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',11);\ncounter = counter + 3;\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',30);\n                        break;\n                    } else\n                        {emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',4,1);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',32);\ncounter++;}}\n                else\n                    {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',12);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',3,1);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',34);\nreturn false;}\n            } else {emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',2,1);\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',36);\n                emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',13);\nif (_temp[i-1])\n                    {emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',5,0);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',37);\ncounter++;}\n                else {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',14);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',5,1);if (_current[i] <= _new[i])\n                    {emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',6,0);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',39);\ncounter++;}\n                else\n                    {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',15);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',6,1);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',41);\nreturn false;}}\n            }\n        }\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',44);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',16);\nif (counter == _current.length)\n            {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',17);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',7,0);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',45);\nreturn true;}else { emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',7,1);}\n\n    }\n\n    /**\n     * @notice Used to compare the lower bound with the latest version\n     * @param _version1 Array holds the lower bound of the version\n     * @param _version2 Array holds the latest version of the ST\n     * @return bool\n     */\n    function compareLowerBound(uint8[] _version1, uint8[] _version2) internal  returns(bool) {emit __FunctionCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',2);\n\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',55);\n        emit __AssertPreCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',8);\nemit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',18);\nrequire(_version1.length == _version2.length, \"Input length mismatch\");emit __AssertPostCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',8);\n\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',56);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',19);\nuint counter = 0;\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',57);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',20);\nfor (uint8 j = 0; j < _version1.length; j++) {\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',58);\n            emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',21);\nif (_version1[j] == 0)\n                {emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',9,0);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',59);\ncounter ++;}else { emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',9,1);}\n\n        }\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',61);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',22);\nif (counter != _version1.length) {emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',10,0);\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',62);\n            emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',23);\ncounter = 0;\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',63);\n            emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',24);\nfor (uint8 i = 0; i < _version1.length; i++) {\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',64);\n                emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',25);\nif (_version2[i] > _version1[i])\n                    {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',26);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',11,0);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',65);\nreturn true;}\n                else {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',27);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',11,1);if (_version2[i] < _version1[i])\n                    {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',28);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',12,0);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',67);\nreturn false;}\n                else\n                    {emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',12,1);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',69);\ncounter++;}}\n            }\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',71);\n            emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',29);\nif (counter == _version1.length - 1)\n                {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',30);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',13,0);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',72);\nreturn true;}\n            else\n                {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',31);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',13,1);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',74);\nreturn false;}\n        } else\n            {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',32);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',10,1);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',76);\nreturn true;}\n    }\n\n    /**\n     * @notice Used to compare the upper bound with the latest version\n     * @param _version1 Array holds the upper bound of the version\n     * @param _version2 Array holds the latest version of the ST\n     * @return bool\n     */\n    function compareUpperBound(uint8[] _version1, uint8[] _version2) internal  returns(bool) {emit __FunctionCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',3);\n\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',86);\n        emit __AssertPreCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',14);\nemit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',33);\nrequire(_version1.length == _version2.length, \"Input length mismatch\");emit __AssertPostCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',14);\n\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',87);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',34);\nuint counter = 0;\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',88);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',35);\nfor (uint8 j = 0; j < _version1.length; j++) {\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',89);\n            emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',36);\nif (_version1[j] == 0)\n                {emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',15,0);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',90);\ncounter ++;}else { emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',15,1);}\n\n        }\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',92);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',37);\nif (counter != _version1.length) {emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',16,0);\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',93);\n            emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',38);\ncounter = 0;\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',94);\n            emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',39);\nfor (uint8 i = 0; i < _version1.length; i++) {\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',95);\n                emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',40);\nif (_version1[i] > _version2[i])\n                    {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',41);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',17,0);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',96);\nreturn true;}\n                else {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',42);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',17,1);if (_version1[i] < _version2[i])\n                    {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',43);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',18,0);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',98);\nreturn false;}\n                else\n                    {emit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',18,1);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',100);\ncounter++;}}\n            }\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',102);\n            emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',44);\nif (counter == _version1.length - 1)\n                {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',45);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',19,0);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',103);\nreturn true;}\n            else\n                {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',46);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',19,1);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',105);\nreturn false;}\n        } else\n            {emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',47);\nemit __BranchCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',16,1);emit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',107);\nreturn true;}\n    }\n\n\n    /**\n     * @notice Used to pack the uint8[] array data into uint24 value\n     * @param _major Major version\n     * @param _minor Minor version\n     * @param _patch Patch version\n     */\n    function pack(uint8 _major, uint8 _minor, uint8 _patch) internal  returns(uint24) {emit __FunctionCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',4);\n\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',118);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',48);\nreturn (uint24(_major) << 16) | (uint24(_minor) << 8) | uint24(_patch);\n    }\n\n    /**\n     * @notice Used to convert packed data into uint8 array\n     * @param _packedVersion Packed data\n     */\n    function unpack(uint24 _packedVersion) internal  returns (uint8[]) {emit __FunctionCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',5);\n\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',126);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',49);\nuint8[] memory _unpackVersion = new uint8[](3);\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',127);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',50);\n_unpackVersion[0] = uint8(_packedVersion >> 16);\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',128);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',51);\n_unpackVersion[1] = uint8(_packedVersion >> 8);\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',129);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',52);\n_unpackVersion[2] = uint8(_packedVersion);\nemit __CoverageVersionUtils('./contracts/libraries/VersionUtils.sol',130);\n        emit __StatementCoverageVersionUtils('./contracts/libraries/VersionUtils.sol',53);\nreturn _unpackVersion;\n    }\n\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/storage/EternalStorage.sol":{"content":"pragma solidity ^0.4.24;\n\ncontract EternalStorage {\n\n    /// @notice Internal mappings used to store all kinds on data into the contract\n    mapping(bytes32 => uint256) internal uintStorage;\n    mapping(bytes32 => string) internal stringStorage;\n    mapping(bytes32 => address) internal addressStorage;\n    mapping(bytes32 => bytes) internal bytesStorage;\n    mapping(bytes32 => bool) internal boolStorage;\n    mapping(bytes32 => int256) internal intStorage;\n    mapping(bytes32 => bytes32) internal bytes32Storage;\n\n    /// @notice Internal mappings used to store arrays of different data types\n    mapping(bytes32 => bytes32[]) internal bytes32ArrayStorage;\n    mapping(bytes32 => uint256[]) internal uintArrayStorage;\n    mapping(bytes32 => address[]) internal addressArrayStorage;\n    mapping(bytes32 => string[]) internal stringArrayStorage;\n\n    //////////////////\n    //// set functions\n    //////////////////\n    /// @notice Set the key values using the Overloaded `set` functions\n    /// Ex- string version = \"0.0.1\"; replace to\n    /// set(keccak256(abi.encodePacked(\"version\"), \"0.0.1\");\n    /// same for the other variables as well some more example listed below\n    /// ex1 - address securityTokenAddress = 0x123; replace to\n    /// set(keccak256(abi.encodePacked(\"securityTokenAddress\"), 0x123);\n    /// ex2 - bytes32 tokenDetails = \"I am ST20\"; replace to\n    /// set(keccak256(abi.encodePacked(\"tokenDetails\"), \"I am ST20\");\n    /// ex3 - mapping(string => address) ownedToken;\n    /// set(keccak256(abi.encodePacked(\"ownedToken\", \"Chris\")), 0x123);\n    /// ex4 - mapping(string => uint) tokenIndex;\n    /// tokenIndex[\"TOKEN\"] = 1; replace to set(keccak256(abi.encodePacked(\"tokenIndex\", \"TOKEN\"), 1);\n    /// ex5 - mapping(string => SymbolDetails) registeredSymbols; where SymbolDetails is the structure having different type of values as\n    /// {uint256 date, string name, address owner} etc.\n    /// registeredSymbols[\"TOKEN\"].name = \"MyFristToken\"; replace to set(keccak256(abi.encodePacked(\"registeredSymbols_name\", \"TOKEN\"), \"MyFirstToken\");\n    /// More generalized- set(keccak256(abi.encodePacked(\"registeredSymbols_<struct variable>\", \"keyname\"), \"value\");\n\n    function set(bytes32 _key, uint256 _value) internal {\n        uintStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, address _value) internal {\n        addressStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bool _value) internal {\n        boolStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bytes32 _value) internal {\n        bytes32Storage[_key] = _value;\n    }\n\n    function set(bytes32 _key, string _value) internal {\n        stringStorage[_key] = _value;\n    }\n\n    ////////////////////////////\n    // deleteArray functions\n    ////////////////////////////\n    /// @notice Function used to delete the array element.\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByOwner;\n    /// For deleting the item from array developers needs to create a funtion for that similarly\n    /// in this case we have the helper function deleteArrayBytes32() which will do it for us\n    /// deleteArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1), 3); -- it will delete the index 3\n\n\n    //Deletes from mapping (bytes32 => array[]) at index _index\n    function deleteArrayAddress(bytes32 _key, uint256 _index) internal {\n        address[] storage array = addressArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => bytes32[]) at index _index\n    function deleteArrayBytes32(bytes32 _key, uint256 _index) internal {\n        bytes32[] storage array = bytes32ArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => uint[]) at index _index\n    function deleteArrayUint(bytes32 _key, uint256 _index) internal {\n        uint256[] storage array = uintArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => string[]) at index _index\n    function deleteArrayString(bytes32 _key, uint256 _index) internal {\n        string[] storage array = stringArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    ////////////////////////////\n    //// pushArray functions\n    ///////////////////////////\n    /// @notice Below are the helper functions to facilitate storing arrays of different data types.\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByTicker;\n    /// tokensOwnedByTicker[owner] = tokensOwnedByTicker[owner].push(\"xyz\"); replace with\n    /// pushArray(keccak256(abi.encodePacked(\"tokensOwnedByTicker\", owner), \"xyz\");\n\n    /// @notice use to store the values for the array\n    /// @param _key bytes32 type\n    /// @param _value [uint256, string, bytes32, address] any of the data type in array\n    function pushArray(bytes32 _key, address _value) internal {\n        addressArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, bytes32 _value) internal {\n        bytes32ArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, string _value) internal {\n        stringArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, uint256 _value) internal {\n        uintArrayStorage[_key].push(_value);\n    }\n\n    /////////////////////////\n    //// Set Array functions\n    ////////////////////////\n    /// @notice used to intialize the array\n    /// Ex1- mapping (address => address[]) public reputation;\n    /// reputation[0x1] = new address[](0); It can be replaced as\n    /// setArray(hash('reputation', 0x1), new address[](0)); \n    \n    function setArray(bytes32 _key, address[] _value) internal {\n        addressArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, uint256[] _value) internal {\n        uintArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, bytes32[] _value) internal {\n        bytes32ArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, string[] _value) internal {\n        stringArrayStorage[_key] = _value;\n    }\n\n    /////////////////////////\n    /// getArray functions\n    /////////////////////////\n    /// @notice Get functions to get the array of the required data type\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByOwner;\n    /// getArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1)); It return the bytes32 array\n    /// Ex2- uint256 _len =  tokensOwnedByOwner[0x1].length; replace with\n    /// getArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1)).length;\n\n    function getArrayAddress(bytes32 _key) public view returns(address[]) {\n        return addressArrayStorage[_key];\n    }\n\n    function getArrayBytes32(bytes32 _key) public view returns(bytes32[]) {\n        return bytes32ArrayStorage[_key];\n    }\n\n    function getArrayUint(bytes32 _key) public view returns(uint[]) {\n        return uintArrayStorage[_key];\n    }\n\n    ///////////////////////////////////\n    /// setArrayIndexValue() functions\n    ///////////////////////////////////\n    /// @notice set the value of particular index of the address array\n    /// Ex1- mapping(bytes32 => address[]) moduleList;\n    /// general way is -- moduleList[moduleType][index] = temp; \n    /// It can be re-write as -- setArrayIndexValue(keccak256(abi.encodePacked('moduleList', moduleType)), index, temp); \n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, address _value) internal {\n        addressArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, uint256 _value) internal {\n        uintArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, bytes32 _value) internal {\n        bytes32ArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, string _value) internal {\n        stringArrayStorage[_key][_index] = _value;\n    }\n\n    /// Public getters functions\n    ////////////////////\n    /// @notice Get function use to get the value of the singleton state variables\n    /// Ex1- string public version = \"0.0.1\";\n    /// string _version = getString(keccak256(abi.encodePacked(\"version\"));\n    /// Ex2 - assert(temp1 == temp2); replace to\n    /// assert(getUint(keccak256(abi.encodePacked(temp1)) == getUint(keccak256(abi.encodePacked(temp2));\n    /// Ex3 - mapping(string => SymbolDetails) registeredSymbols; where SymbolDetails is the structure having different type of values as\n    /// {uint256 date, string name, address owner} etc.\n    /// string _name = getString(keccak256(abi.encodePacked(\"registeredSymbols_name\", \"TOKEN\"));\n\n    function getUintValue(bytes32 _variable) public view returns(uint256) {\n        return uintStorage[_variable];\n    }\n\n    function getBoolValue(bytes32 _variable) public view returns(bool) {\n        return boolStorage[_variable];\n    }\n\n    function getStringValue(bytes32 _variable) public view returns(string) {\n        return stringStorage[_variable];\n    }\n\n    function getAddressValue(bytes32 _variable) public view returns(address) {\n        return addressStorage[_variable];\n    }\n\n    function getBytes32Value(bytes32 _variable) public view returns(bytes32) {\n        return bytes32Storage[_variable];\n    }\n\n    function getBytesValue(bytes32 _variable) public view returns(bytes) {\n        return bytesStorage[_variable];\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/libraries/Encoder.sol":{"content":"pragma solidity ^0.4.24;\n\nlibrary Encoder {event __CoverageEncoder(string fileName, uint256 lineNumber);\nevent __FunctionCoverageEncoder(string fileName, uint256 fnId);\nevent __StatementCoverageEncoder(string fileName, uint256 statementId);\nevent __BranchCoverageEncoder(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageEncoder(string fileName, uint256 branchId);\nevent __AssertPostCoverageEncoder(string fileName, uint256 branchId);\n\n\n    function getKey(string _key) internal  returns (bytes32) {emit __FunctionCoverageEncoder('./contracts/libraries/Encoder.sol',1);\n\nemit __CoverageEncoder('./contracts/libraries/Encoder.sol',6);\n        emit __StatementCoverageEncoder('./contracts/libraries/Encoder.sol',1);\nreturn bytes32(keccak256(abi.encodePacked(_key)));\n    }\n\n    function getKey(string _key1, address _key2) internal  returns (bytes32) {emit __FunctionCoverageEncoder('./contracts/libraries/Encoder.sol',2);\n\nemit __CoverageEncoder('./contracts/libraries/Encoder.sol',10);\n        emit __StatementCoverageEncoder('./contracts/libraries/Encoder.sol',2);\nreturn bytes32(keccak256(abi.encodePacked(_key1, _key2)));\n    }\n\n    function getKey(string _key1, string _key2) internal  returns (bytes32) {emit __FunctionCoverageEncoder('./contracts/libraries/Encoder.sol',3);\n\nemit __CoverageEncoder('./contracts/libraries/Encoder.sol',14);\n        emit __StatementCoverageEncoder('./contracts/libraries/Encoder.sol',3);\nreturn bytes32(keccak256(abi.encodePacked(_key1, _key2)));\n    }\n\n    function getKey(string _key1, uint256 _key2) internal  returns (bytes32) {emit __FunctionCoverageEncoder('./contracts/libraries/Encoder.sol',4);\n\nemit __CoverageEncoder('./contracts/libraries/Encoder.sol',18);\n        emit __StatementCoverageEncoder('./contracts/libraries/Encoder.sol',4);\nreturn bytes32(keccak256(abi.encodePacked(_key1, _key2)));\n    }\n\n    function getKey(string _key1, bytes32 _key2) internal  returns (bytes32) {emit __FunctionCoverageEncoder('./contracts/libraries/Encoder.sol',5);\n\nemit __CoverageEncoder('./contracts/libraries/Encoder.sol',22);\n        emit __StatementCoverageEncoder('./contracts/libraries/Encoder.sol',5);\nreturn bytes32(keccak256(abi.encodePacked(_key1, _key2)));\n    }\n\n    function getKey(string _key1, bool _key2) internal  returns (bytes32) {emit __FunctionCoverageEncoder('./contracts/libraries/Encoder.sol',6);\n\nemit __CoverageEncoder('./contracts/libraries/Encoder.sol',26);\n        emit __StatementCoverageEncoder('./contracts/libraries/Encoder.sol',6);\nreturn bytes32(keccak256(abi.encodePacked(_key1, _key2)));\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/interfaces/IOwnable.sol":{"content":"pragma solidity ^0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ninterface IOwnable {event __CoverageIOwnable(string fileName, uint256 lineNumber);\nevent __FunctionCoverageIOwnable(string fileName, uint256 fnId);\nevent __StatementCoverageIOwnable(string fileName, uint256 statementId);\nevent __BranchCoverageIOwnable(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageIOwnable(string fileName, uint256 branchId);\nevent __AssertPostCoverageIOwnable(string fileName, uint256 branchId);\n\n    /**\n    * @dev Returns owner\n    */\n    function owner() external  returns (address);\n\n    /**\n    * @dev Allows the current owner to relinquish control of the contract.\n    */\n    function renounceOwnership() external;\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address _newOwner) external;\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/interfaces/ISecurityToken.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Interface for all security tokens\n */\ninterface ISecurityToken {event __CoverageISecurityToken(string fileName, uint256 lineNumber);\nevent __FunctionCoverageISecurityToken(string fileName, uint256 fnId);\nevent __StatementCoverageISecurityToken(string fileName, uint256 statementId);\nevent __BranchCoverageISecurityToken(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageISecurityToken(string fileName, uint256 branchId);\nevent __AssertPostCoverageISecurityToken(string fileName, uint256 branchId);\n\n\n    // Standard ERC20 interface\n    function decimals() external  returns (uint8);\n    function totalSupply() external  returns (uint256);\n    function balanceOf(address _owner) external  returns (uint256);\n    function allowance(address _owner, address _spender) external  returns (uint256);\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\n    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    //transfer, transferFrom must respect the result of verifyTransfer\n    function verifyTransfer(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /**\n     * @notice Mints new tokens and assigns them to the target _investor.\n     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\n     * @param _investor Address the tokens will be minted to\n     * @param _value is the amount of tokens that will be minted to the investor\n     */\n    function mint(address _investor, uint256 _value) external returns (bool success);\n\n    /**\n     * @notice Mints new tokens and assigns them to the target _investor.\n     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\n     * @param _investor Address the tokens will be minted to\n     * @param _value is The amount of tokens that will be minted to the investor\n     * @param _data Data to indicate validation\n     */\n    function mintWithData(address _investor, uint256 _value, bytes _data) external returns (bool success);\n\n    /**\n     * @notice Used to burn the securityToken on behalf of someone else\n     * @param _from Address for whom to burn tokens\n     * @param _value No. of tokens to be burned\n     * @param _data Data to indicate validation\n     */\n    function burnFromWithData(address _from, uint256 _value, bytes _data) external;\n\n    /**\n     * @notice Used to burn the securityToken\n     * @param _value No. of tokens to be burned\n     * @param _data Data to indicate validation\n     */\n    function burnWithData(uint256 _value, bytes _data) external;\n\n    event Minted(address indexed _to, uint256 _value);\n    event Burnt(address indexed _burner, uint256 _value);\n\n    // Permissions this to a Permission module, which has a key of 1\n    // If no Permission return false - note that IModule withPerm will allow ST owner all permissions anyway\n    // this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external  returns (bool);\n\n    /**\n     * @notice Returns module list for a module type\n     * @param _module Address of the module\n     * @return bytes32 Name\n     * @return address Module address\n     * @return address Module factory address\n     * @return bool Module archived\n     * @return uint8 Module type\n     * @return uint256 Module index\n     * @return uint256 Name index\n\n     */\n    function getModule(address _module) external  returns(bytes32, address, address, bool, uint8, uint256, uint256);\n\n    /**\n     * @notice Returns module list for a module name\n     * @param _name Name of the module\n     * @return address[] List of modules with this name\n     */\n    function getModulesByName(bytes32 _name) external  returns (address[]);\n\n    /**\n     * @notice Returns module list for a module type\n     * @param _type Type of the module\n     * @return address[] List of modules with this type\n     */\n    function getModulesByType(uint8 _type) external  returns (address[]);\n\n    /**\n     * @notice Queries totalSupply at a specified checkpoint\n     * @param _checkpointId Checkpoint ID to query as of\n     */\n    function totalSupplyAt(uint256 _checkpointId) external  returns (uint256);\n\n    /**\n     * @notice Queries balance at a specified checkpoint\n     * @param _investor Investor to query balance for\n     * @param _checkpointId Checkpoint ID to query as of\n     */\n    function balanceOfAt(address _investor, uint256 _checkpointId) external  returns (uint256);\n\n    /**\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\n     */\n    function createCheckpoint() external returns (uint256);\n\n    /**\n     * @notice Gets length of investors array\n     * NB - this length may differ from investorCount if the list has not been pruned of zero-balance investors\n     * @return Length\n     */\n    function getInvestors() external  returns (address[]);\n\n    /**\n     * @notice returns an array of investors at a given checkpoint\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\n     * @return list of investors\n     */\n    function getInvestorsAt(uint256 _checkpointId) external  returns(address[]);\n\n    /**\n     * @notice generates subset of investors\n     * NB - can be used in batches if investor list is large\n     * @param _start Position of investor to start iteration from\n     * @param _end Position of investor to stop iteration at\n     * @return list of investors\n     */\n    function iterateInvestors(uint256 _start, uint256 _end) external  returns(address[]);\n    \n    /**\n     * @notice Gets current checkpoint ID\n     * @return Id\n     */\n    function currentCheckpointId() external  returns (uint256);\n\n    /**\n    * @notice Gets an investor at a particular index\n    * @param _index Index to return address from\n    * @return Investor address\n    */\n    function investors(uint256 _index) external  returns (address);\n\n   /**\n    * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\n    * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\n    * @param _tokenContract Address of the ERC20Basic compliance token\n    * @param _value Amount of POLY to withdraw\n    */\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\n\n    /**\n    * @notice Allows owner to approve more POLY to one of the modules\n    * @param _module Module address\n    * @param _budget New budget\n    */\n    function changeModuleBudget(address _module, uint256 _budget) external;\n\n    /**\n     * @notice Changes the tokenDetails\n     * @param _newTokenDetails New token details\n     */\n    function updateTokenDetails(string _newTokenDetails) external;\n\n    /**\n    * @notice Allows the owner to change token granularity\n    * @param _granularity Granularity level of the token\n    */\n    function changeGranularity(uint256 _granularity) external;\n\n    /**\n    * @notice Removes addresses with zero balances from the investors list\n    * @param _start Index in investors list at which to start removing zero balances\n    * @param _iters Max number of iterations of the for loop\n    * NB - pruning this list will mean you may not be able to iterate over investors on-chain as of a historical checkpoint\n    */\n    function pruneInvestors(uint256 _start, uint256 _iters) external;\n\n    /**\n     * @notice Freezes all the transfers\n     */\n    function freezeTransfers() external;\n\n    /**\n     * @notice Un-freezes all the transfers\n     */\n    function unfreezeTransfers() external;\n\n    /**\n     * @notice Ends token minting period permanently\n     */\n    function freezeMinting() external;\n\n    /**\n     * @notice Mints new tokens and assigns them to the target investors.\n     * Can only be called by the STO attached to the token or by the Issuer (Security Token contract owner)\n     * @param _investors A list of addresses to whom the minted tokens will be delivered\n     * @param _values A list of the amount of tokens to mint to corresponding addresses from _investor[] list\n     * @return Success\n     */\n    function mintMulti(address[] _investors, uint256[] _values) external returns (bool success);\n\n    /**\n     * @notice Function used to attach a module to the security token\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\n     * @dev to control restrictions on transfers.\n     * @dev You are allowed to add a new moduleType if:\n     * @dev - there is no existing module of that type yet added\n     * @dev - the last member of the module list is replacable\n     * @param _moduleFactory is the address of the module factory to be added\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\n     */\n    function addModule(\n        address _moduleFactory,\n        bytes _data,\n        uint256 _maxCost,\n        uint256 _budget\n    ) external;\n\n    /**\n    * @notice Archives a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function archiveModule(address _module) external;\n\n    /**\n    * @notice Unarchives a module attached to the SecurityToken\n    * @param _module address of module to unarchive\n    */\n    function unarchiveModule(address _module) external;\n\n    /**\n    * @notice Removes a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function removeModule(address _module) external;\n\n    /**\n     * @notice Used by the issuer to set the controller addresses\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) external;\n\n    /**\n     * @notice Used by a controller to execute a forced transfer\n     * @param _from address from which to take tokens\n     * @param _to address where to send tokens\n     * @param _value amount of tokens to transfer\n     * @param _data data to indicate validation\n     * @param _log data attached to the transfer by controller to emit in event\n     */\n    function forceTransfer(address _from, address _to, uint256 _value, bytes _data, bytes _log) external;\n\n    /**\n     * @notice Used by a controller to execute a foced burn\n     * @param _from address from which to take tokens\n     * @param _value amount of tokens to transfer\n     * @param _data data to indicate validation\n     * @param _log data attached to the transfer by controller to emit in event\n     */\n    function forceBurn(address _from, uint256 _value, bytes _data, bytes _log) external;\n\n    /**\n     * @notice Used by the issuer to permanently disable controller functionality\n     * @dev enabled via feature switch \"disableControllerAllowed\"\n     */\n     function disableController() external;\n\n     /**\n     * @notice Used to get the version of the securityToken\n     */\n     function getVersion() external  returns(uint8[]);\n\n     /**\n     * @notice Gets the investor count\n     */\n     function getInvestorCount() external  returns(uint256);\n\n     /**\n      * @notice Overloaded version of the transfer function\n      * @param _to receiver of transfer\n      * @param _value value of transfer\n      * @param _data data to indicate validation\n      * @return bool success\n      */\n     function transferWithData(address _to, uint256 _value, bytes _data) external returns (bool success);\n\n     /**\n      * @notice Overloaded version of the transferFrom function\n      * @param _from sender of transfer\n      * @param _to receiver of transfer\n      * @param _value value of transfer\n      * @param _data data to indicate validation\n      * @return bool success\n      */\n     function transferFromWithData(address _from, address _to, uint256 _value, bytes _data) external returns(bool);\n\n     /**\n      * @notice Provides the granularity of the token\n      * @return uint256\n      */\n     function granularity() external  returns(uint256);\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/Pausable.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Utility contract to allow pausing and unpausing of certain functions\n */\ncontract Pausable {event __CoveragePausable(string fileName, uint256 lineNumber);\nevent __FunctionCoveragePausable(string fileName, uint256 fnId);\nevent __StatementCoveragePausable(string fileName, uint256 statementId);\nevent __BranchCoveragePausable(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoveragePausable(string fileName, uint256 branchId);\nevent __AssertPostCoveragePausable(string fileName, uint256 branchId);\n\n\n    event Pause(uint256 _timestammp);\n    event Unpause(uint256 _timestamp);\n\n    bool public paused = false;\n\n    /**\n    * @notice Modifier to make a function callable only when the contract is not paused.\n    */\n    modifier whenNotPaused() {emit __FunctionCoveragePausable('./contracts/Pausable.sol',1);\n\nemit __CoveragePausable('./contracts/Pausable.sol',17);\n        emit __AssertPreCoveragePausable('./contracts/Pausable.sol',1);\nemit __StatementCoveragePausable('./contracts/Pausable.sol',1);\nrequire(!paused, \"Contract is paused\");emit __AssertPostCoveragePausable('./contracts/Pausable.sol',1);\n\nemit __CoveragePausable('./contracts/Pausable.sol',18);\n        _;\n    }\n\n    /**\n    * @notice Modifier to make a function callable only when the contract is paused.\n    */\n    modifier whenPaused() {emit __FunctionCoveragePausable('./contracts/Pausable.sol',2);\n\nemit __CoveragePausable('./contracts/Pausable.sol',25);\n        emit __AssertPreCoveragePausable('./contracts/Pausable.sol',2);\nemit __StatementCoveragePausable('./contracts/Pausable.sol',2);\nrequire(paused, \"Contract is not paused\");emit __AssertPostCoveragePausable('./contracts/Pausable.sol',2);\n\nemit __CoveragePausable('./contracts/Pausable.sol',26);\n        _;\n    }\n\n   /**\n    * @notice Called by the owner to pause, triggers stopped state\n    */\n    function _pause() internal whenNotPaused {emit __FunctionCoveragePausable('./contracts/Pausable.sol',3);\n\nemit __CoveragePausable('./contracts/Pausable.sol',33);\n        emit __StatementCoveragePausable('./contracts/Pausable.sol',3);\npaused = true;\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoveragePausable('./contracts/Pausable.sol',35);\n        emit __StatementCoveragePausable('./contracts/Pausable.sol',4);\nemit Pause(now);\n    }\n\n    /**\n    * @notice Called by the owner to unpause, returns to normal state\n    */\n    function _unpause() internal whenPaused {emit __FunctionCoveragePausable('./contracts/Pausable.sol',4);\n\nemit __CoveragePausable('./contracts/Pausable.sol',42);\n        emit __StatementCoveragePausable('./contracts/Pausable.sol',5);\npaused = false;\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoveragePausable('./contracts/Pausable.sol',44);\n        emit __StatementCoveragePausable('./contracts/Pausable.sol',6);\nemit Unpause(now);\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/proxy/ERC20DividendCheckpointProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../modules/Checkpoint/ERC20DividendCheckpointStorage.sol\";\nimport \"../modules/Checkpoint/DividendCheckpointStorage.sol\";\nimport \"./OwnedProxy.sol\";\nimport \"../Pausable.sol\";\nimport \"../modules/ModuleStorage.sol\";\n\n/**\n * @title Transfer Manager module for core transfer validation functionality\n */\ncontract ERC20DividendCheckpointProxy is ERC20DividendCheckpointStorage, DividendCheckpointStorage, ModuleStorage, Pausable, OwnedProxy {event __CoverageERC20DividendCheckpointProxy(string fileName, uint256 lineNumber);\nevent __FunctionCoverageERC20DividendCheckpointProxy(string fileName, uint256 fnId);\nevent __StatementCoverageERC20DividendCheckpointProxy(string fileName, uint256 statementId);\nevent __BranchCoverageERC20DividendCheckpointProxy(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageERC20DividendCheckpointProxy(string fileName, uint256 branchId);\nevent __AssertPostCoverageERC20DividendCheckpointProxy(string fileName, uint256 branchId);\n\n\n    /**\n    * @notice Constructor\n    * @param _securityToken Address of the security token\n    * @param _polyAddress Address of the polytoken\n    * @param _implementation representing the address of the new implementation to be set\n    */\n    constructor (address _securityToken, address _polyAddress, address _implementation)\n    public\n    ModuleStorage(_securityToken, _polyAddress)\n    {emit __FunctionCoverageERC20DividendCheckpointProxy('./contracts/proxy/ERC20DividendCheckpointProxy.sol',1);\n\nemit __CoverageERC20DividendCheckpointProxy('./contracts/proxy/ERC20DividendCheckpointProxy.sol',24);\n        emit __AssertPreCoverageERC20DividendCheckpointProxy('./contracts/proxy/ERC20DividendCheckpointProxy.sol',1);\nemit __StatementCoverageERC20DividendCheckpointProxy('./contracts/proxy/ERC20DividendCheckpointProxy.sol',1);\nrequire(\n            _implementation != address(0),\n            \"Implementation address should not be 0x\"\n        );emit __AssertPostCoverageERC20DividendCheckpointProxy('./contracts/proxy/ERC20DividendCheckpointProxy.sol',1);\n\nemit __CoverageERC20DividendCheckpointProxy('./contracts/proxy/ERC20DividendCheckpointProxy.sol',28);\n        emit __StatementCoverageERC20DividendCheckpointProxy('./contracts/proxy/ERC20DividendCheckpointProxy.sol',2);\n__implementation = _implementation;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../../proxy/ERC20DividendCheckpointProxy.sol\";\nimport \"../ModuleFactory.sol\";\n\n/**\n * @title Factory for deploying ERC20DividendCheckpoint module\n */\ncontract ERC20DividendCheckpointFactory is ModuleFactory {event __CoverageERC20DividendCheckpointFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageERC20DividendCheckpointFactory(string fileName, uint256 fnId);\nevent __StatementCoverageERC20DividendCheckpointFactory(string fileName, uint256 statementId);\nevent __BranchCoverageERC20DividendCheckpointFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageERC20DividendCheckpointFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageERC20DividendCheckpointFactory(string fileName, uint256 branchId);\n\n\n    address public logicContract;\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     * @param _setupCost Setup cost of the module\n     * @param _usageCost Usage cost of the module\n     * @param _subscriptionCost Subscription cost of the module\n     * @param _logicContract Contract address that contains the logic related to `description`\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost, address _logicContract) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {emit __FunctionCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',1);\n\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',24);\n        emit __AssertPreCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',1);\nemit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',1);\nrequire(_logicContract != address(0), \"Invalid logic contract\");emit __AssertPostCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',1);\n\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',25);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',2);\nversion = \"2.1.0\";\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',26);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',3);\nname = \"ERC20DividendCheckpoint\";\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',27);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',4);\ntitle = \"ERC20 Dividend Checkpoint\";\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',28);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',5);\ndescription = \"Create ERC20 dividends for token holders at a specific checkpoint\";\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',29);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',6);\ncompatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',30);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',7);\ncompatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',31);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',8);\nlogicContract = _logicContract;\n    }\n\n    /**\n     * @notice Used to launch the Module with the help of factory\n     * @return Address Contract address of the Module\n     */\n    function deploy(bytes /* _data */) external returns(address) {emit __FunctionCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',2);\n\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',39);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',9);\nif (setupCost > 0)\n            {emit __AssertPreCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',3);\nemit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',10);\nemit __BranchCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',2,0);emit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',40);\nrequire(polyToken.transferFrom(msg.sender, owner, setupCost), \"insufficent allowance\");emit __AssertPostCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',3);\n}else { emit __BranchCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',2,1);}\n\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',41);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',11);\naddress erc20DividendCheckpoint = new ERC20DividendCheckpointProxy(msg.sender, address(polyToken), logicContract);\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',43);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',12);\nemit GenerateModuleFromFactory(erc20DividendCheckpoint, getName(), address(this), msg.sender, setupCost, now);\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',44);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',13);\nreturn erc20DividendCheckpoint;\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {emit __FunctionCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',3);\n\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',51);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',14);\nuint8[] memory res = new uint8[](1);\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',52);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',15);\nres[0] = 4;\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',53);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',16);\nreturn res;\n    }\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {emit __FunctionCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',4);\n\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',60);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',17);\nreturn \"Create ERC20 dividend to be paid out to token holders based on their balances at dividend creation time\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {emit __FunctionCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',5);\n\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',67);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',18);\nbytes32[] memory availableTags = new bytes32[](3);\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',68);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',19);\navailableTags[0] = \"ERC20\";\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',69);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',20);\navailableTags[1] = \"Dividend\";\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',70);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',21);\navailableTags[2] = \"Checkpoint\";\nemit __CoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',71);\n        emit __StatementCoverageERC20DividendCheckpointFactory('./contracts/modules/Checkpoint/ERC20DividendCheckpointFactory.sol',22);\nreturn availableTags;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/ModuleFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IModuleFactory.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"../libraries/VersionUtils.sol\";\n\n/**\n * @title Interface that any module factory contract should implement\n * @notice Contract is abstract\n */\ncontract ModuleFactory is IModuleFactory, Ownable {event __CoverageModuleFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageModuleFactory(string fileName, uint256 fnId);\nevent __StatementCoverageModuleFactory(string fileName, uint256 statementId);\nevent __BranchCoverageModuleFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageModuleFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageModuleFactory(string fileName, uint256 branchId);\n\n\n    IERC20 public polyToken;\n    uint256 public usageCost;\n    uint256 public monthlySubscriptionCost;\n\n    uint256 public setupCost;\n    string public description;\n    string public version;\n    bytes32 public name;\n    string public title;\n\n    // @notice Allow only two variables to be stored\n    // 1. lowerBound \n    // 2. upperBound\n    // @dev (0.0.0 will act as the wildcard) \n    // @dev uint24 consists packed value of uint8 _major, uint8 _minor, uint8 _patch\n    mapping(string => uint24) compatibleSTVersionRange;\n\n    event ChangeFactorySetupFee(uint256 _oldSetupCost, uint256 _newSetupCost, address _moduleFactory);\n    event ChangeFactoryUsageFee(uint256 _oldUsageCost, uint256 _newUsageCost, address _moduleFactory);\n    event ChangeFactorySubscriptionFee(uint256 _oldSubscriptionCost, uint256 _newMonthlySubscriptionCost, address _moduleFactory);\n    event GenerateModuleFromFactory(\n        address _module,\n        bytes32 indexed _moduleName,\n        address indexed _moduleFactory,\n        address _creator,\n        uint256 _timestamp\n    );\n    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public {emit __FunctionCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',1);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',48);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',1);\npolyToken = IERC20(_polyAddress);\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',49);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',2);\nsetupCost = _setupCost;\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',50);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',3);\nusageCost = _usageCost;\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',51);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',4);\nmonthlySubscriptionCost = _subscriptionCost;\n    }\n\n    /**\n     * @notice Used to change the fee of the setup cost\n     * @param _newSetupCost new setup cost\n     */\n    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {emit __FunctionCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',2);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',59);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',5);\nemit ChangeFactorySetupFee(setupCost, _newSetupCost, address(this));\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',60);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',6);\nsetupCost = _newSetupCost;\n    }\n\n    /**\n     * @notice Used to change the fee of the usage cost\n     * @param _newUsageCost new usage cost\n     */\n    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {emit __FunctionCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',3);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',68);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',7);\nemit ChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',69);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',8);\nusageCost = _newUsageCost;\n    }\n\n    /**\n     * @notice Used to change the fee of the subscription cost\n     * @param _newSubscriptionCost new subscription cost\n     */\n    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {emit __FunctionCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',4);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',77);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',9);\nemit ChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',78);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',10);\nmonthlySubscriptionCost = _newSubscriptionCost;\n\n    }\n\n    /**\n     * @notice Updates the title of the ModuleFactory\n     * @param _newTitle New Title that will replace the old one.\n     */\n    function changeTitle(string _newTitle) public onlyOwner {emit __FunctionCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',5);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',87);\n        emit __AssertPreCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',1);\nemit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',11);\nrequire(bytes(_newTitle).length > 0, \"Invalid title\");emit __AssertPostCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',1);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',88);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',12);\ntitle = _newTitle;\n    }\n\n    /**\n     * @notice Updates the description of the ModuleFactory\n     * @param _newDesc New description that will replace the old one.\n     */\n    function changeDescription(string _newDesc) public onlyOwner {emit __FunctionCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',6);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',96);\n        emit __AssertPreCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',2);\nemit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',13);\nrequire(bytes(_newDesc).length > 0, \"Invalid description\");emit __AssertPostCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',2);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',97);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',14);\ndescription = _newDesc;\n    }\n\n    /**\n     * @notice Updates the name of the ModuleFactory\n     * @param _newName New name that will replace the old one.\n     */\n    function changeName(bytes32 _newName) public onlyOwner {emit __FunctionCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',7);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',105);\n        emit __AssertPreCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',3);\nemit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',15);\nrequire(_newName != bytes32(0),\"Invalid name\");emit __AssertPostCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',3);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',106);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',16);\nname = _newName;\n    }\n\n    /**\n     * @notice Updates the version of the ModuleFactory\n     * @param _newVersion New name that will replace the old one.\n     */\n    function changeVersion(string _newVersion) public onlyOwner {emit __FunctionCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',8);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',114);\n        emit __AssertPreCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',4);\nemit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',17);\nrequire(bytes(_newVersion).length > 0, \"Invalid version\");emit __AssertPostCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',4);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',115);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',18);\nversion = _newVersion;\n    }\n\n    /**\n     * @notice Function use to change the lower and upper bound of the compatible version st\n     * @param _boundType Type of bound\n     * @param _newVersion new version array\n     */\n    function changeSTVersionBounds(string _boundType, uint8[] _newVersion) external onlyOwner {emit __FunctionCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',9);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',124);\n        emit __AssertPreCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',5);\nemit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',19);\nrequire(\n            keccak256(abi.encodePacked(_boundType)) == keccak256(abi.encodePacked(\"lowerBound\")) ||\n            keccak256(abi.encodePacked(_boundType)) == keccak256(abi.encodePacked(\"upperBound\")),\n            \"Must be a valid bound type\"\n        );emit __AssertPostCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',5);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',129);\n        emit __AssertPreCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',6);\nemit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',20);\nrequire(_newVersion.length == 3);emit __AssertPostCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',6);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',130);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',21);\nif (compatibleSTVersionRange[_boundType] != uint24(0)) {emit __BranchCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',7,0); \nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',131);\n            emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',22);\nuint8[] memory _currentVersion = VersionUtils.unpack(compatibleSTVersionRange[_boundType]);\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',132);\n            emit __AssertPreCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',8);\nemit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',23);\nrequire(VersionUtils.isValidVersion(_currentVersion, _newVersion), \"Failed because of in-valid version\");emit __AssertPostCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',8);\n\n        }else { emit __BranchCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',7,1);}\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',134);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',24);\ncompatibleSTVersionRange[_boundType] = VersionUtils.pack(_newVersion[0], _newVersion[1], _newVersion[2]);\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',135);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',25);\nemit ChangeSTVersionBound(_boundType, _newVersion[0], _newVersion[1], _newVersion[2]);\n    }\n\n    /**\n     * @notice Used to get the lower bound\n     * @return lower bound\n     */\n    function getLowerSTVersionBounds() external  returns(uint8[]) {emit __FunctionCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',10);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',143);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',26);\nreturn VersionUtils.unpack(compatibleSTVersionRange[\"lowerBound\"]);\n    }\n\n    /**\n     * @notice Used to get the upper bound\n     * @return upper bound\n     */\n    function getUpperSTVersionBounds() external  returns(uint8[]) {emit __FunctionCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',11);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',151);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',27);\nreturn VersionUtils.unpack(compatibleSTVersionRange[\"upperBound\"]);\n    }\n\n    /**\n     * @notice Get the setup cost of the module\n     */\n    function getSetupCost() external  returns (uint256) {emit __FunctionCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',12);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',158);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',28);\nreturn setupCost;\n    }\n\n   /**\n    * @notice Get the name of the Module\n    */\n    function getName() public  returns(bytes32) {emit __FunctionCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',13);\n\nemit __CoverageModuleFactory('./contracts/modules/ModuleFactory.sol',165);\n        emit __StatementCoverageModuleFactory('./contracts/modules/ModuleFactory.sol',29);\nreturn name;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Checkpoint/ERC20DividendCheckpointStorage.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title It holds the storage variables related to ERC20DividendCheckpoint module\n */\ncontract ERC20DividendCheckpointStorage {event __CoverageERC20DividendCheckpointStorage(string fileName, uint256 lineNumber);\nevent __FunctionCoverageERC20DividendCheckpointStorage(string fileName, uint256 fnId);\nevent __StatementCoverageERC20DividendCheckpointStorage(string fileName, uint256 statementId);\nevent __BranchCoverageERC20DividendCheckpointStorage(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageERC20DividendCheckpointStorage(string fileName, uint256 branchId);\nevent __AssertPostCoverageERC20DividendCheckpointStorage(string fileName, uint256 branchId);\n\n\n    // Mapping to token address for each dividend\n    mapping (uint256 => address) public dividendTokens;\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Checkpoint/DividendCheckpointStorage.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Holds the storage variable for the DividendCheckpoint modules (i.e ERC20, Ether)\n * @dev abstract contract\n */\ncontract DividendCheckpointStorage {event __CoverageDividendCheckpointStorage(string fileName, uint256 lineNumber);\nevent __FunctionCoverageDividendCheckpointStorage(string fileName, uint256 fnId);\nevent __StatementCoverageDividendCheckpointStorage(string fileName, uint256 statementId);\nevent __BranchCoverageDividendCheckpointStorage(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageDividendCheckpointStorage(string fileName, uint256 branchId);\nevent __AssertPostCoverageDividendCheckpointStorage(string fileName, uint256 branchId);\n\n\n    uint256 public EXCLUDED_ADDRESS_LIMIT = 150;\n    bytes32 public constant DISTRIBUTE = \"DISTRIBUTE\";\n    bytes32 public constant MANAGE = \"MANAGE\";\n    bytes32 public constant CHECKPOINT = \"CHECKPOINT\";\n\n    struct Dividend {\n        uint256 checkpointId;\n        uint256 created; // Time at which the dividend was created\n        uint256 maturity; // Time after which dividend can be claimed - set to 0 to bypass\n        uint256 expiry;  // Time until which dividend can be claimed - after this time any remaining amount can be withdrawn by issuer -\n                         // set to very high value to bypass\n        uint256 amount; // Dividend amount in WEI\n        uint256 claimedAmount; // Amount of dividend claimed so far\n        uint256 totalSupply; // Total supply at the associated checkpoint (avoids recalculating this)\n        bool reclaimed;  // True if expiry has passed and issuer has reclaimed remaining dividend\n        uint256 totalWithheld;\n        uint256 totalWithheldWithdrawn;\n        mapping (address => bool) claimed; // List of addresses which have claimed dividend\n        mapping (address => bool) dividendExcluded; // List of addresses which cannot claim dividends\n        mapping (address => uint256) withheld; // Amount of tax withheld from claim\n        bytes32 name; // Name/title - used for identification\n    }\n\n    // List of all dividends\n    Dividend[] public dividends;\n\n    // List of addresses which cannot claim dividends\n    address[] public excluded;\n\n    // Mapping from address to withholding tax as a percentage * 10**16\n    mapping (address => uint256) public withholdingTax;\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/proxy/OwnedProxy.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./Proxy.sol\";\n\n/**\n * @title OwnedProxy\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n */\ncontract OwnedProxy is Proxy {event __CoverageOwnedProxy(string fileName, uint256 lineNumber);\nevent __FunctionCoverageOwnedProxy(string fileName, uint256 fnId);\nevent __StatementCoverageOwnedProxy(string fileName, uint256 statementId);\nevent __BranchCoverageOwnedProxy(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageOwnedProxy(string fileName, uint256 branchId);\nevent __AssertPostCoverageOwnedProxy(string fileName, uint256 branchId);\n\n\n    // Owner of the contract\n    address private __owner;\n\n    // Address of the current implementation\n    address internal __implementation;\n\n    /**\n    * @dev Event to show ownership has been transferred\n    * @param _previousOwner representing the address of the previous owner\n    * @param _newOwner representing the address of the new owner\n    */\n    event ProxyOwnershipTransferred(address _previousOwner, address _newOwner);\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier ifOwner() {emit __FunctionCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',1);\n\nemit __CoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',28);\n        emit __StatementCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',1);\nif (msg.sender == _owner()) {emit __BranchCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',1,0);\nemit __CoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',29);\n            _;\n        } else {emit __BranchCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',1,1);\nemit __CoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',31);\n            emit __StatementCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',2);\n_fallback();\n        }\n    }\n\n    /**\n    * @dev the constructor sets the original owner of the contract to the sender account.\n    */\n    constructor() public {emit __FunctionCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',2);\n\nemit __CoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',39);\n        emit __StatementCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',3);\n_setOwner(msg.sender);\n    }\n\n    /**\n    * @dev Tells the address of the owner\n    * @return the address of the owner\n    */\n    function _owner() internal  returns (address) {emit __FunctionCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',3);\n\nemit __CoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',47);\n        emit __StatementCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',4);\nreturn __owner;\n    }\n\n    /**\n    * @dev Sets the address of the owner\n    */\n    function _setOwner(address _newOwner) internal {emit __FunctionCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',4);\n\nemit __CoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',54);\n        emit __AssertPreCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',2);\nemit __StatementCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',5);\nrequire(_newOwner != address(0), \"Address should not be 0x\");emit __AssertPostCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',2);\n\nemit __CoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',55);\n        emit __StatementCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',6);\n__owner = _newOwner;\n    }\n\n    /**\n    * @notice Internal function to provide the address of the implementation contract\n    */\n    function _implementation() internal  returns (address) {emit __FunctionCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',5);\n\nemit __CoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',62);\n        emit __StatementCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',7);\nreturn __implementation;\n    }\n\n    /**\n    * @dev Tells the address of the proxy owner\n    * @return the address of the proxy owner\n    */\n    function proxyOwner() external ifOwner returns (address) {emit __FunctionCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',6);\n\nemit __CoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',70);\n        emit __StatementCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',8);\nreturn _owner();\n    }\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() external ifOwner returns (address) {emit __FunctionCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',7);\n\nemit __CoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',78);\n        emit __StatementCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',9);\nreturn _implementation();\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferProxyOwnership(address _newOwner) external ifOwner {emit __FunctionCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',8);\n\nemit __CoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',86);\n        emit __AssertPreCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',3);\nemit __StatementCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',10);\nrequire(_newOwner != address(0), \"Address should not be 0x\");emit __AssertPostCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',3);\n\nemit __CoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',87);\n        emit __StatementCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',11);\nemit ProxyOwnershipTransferred(_owner(), _newOwner);\nemit __CoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',88);\n        emit __StatementCoverageOwnedProxy('./contracts/proxy/OwnedProxy.sol',12);\n_setOwner(_newOwner);\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/proxy/Proxy.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Proxy\n * @dev Gives the possibility to delegate any call to a foreign implementation.\n */\ncontract Proxy {event __CoverageProxy(string fileName, uint256 lineNumber);\nevent __FunctionCoverageProxy(string fileName, uint256 fnId);\nevent __StatementCoverageProxy(string fileName, uint256 statementId);\nevent __BranchCoverageProxy(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageProxy(string fileName, uint256 branchId);\nevent __AssertPostCoverageProxy(string fileName, uint256 branchId);\n\n\n    /**\n    * @dev Tells the address of the implementation where every call will be delegated.\n    * @return address of the implementation to which it will be delegated\n    */\n    function _implementation() internal  returns (address);\n\n    /**\n    * @dev Fallback function.\n    * Implemented entirely in `_fallback`.\n    */\n    function _fallback() internal {emit __FunctionCoverageProxy('./contracts/proxy/Proxy.sol',1);\n\nemit __CoverageProxy('./contracts/proxy/Proxy.sol',20);\n        emit __StatementCoverageProxy('./contracts/proxy/Proxy.sol',1);\n_delegate(_implementation());\n    }\n\n    /**\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n    * This function will return whatever the implementation call returns\n    */\n    function _delegate(address implementation) internal {emit __FunctionCoverageProxy('./contracts/proxy/Proxy.sol',2);\n\n        /*solium-disable-next-line security/no-inline-assembly*/\nemit __CoverageProxy('./contracts/proxy/Proxy.sol',29);\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize)\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize)\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize) }\n            default { return(0, returndatasize) }\n        }\n    }\n\n    function () public payable {emit __FunctionCoverageProxy('./contracts/proxy/Proxy.sol',3);\n\nemit __CoverageProxy('./contracts/proxy/Proxy.sol',50);\n        emit __StatementCoverageProxy('./contracts/proxy/Proxy.sol',2);\n_fallback();\n    }\n}"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/ModuleStorage.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../interfaces/IERC20.sol\";\n\n/**\n * @title Storage for Module contract\n * @notice Contract is abstract\n */\ncontract ModuleStorage {event __CoverageModuleStorage(string fileName, uint256 lineNumber);\nevent __FunctionCoverageModuleStorage(string fileName, uint256 fnId);\nevent __StatementCoverageModuleStorage(string fileName, uint256 statementId);\nevent __BranchCoverageModuleStorage(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageModuleStorage(string fileName, uint256 branchId);\nevent __AssertPostCoverageModuleStorage(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress) public {emit __FunctionCoverageModuleStorage('./contracts/modules/ModuleStorage.sol',1);\n\nemit __CoverageModuleStorage('./contracts/modules/ModuleStorage.sol',17);\n        emit __StatementCoverageModuleStorage('./contracts/modules/ModuleStorage.sol',1);\nsecurityToken = _securityToken;\nemit __CoverageModuleStorage('./contracts/modules/ModuleStorage.sol',18);\n        emit __StatementCoverageModuleStorage('./contracts/modules/ModuleStorage.sol',2);\nfactory = msg.sender;\nemit __CoverageModuleStorage('./contracts/modules/ModuleStorage.sol',19);\n        emit __StatementCoverageModuleStorage('./contracts/modules/ModuleStorage.sol',3);\npolyToken = IERC20(_polyAddress);\n    }\n    \n    address public factory;\n\n    address public securityToken;\n\n    bytes32 public constant FEE_ADMIN = \"FEE_ADMIN\";\n\n    IERC20 public polyToken;\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/proxy/EtherDividendCheckpointProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../modules/Checkpoint/DividendCheckpointStorage.sol\";\nimport \"./OwnedProxy.sol\";\nimport \"../Pausable.sol\";\nimport \"../modules/ModuleStorage.sol\";\n\n/**\n * @title Transfer Manager module for core transfer validation functionality\n */\ncontract EtherDividendCheckpointProxy is DividendCheckpointStorage, ModuleStorage, Pausable, OwnedProxy {event __CoverageEtherDividendCheckpointProxy(string fileName, uint256 lineNumber);\nevent __FunctionCoverageEtherDividendCheckpointProxy(string fileName, uint256 fnId);\nevent __StatementCoverageEtherDividendCheckpointProxy(string fileName, uint256 statementId);\nevent __BranchCoverageEtherDividendCheckpointProxy(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageEtherDividendCheckpointProxy(string fileName, uint256 branchId);\nevent __AssertPostCoverageEtherDividendCheckpointProxy(string fileName, uint256 branchId);\n\n\n    /**\n    * @notice Constructor\n    * @param _securityToken Address of the security token\n    * @param _polyAddress Address of the polytoken\n    * @param _implementation representing the address of the new implementation to be set\n    */\n    constructor (address _securityToken, address _polyAddress, address _implementation)\n    public\n    ModuleStorage(_securityToken, _polyAddress)\n    {emit __FunctionCoverageEtherDividendCheckpointProxy('./contracts/proxy/EtherDividendCheckpointProxy.sol',1);\n\nemit __CoverageEtherDividendCheckpointProxy('./contracts/proxy/EtherDividendCheckpointProxy.sol',23);\n        emit __AssertPreCoverageEtherDividendCheckpointProxy('./contracts/proxy/EtherDividendCheckpointProxy.sol',1);\nemit __StatementCoverageEtherDividendCheckpointProxy('./contracts/proxy/EtherDividendCheckpointProxy.sol',1);\nrequire(\n            _implementation != address(0),\n            \"Implementation address should not be 0x\"\n        );emit __AssertPostCoverageEtherDividendCheckpointProxy('./contracts/proxy/EtherDividendCheckpointProxy.sol',1);\n\nemit __CoverageEtherDividendCheckpointProxy('./contracts/proxy/EtherDividendCheckpointProxy.sol',27);\n        emit __StatementCoverageEtherDividendCheckpointProxy('./contracts/proxy/EtherDividendCheckpointProxy.sol',2);\n__implementation = _implementation;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../../proxy/EtherDividendCheckpointProxy.sol\";\nimport \"../ModuleFactory.sol\";\n\n/**\n * @title Factory for deploying EtherDividendCheckpoint module\n */\ncontract EtherDividendCheckpointFactory is ModuleFactory {event __CoverageEtherDividendCheckpointFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageEtherDividendCheckpointFactory(string fileName, uint256 fnId);\nevent __StatementCoverageEtherDividendCheckpointFactory(string fileName, uint256 statementId);\nevent __BranchCoverageEtherDividendCheckpointFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageEtherDividendCheckpointFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageEtherDividendCheckpointFactory(string fileName, uint256 branchId);\n\n\n    address public logicContract;\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     * @param _setupCost Setup cost of the module\n     * @param _usageCost Usage cost of the module\n     * @param _subscriptionCost Subscription cost of the module\n     * @param _logicContract Contract address that contains the logic related to `description`\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost, address _logicContract) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {emit __FunctionCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',1);\n\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',24);\n        emit __AssertPreCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',1);\nemit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',1);\nrequire(_logicContract != address(0), \"Invalid logic contract\");emit __AssertPostCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',1);\n\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',25);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',2);\nversion = \"2.1.0\";\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',26);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',3);\nname = \"EtherDividendCheckpoint\";\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',27);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',4);\ntitle = \"Ether Dividend Checkpoint\";\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',28);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',5);\ndescription = \"Create ETH dividends for token holders at a specific checkpoint\";\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',29);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',6);\ncompatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',30);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',7);\ncompatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',31);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',8);\nlogicContract = _logicContract;\n    }\n\n    /**\n     * @notice Used to launch the Module with the help of factory\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes /* _data */) external returns(address) {emit __FunctionCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',2);\n\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',39);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',9);\nif(setupCost > 0)\n            {emit __AssertPreCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',3);\nemit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',10);\nemit __BranchCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',2,0);emit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',40);\nrequire(polyToken.transferFrom(msg.sender, owner, setupCost), \"Insufficent allowance or balance\");emit __AssertPostCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',3);\n}else { emit __BranchCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',2,1);}\n\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',41);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',11);\naddress ethDividendCheckpoint = new EtherDividendCheckpointProxy(msg.sender, address(polyToken), logicContract);\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',43);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',12);\nemit GenerateModuleFromFactory(ethDividendCheckpoint, getName(), address(this), msg.sender, setupCost, now);\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',44);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',13);\nreturn ethDividendCheckpoint;\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {emit __FunctionCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',3);\n\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',51);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',14);\nuint8[] memory res = new uint8[](1);\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',52);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',15);\nres[0] = 4;\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',53);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',16);\nreturn res;\n    }\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {emit __FunctionCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',4);\n\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',60);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',17);\nreturn \"Create a dividend which will be paid out to token holders proportionally according to their balances at the point the dividend is created\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {emit __FunctionCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',5);\n\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',67);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',18);\nbytes32[] memory availableTags = new bytes32[](3);\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',68);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',19);\navailableTags[0] = \"ETH\";\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',69);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',20);\navailableTags[1] = \"Checkpoint\";\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',70);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',21);\navailableTags[2] = \"Dividend\";\nemit __CoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',71);\n        emit __StatementCoverageEtherDividendCheckpointFactory('./contracts/modules/Checkpoint/EtherDividendCheckpointFactory.sol',22);\nreturn availableTags;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/proxy/GeneralTransferManagerProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../modules/TransferManager/GeneralTransferManagerStorage.sol\";\nimport \"./OwnedProxy.sol\";\nimport \"../Pausable.sol\";\nimport \"../modules/ModuleStorage.sol\";\n\n/**\n * @title Transfer Manager module for core transfer validation functionality\n */\ncontract GeneralTransferManagerProxy is GeneralTransferManagerStorage, ModuleStorage, Pausable, OwnedProxy {event __CoverageGeneralTransferManagerProxy(string fileName, uint256 lineNumber);\nevent __FunctionCoverageGeneralTransferManagerProxy(string fileName, uint256 fnId);\nevent __StatementCoverageGeneralTransferManagerProxy(string fileName, uint256 statementId);\nevent __BranchCoverageGeneralTransferManagerProxy(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageGeneralTransferManagerProxy(string fileName, uint256 branchId);\nevent __AssertPostCoverageGeneralTransferManagerProxy(string fileName, uint256 branchId);\n\n\n    /**\n    * @notice Constructor\n    * @param _securityToken Address of the security token\n    * @param _polyAddress Address of the polytoken\n    * @param _implementation representing the address of the new implementation to be set\n    */\n    constructor (address _securityToken, address _polyAddress, address _implementation)\n    public\n    ModuleStorage(_securityToken, _polyAddress)\n    {emit __FunctionCoverageGeneralTransferManagerProxy('./contracts/proxy/GeneralTransferManagerProxy.sol',1);\n\nemit __CoverageGeneralTransferManagerProxy('./contracts/proxy/GeneralTransferManagerProxy.sol',23);\n        emit __AssertPreCoverageGeneralTransferManagerProxy('./contracts/proxy/GeneralTransferManagerProxy.sol',1);\nemit __StatementCoverageGeneralTransferManagerProxy('./contracts/proxy/GeneralTransferManagerProxy.sol',1);\nrequire(\n            _implementation != address(0),\n            \"Implementation address should not be 0x\"\n        );emit __AssertPostCoverageGeneralTransferManagerProxy('./contracts/proxy/GeneralTransferManagerProxy.sol',1);\n\nemit __CoverageGeneralTransferManagerProxy('./contracts/proxy/GeneralTransferManagerProxy.sol',27);\n        emit __StatementCoverageGeneralTransferManagerProxy('./contracts/proxy/GeneralTransferManagerProxy.sol',2);\n__implementation = _implementation;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/GeneralTransferManagerFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../../proxy/GeneralTransferManagerProxy.sol\";\nimport \"../ModuleFactory.sol\";\n\n/**\n * @title Factory for deploying GeneralTransferManager module\n */\ncontract GeneralTransferManagerFactory is ModuleFactory {event __CoverageGeneralTransferManagerFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageGeneralTransferManagerFactory(string fileName, uint256 fnId);\nevent __StatementCoverageGeneralTransferManagerFactory(string fileName, uint256 statementId);\nevent __BranchCoverageGeneralTransferManagerFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageGeneralTransferManagerFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageGeneralTransferManagerFactory(string fileName, uint256 branchId);\n\n\n    address public logicContract;\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     * @param _setupCost Setup cost of the module\n     * @param _usageCost Usage cost of the module\n     * @param _subscriptionCost Subscription cost of the module\n     * @param _logicContract Contract address that contains the logic related to `description`\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost, address _logicContract) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {emit __FunctionCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',1);\n\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',24);\n        emit __AssertPreCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',1);\nemit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',1);\nrequire(_logicContract != address(0), \"Invalid logic contract\");emit __AssertPostCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',1);\n\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',25);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',2);\nversion = \"2.1.0\";\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',26);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',3);\nname = \"GeneralTransferManager\";\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',27);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',4);\ntitle = \"General Transfer Manager\";\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',28);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',5);\ndescription = \"Manage transfers using a time based whitelist\";\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',29);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',6);\ncompatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',30);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',7);\ncompatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',31);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',8);\nlogicContract = _logicContract;\n    }\n\n\n     /**\n     * @notice Used to launch the Module with the help of factory\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes /* _data */) external returns(address) {emit __FunctionCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',2);\n\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',40);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',9);\nif (setupCost > 0)\n            {emit __AssertPreCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',3);\nemit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',10);\nemit __BranchCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',2,0);emit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',41);\nrequire(polyToken.transferFrom(msg.sender, owner, setupCost), \"Failed transferFrom because of sufficent Allowance is not provided\");emit __AssertPostCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',3);\n}else { emit __BranchCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',2,1);}\n\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',42);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',11);\naddress generalTransferManager = new GeneralTransferManagerProxy(msg.sender, address(polyToken), logicContract);\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',44);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',12);\nemit GenerateModuleFromFactory(address(generalTransferManager), getName(), address(this), msg.sender, setupCost, now);\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',45);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',13);\nreturn address(generalTransferManager);\n    }\n\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {emit __FunctionCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',3);\n\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',53);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',14);\nuint8[] memory res = new uint8[](1);\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',54);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',15);\nres[0] = 2;\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',55);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',16);\nreturn res;\n    }\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {emit __FunctionCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',4);\n\n        /*solium-disable-next-line max-len*/\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',63);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',17);\nreturn \"Allows an issuer to maintain a time based whitelist of authorised token holders.Addresses are added via modifyWhitelist and take a fromTime (the time from which they can send tokens) and a toTime (the time from which they can receive tokens). There are additional flags, allowAllWhitelistIssuances, allowAllWhitelistTransfers & allowAllTransfers which allow you to set corresponding contract level behaviour. Init function takes no parameters.\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() public  returns(bytes32[]) {emit __FunctionCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',5);\n\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',70);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',18);\nbytes32[] memory availableTags = new bytes32[](2);\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',71);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',19);\navailableTags[0] = \"General\";\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',72);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',20);\navailableTags[1] = \"Transfer Restriction\";\nemit __CoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',73);\n        emit __StatementCoverageGeneralTransferManagerFactory('./contracts/modules/TransferManager/GeneralTransferManagerFactory.sol',21);\nreturn availableTags;\n    }\n\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/GeneralTransferManagerStorage.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Transfer Manager module for core transfer validation functionality\n */\ncontract GeneralTransferManagerStorage {event __CoverageGeneralTransferManagerStorage(string fileName, uint256 lineNumber);\nevent __FunctionCoverageGeneralTransferManagerStorage(string fileName, uint256 fnId);\nevent __StatementCoverageGeneralTransferManagerStorage(string fileName, uint256 statementId);\nevent __BranchCoverageGeneralTransferManagerStorage(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageGeneralTransferManagerStorage(string fileName, uint256 branchId);\nevent __AssertPostCoverageGeneralTransferManagerStorage(string fileName, uint256 branchId);\n\n\n    //Address from which issuances come\n    address public issuanceAddress = address(0);\n\n    //Address which can sign whitelist changes\n    address public signingAddress = address(0);\n\n    bytes32 public constant WHITELIST = \"WHITELIST\";\n    bytes32 public constant FLAGS = \"FLAGS\";\n\n    //from and to timestamps that an investor can send / receive tokens respectively\n    struct TimeRestriction {\n        uint64 fromTime;\n        uint64 toTime;\n        uint64 expiryTime;\n        uint8 canBuyFromSTO;\n        uint8 added;\n    }\n\n    // Allows all TimeRestrictions to be offset\n    struct Defaults {\n        uint64 fromTime;\n        uint64 toTime;\n    }\n\n    // Offset to be applied to all timings (except KYC expiry)\n    Defaults public defaults;\n\n    // List of all addresses that have been added to the GTM at some point\n    address[] public investors;\n\n    // An address can only send / receive tokens once their corresponding uint256 > block.number\n    // (unless allowAllTransfers == true or allowAllWhitelistTransfers == true)\n    mapping (address => TimeRestriction) public whitelist;\n    // Map of used nonces by customer\n    mapping(address => mapping(uint256 => bool)) public nonceMap;\n\n    //If true, there are no transfer restrictions, for any addresses\n    bool public allowAllTransfers = false;\n    //If true, time lock is ignored for transfers (address must still be on whitelist)\n    bool public allowAllWhitelistTransfers = false;\n    //If true, time lock is ignored for issuances (address must still be on whitelist)\n    bool public allowAllWhitelistIssuances = true;\n    //If true, time lock is ignored for burn transactions\n    bool public allowAllBurnTransfers = false;\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/proxy/USDTieredSTOProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../modules/STO/USDTieredSTOStorage.sol\";\nimport \"./OwnedProxy.sol\";\nimport \"../Pausable.sol\";\nimport \"openzeppelin-solidity/contracts/ReentrancyGuard.sol\";\nimport \"../modules/STO/ISTOStorage.sol\";\nimport \"../modules/ModuleStorage.sol\";\n\n/**\n * @title USDTiered STO module Proxy\n */\ncontract USDTieredSTOProxy is USDTieredSTOStorage, ISTOStorage, ModuleStorage, Pausable, ReentrancyGuard, OwnedProxy {event __CoverageUSDTieredSTOProxy(string fileName, uint256 lineNumber);\nevent __FunctionCoverageUSDTieredSTOProxy(string fileName, uint256 fnId);\nevent __StatementCoverageUSDTieredSTOProxy(string fileName, uint256 statementId);\nevent __BranchCoverageUSDTieredSTOProxy(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageUSDTieredSTOProxy(string fileName, uint256 branchId);\nevent __AssertPostCoverageUSDTieredSTOProxy(string fileName, uint256 branchId);\n\n\n    /**\n    * @notice Constructor\n    * @param _securityToken Address of the security token\n    * @param _polyAddress Address of the polytoken\n    * @param _implementation representing the address of the new implementation to be set\n    */\n    constructor (address _securityToken, address _polyAddress, address _implementation)\n    public\n    ModuleStorage(_securityToken, _polyAddress)\n    {emit __FunctionCoverageUSDTieredSTOProxy('./contracts/proxy/USDTieredSTOProxy.sol',1);\n\nemit __CoverageUSDTieredSTOProxy('./contracts/proxy/USDTieredSTOProxy.sol',25);\n        emit __AssertPreCoverageUSDTieredSTOProxy('./contracts/proxy/USDTieredSTOProxy.sol',1);\nemit __StatementCoverageUSDTieredSTOProxy('./contracts/proxy/USDTieredSTOProxy.sol',1);\nrequire(\n            _implementation != address(0),\n            \"Implementation address should not be 0x\"\n        );emit __AssertPostCoverageUSDTieredSTOProxy('./contracts/proxy/USDTieredSTOProxy.sol',1);\n\nemit __CoverageUSDTieredSTOProxy('./contracts/proxy/USDTieredSTOProxy.sol',29);\n        emit __StatementCoverageUSDTieredSTOProxy('./contracts/proxy/USDTieredSTOProxy.sol',2);\n__implementation = _implementation;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/STO/USDTieredSTOFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../../interfaces/IBoot.sol\";\nimport \"../../proxy/USDTieredSTOProxy.sol\";\nimport \"../ModuleFactory.sol\";\nimport \"../../libraries/Util.sol\";\n\n/**\n * @title Factory for deploying CappedSTO module\n */\ncontract USDTieredSTOFactory is ModuleFactory {event __CoverageUSDTieredSTOFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageUSDTieredSTOFactory(string fileName, uint256 fnId);\nevent __StatementCoverageUSDTieredSTOFactory(string fileName, uint256 statementId);\nevent __BranchCoverageUSDTieredSTOFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageUSDTieredSTOFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageUSDTieredSTOFactory(string fileName, uint256 branchId);\n\n\n    address public logicContract;\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost, address _logicContract) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {emit __FunctionCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',1);\n\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',22);\n        emit __AssertPreCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',1);\nemit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',1);\nrequire(_logicContract != address(0), \"0x address is not allowed\");emit __AssertPostCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',1);\n\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',23);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',2);\nlogicContract = _logicContract;\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',24);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',3);\nversion = \"2.1.0\";\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',25);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',4);\nname = \"USDTieredSTO\";\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',26);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',5);\ntitle = \"USD Tiered STO\";\n        /*solium-disable-next-line max-len*/\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',28);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',6);\ndescription = \"It allows both accredited and non-accredited investors to contribute into the STO. Non-accredited investors will be capped at a maximum investment limit (as a default or specific to their jurisdiction). Tokens will be sold according to tiers sequentially & each tier has its own price and volume of tokens to sell. Upon receipt of funds (ETH, POLY or DAI), security tokens will automatically transfer to investors wallet address\";\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',29);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',7);\ncompatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',30);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',8);\ncompatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n    }\n\n     /**\n     * @notice Used to launch the Module with the help of factory\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes _data) external returns(address) {emit __FunctionCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',2);\n\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',38);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',9);\nif(setupCost > 0)\n            {emit __AssertPreCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',3);\nemit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',10);\nemit __BranchCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',2,0);emit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',39);\nrequire(polyToken.transferFrom(msg.sender, owner, setupCost), \"Sufficent Allowance is not provided\");emit __AssertPostCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',3);\n}else { emit __BranchCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',2,1);}\n\n        //Check valid bytes - can only call module init function\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',41);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',11);\naddress usdTieredSTO = new USDTieredSTOProxy(msg.sender, address(polyToken), logicContract);\n        //Checks that _data is valid (not calling anything it shouldn't)\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',43);\n        emit __AssertPreCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',4);\nemit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',12);\nrequire(Util.getSig(_data) == IBoot(usdTieredSTO).getInitFunction(), \"Invalid data\");emit __AssertPostCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',4);\n\n        /*solium-disable-next-line security/no-low-level-calls*/\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',45);\n        emit __AssertPreCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',5);\nemit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',13);\nrequire(address(usdTieredSTO).call(_data), \"Unsuccessfull call\");emit __AssertPostCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',5);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',47);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',14);\nemit GenerateModuleFromFactory(usdTieredSTO, getName(), address(this), msg.sender, setupCost, now);\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',48);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',15);\nreturn address(usdTieredSTO);\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {emit __FunctionCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',3);\n\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',55);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',16);\nuint8[] memory res = new uint8[](1);\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',56);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',17);\nres[0] = 3;\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',57);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',18);\nreturn res;\n    }\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {emit __FunctionCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',4);\n\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',64);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',19);\nreturn \"Initialises a USD tiered STO.\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {emit __FunctionCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',5);\n\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',71);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',20);\nbytes32[] memory availableTags = new bytes32[](4);\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',72);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',21);\navailableTags[0] = \"USD\";\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',73);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',22);\navailableTags[1] = \"Tiered\";\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',74);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',23);\navailableTags[2] = \"POLY\";\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',75);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',24);\navailableTags[3] = \"ETH\";\nemit __CoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',76);\n        emit __StatementCoverageUSDTieredSTOFactory('./contracts/modules/STO/USDTieredSTOFactory.sol',25);\nreturn availableTags;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/interfaces/IBoot.sol":{"content":"pragma solidity ^0.4.24;\n\ninterface IBoot {event __CoverageIBoot(string fileName, uint256 lineNumber);\nevent __FunctionCoverageIBoot(string fileName, uint256 fnId);\nevent __StatementCoverageIBoot(string fileName, uint256 statementId);\nevent __BranchCoverageIBoot(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageIBoot(string fileName, uint256 branchId);\nevent __AssertPostCoverageIBoot(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice This function returns the signature of configure function\n     * @return bytes4 Configure function signature\n     */\n    function getInitFunction() external  returns(bytes4);\n}"},"/home/max/Desktop/Ethereum/polymath-core/contracts/libraries/Util.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Utility contract for reusable code\n */\nlibrary Util {event __CoverageUtil(string fileName, uint256 lineNumber);\nevent __FunctionCoverageUtil(string fileName, uint256 fnId);\nevent __StatementCoverageUtil(string fileName, uint256 statementId);\nevent __BranchCoverageUtil(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageUtil(string fileName, uint256 branchId);\nevent __AssertPostCoverageUtil(string fileName, uint256 branchId);\n\n\n   /**\n    * @notice Changes a string to upper case\n    * @param _base String to change\n    */\n    function upper(string _base) internal  returns (string) {emit __FunctionCoverageUtil('./contracts/libraries/Util.sol',1);\n\nemit __CoverageUtil('./contracts/libraries/Util.sol',13);\n        emit __StatementCoverageUtil('./contracts/libraries/Util.sol',1);\nbytes memory _baseBytes = bytes(_base);\nemit __CoverageUtil('./contracts/libraries/Util.sol',14);\n        emit __StatementCoverageUtil('./contracts/libraries/Util.sol',2);\nfor (uint i = 0; i < _baseBytes.length; i++) {\nemit __CoverageUtil('./contracts/libraries/Util.sol',15);\n            emit __StatementCoverageUtil('./contracts/libraries/Util.sol',3);\nbytes1 b1 = _baseBytes[i];\nemit __CoverageUtil('./contracts/libraries/Util.sol',16);\n            emit __StatementCoverageUtil('./contracts/libraries/Util.sol',4);\nif (b1 >= 0x61 && b1 <= 0x7A) {emit __BranchCoverageUtil('./contracts/libraries/Util.sol',1,0);\nemit __CoverageUtil('./contracts/libraries/Util.sol',17);\n                emit __StatementCoverageUtil('./contracts/libraries/Util.sol',5);\nb1 = bytes1(uint8(b1)-32);\n            }else { emit __BranchCoverageUtil('./contracts/libraries/Util.sol',1,1);}\n\nemit __CoverageUtil('./contracts/libraries/Util.sol',19);\n            emit __StatementCoverageUtil('./contracts/libraries/Util.sol',6);\n_baseBytes[i] = b1;\n        }\nemit __CoverageUtil('./contracts/libraries/Util.sol',21);\n        emit __StatementCoverageUtil('./contracts/libraries/Util.sol',7);\nreturn string(_baseBytes);\n    }\n\n    /**\n     * @notice Changes the string into bytes32\n     * @param _source String that need to convert into bytes32\n     */\n    /// Notice - Maximum Length for _source will be 32 chars otherwise returned bytes32 value will have lossy value.\n    function stringToBytes32(string memory _source) internal  returns (bytes32) {emit __FunctionCoverageUtil('./contracts/libraries/Util.sol',2);\n\nemit __CoverageUtil('./contracts/libraries/Util.sol',30);\n        emit __StatementCoverageUtil('./contracts/libraries/Util.sol',8);\nreturn bytesToBytes32(bytes(_source), 0);\n    }\n\n    /**\n     * @notice Changes bytes into bytes32\n     * @param _b Bytes that need to convert into bytes32\n     * @param _offset Offset from which to begin conversion\n     */\n    /// Notice - Maximum length for _source will be 32 chars otherwise returned bytes32 value will have lossy value.\n    function bytesToBytes32(bytes _b, uint _offset) internal  returns (bytes32) {emit __FunctionCoverageUtil('./contracts/libraries/Util.sol',3);\n\nemit __CoverageUtil('./contracts/libraries/Util.sol',40);\n        bytes32 result;\n\nemit __CoverageUtil('./contracts/libraries/Util.sol',42);\n        emit __StatementCoverageUtil('./contracts/libraries/Util.sol',9);\nfor (uint i = 0; i < _b.length; i++) {\nemit __CoverageUtil('./contracts/libraries/Util.sol',43);\n            emit __StatementCoverageUtil('./contracts/libraries/Util.sol',10);\nresult |= bytes32(_b[_offset + i] & 0xFF) >> (i * 8);\n        }\nemit __CoverageUtil('./contracts/libraries/Util.sol',45);\n        emit __StatementCoverageUtil('./contracts/libraries/Util.sol',11);\nreturn result;\n    }\n\n    /**\n     * @notice Changes the bytes32 into string\n     * @param _source that need to convert into string\n     */\n    function bytes32ToString(bytes32 _source) internal  returns (string result) {emit __FunctionCoverageUtil('./contracts/libraries/Util.sol',4);\n\nemit __CoverageUtil('./contracts/libraries/Util.sol',53);\n        emit __StatementCoverageUtil('./contracts/libraries/Util.sol',12);\nbytes memory bytesString = new bytes(32);\nemit __CoverageUtil('./contracts/libraries/Util.sol',54);\n        emit __StatementCoverageUtil('./contracts/libraries/Util.sol',13);\nuint charCount = 0;\nemit __CoverageUtil('./contracts/libraries/Util.sol',55);\n        emit __StatementCoverageUtil('./contracts/libraries/Util.sol',14);\nfor (uint j = 0; j < 32; j++) {\nemit __CoverageUtil('./contracts/libraries/Util.sol',56);\n            emit __StatementCoverageUtil('./contracts/libraries/Util.sol',15);\nbyte char = byte(bytes32(uint(_source) * 2 ** (8 * j)));\nemit __CoverageUtil('./contracts/libraries/Util.sol',57);\n            emit __StatementCoverageUtil('./contracts/libraries/Util.sol',16);\nif (char != 0) {emit __BranchCoverageUtil('./contracts/libraries/Util.sol',2,0);\nemit __CoverageUtil('./contracts/libraries/Util.sol',58);\n                emit __StatementCoverageUtil('./contracts/libraries/Util.sol',17);\nbytesString[charCount] = char;\nemit __CoverageUtil('./contracts/libraries/Util.sol',59);\n                charCount++;\n            }else { emit __BranchCoverageUtil('./contracts/libraries/Util.sol',2,1);}\n\n        }\nemit __CoverageUtil('./contracts/libraries/Util.sol',62);\n        emit __StatementCoverageUtil('./contracts/libraries/Util.sol',18);\nbytes memory bytesStringTrimmed = new bytes(charCount);\nemit __CoverageUtil('./contracts/libraries/Util.sol',63);\n        emit __StatementCoverageUtil('./contracts/libraries/Util.sol',19);\nfor (j = 0; j < charCount; j++) {\nemit __CoverageUtil('./contracts/libraries/Util.sol',64);\n            emit __StatementCoverageUtil('./contracts/libraries/Util.sol',20);\nbytesStringTrimmed[j] = bytesString[j];\n        }\nemit __CoverageUtil('./contracts/libraries/Util.sol',66);\n        emit __StatementCoverageUtil('./contracts/libraries/Util.sol',21);\nreturn string(bytesStringTrimmed);\n    }\n\n    /**\n     * @notice Gets function signature from _data\n     * @param _data Passed data\n     * @return bytes4 sig\n     */\n    function getSig(bytes _data) internal  returns (bytes4 sig) {emit __FunctionCoverageUtil('./contracts/libraries/Util.sol',5);\n\nemit __CoverageUtil('./contracts/libraries/Util.sol',75);\n        emit __StatementCoverageUtil('./contracts/libraries/Util.sol',22);\nuint len = _data.length < 4 ? _data.length : 4;\nemit __CoverageUtil('./contracts/libraries/Util.sol',76);\n        emit __StatementCoverageUtil('./contracts/libraries/Util.sol',23);\nfor (uint i = 0; i < len; i++) {\nemit __CoverageUtil('./contracts/libraries/Util.sol',77);\n            emit __StatementCoverageUtil('./contracts/libraries/Util.sol',24);\nsig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (len - 1 - i))));\n        }\n    }\n\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/STO/USDTieredSTOStorage.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../../interfaces/IERC20.sol\";\n\n/**\n * @title Contract used to store layout for the USDTieredSTO storage\n */\ncontract USDTieredSTOStorage {event __CoverageUSDTieredSTOStorage(string fileName, uint256 lineNumber);\nevent __FunctionCoverageUSDTieredSTOStorage(string fileName, uint256 fnId);\nevent __StatementCoverageUSDTieredSTOStorage(string fileName, uint256 statementId);\nevent __BranchCoverageUSDTieredSTOStorage(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageUSDTieredSTOStorage(string fileName, uint256 branchId);\nevent __AssertPostCoverageUSDTieredSTOStorage(string fileName, uint256 branchId);\n\n\n    /////////////\n    // Storage //\n    /////////////\n    struct Tier {\n        // NB rates mentioned below are actually price and are used like price in the logic.\n        // How many token units a buyer gets per USD in this tier (multiplied by 10**18)\n        uint256 rate;\n\n        // How many token units a buyer gets per USD in this tier (multiplied by 10**18) when investing in POLY up to tokensDiscountPoly\n        uint256 rateDiscountPoly;\n\n        // How many tokens are available in this tier (relative to totalSupply)\n        uint256 tokenTotal;\n\n        // How many token units are available in this tier (relative to totalSupply) at the ratePerTierDiscountPoly rate\n        uint256 tokensDiscountPoly;\n\n        // How many tokens have been minted in this tier (relative to totalSupply)\n        uint256 mintedTotal;\n\n        // How many tokens have been minted in this tier (relative to totalSupply) for each fund raise type\n        mapping (uint8 => uint256) minted;\n\n        // How many tokens have been minted in this tier (relative to totalSupply) at discounted POLY rate\n        uint256 mintedDiscountPoly;\n    }\n\n    mapping (bytes32 => mapping (bytes32 => string)) oracleKeys;\n\n    // Determine whether users can invest on behalf of a beneficiary\n    bool public allowBeneficialInvestments = false;\n\n    // Whether or not the STO has been finalized\n    bool public isFinalized;\n\n    // Address where ETH, POLY & Stable Coin funds are delivered\n    address public wallet;\n\n    // Address of issuer reserve wallet for unsold tokens\n    address public reserveWallet;\n\n    // List of stable coin addresses\n    address[] public usdTokens;\n\n    // Current tier\n    uint256 public currentTier;\n\n    // Amount of USD funds raised\n    uint256 public fundsRaisedUSD;\n\n    // Amount of stable coins raised\n    mapping (address => uint256) public stableCoinsRaised;\n\n    // Amount in USD invested by each address\n    mapping (address => uint256) public investorInvestedUSD;\n\n    // Amount in fund raise type invested by each investor\n    mapping (address => mapping (uint8 => uint256)) public investorInvested;\n\n    // List of accredited investors\n    mapping (address => bool) public accredited;\n\n    // List of active stable coin addresses\n    mapping (address => bool) public usdTokenEnabled;\n\n    // Default limit in USD for non-accredited investors multiplied by 10**18\n    uint256 public nonAccreditedLimitUSD;\n\n    // Overrides for default limit in USD for non-accredited investors multiplied by 10**18\n    mapping (address => uint256) public nonAccreditedLimitUSDOverride;\n\n    // Minimum investable amount in USD\n    uint256 public minimumInvestmentUSD;\n\n    // Final amount of tokens returned to issuer\n    uint256 public finalAmountReturned;\n\n    // Array of Tiers\n    Tier[] public tiers;\n\n}"},"openzeppelin-solidity/contracts/ReentrancyGuard.sol":{"content":"pragma solidity ^0.4.23;\n\n\n/**\n * @title Helps contracts guard agains reentrancy attacks.\n * @author Remco Bloemen <remco@2.com>\n * @notice If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n\n  /**\n   * @dev We use a single lock for the whole contract.\n   */\n  bool private reentrancyLock = false;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * @notice If you mark a function `nonReentrant`, you should also\n   * mark it `external`. Calling one nonReentrant function from\n   * another is not supported. Instead, you can implement a\n   * `private` function doing the actual work, and a `external`\n   * wrapper marked as `nonReentrant`.\n   */\n  modifier nonReentrant() {\n    require(!reentrancyLock);\n    reentrancyLock = true;\n    _;\n    reentrancyLock = false;\n  }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/STO/ISTOStorage.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Storage layout for the ISTO contract\n */\ncontract ISTOStorage {event __CoverageISTOStorage(string fileName, uint256 lineNumber);\nevent __FunctionCoverageISTOStorage(string fileName, uint256 fnId);\nevent __StatementCoverageISTOStorage(string fileName, uint256 statementId);\nevent __BranchCoverageISTOStorage(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageISTOStorage(string fileName, uint256 branchId);\nevent __AssertPostCoverageISTOStorage(string fileName, uint256 branchId);\n\n\n    mapping (uint8 => bool) public fundRaiseTypes;\n    mapping (uint8 => uint256) public fundsRaised;\n\n    // Start time of the STO\n    uint256 public startTime;\n    // End time of the STO\n    uint256 public endTime;\n    // Time STO was paused\n    uint256 public pausedTime;\n    // Number of individual investors\n    uint256 public investorCount;\n    // Address where ETH & POLY funds are delivered\n    address public wallet;\n     // Final amount of tokens sold\n    uint256 public totalTokensSold;\n\n}"},"/home/max/Desktop/Ethereum/polymath-core/contracts/proxy/VestingEscrowWalletProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../modules/Wallet/VestingEscrowWalletStorage.sol\";\nimport \"./OwnedProxy.sol\";\nimport \"../Pausable.sol\";\nimport \"../modules/ModuleStorage.sol\";\n /**\n * @title Escrow wallet module for vesting functionality\n */\ncontract VestingEscrowWalletProxy is VestingEscrowWalletStorage, ModuleStorage, Pausable, OwnedProxy {event __CoverageVestingEscrowWalletProxy(string fileName, uint256 lineNumber);\nevent __FunctionCoverageVestingEscrowWalletProxy(string fileName, uint256 fnId);\nevent __StatementCoverageVestingEscrowWalletProxy(string fileName, uint256 statementId);\nevent __BranchCoverageVestingEscrowWalletProxy(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageVestingEscrowWalletProxy(string fileName, uint256 branchId);\nevent __AssertPostCoverageVestingEscrowWalletProxy(string fileName, uint256 branchId);\n\n     /**\n    * @notice Constructor\n    * @param _securityToken Address of the security token\n    * @param _polyAddress Address of the polytoken\n    * @param _implementation representing the address of the new implementation to be set\n    */\n    constructor (address _securityToken, address _polyAddress, address _implementation)\n    public\n    ModuleStorage(_securityToken, _polyAddress)\n    {emit __FunctionCoverageVestingEscrowWalletProxy('./contracts/proxy/VestingEscrowWalletProxy.sol',1);\n\nemit __CoverageVestingEscrowWalletProxy('./contracts/proxy/VestingEscrowWalletProxy.sol',21);\n        emit __AssertPreCoverageVestingEscrowWalletProxy('./contracts/proxy/VestingEscrowWalletProxy.sol',1);\nemit __StatementCoverageVestingEscrowWalletProxy('./contracts/proxy/VestingEscrowWalletProxy.sol',1);\nrequire(\n            _implementation != address(0),\n            \"Implementation address should not be 0x\"\n        );emit __AssertPostCoverageVestingEscrowWalletProxy('./contracts/proxy/VestingEscrowWalletProxy.sol',1);\n\nemit __CoverageVestingEscrowWalletProxy('./contracts/proxy/VestingEscrowWalletProxy.sol',25);\n        emit __StatementCoverageVestingEscrowWalletProxy('./contracts/proxy/VestingEscrowWalletProxy.sol',2);\n__implementation = _implementation;\n    }\n }"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Wallet/VestingEscrowWalletFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../../proxy/VestingEscrowWalletProxy.sol\";\nimport \"../../interfaces/IBoot.sol\";\nimport \"../ModuleFactory.sol\";\nimport \"../../libraries/Util.sol\";\n\n/**\n * @title Factory for deploying VestingEscrowWallet module\n */\ncontract VestingEscrowWalletFactory is ModuleFactory {event __CoverageVestingEscrowWalletFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageVestingEscrowWalletFactory(string fileName, uint256 fnId);\nevent __StatementCoverageVestingEscrowWalletFactory(string fileName, uint256 statementId);\nevent __BranchCoverageVestingEscrowWalletFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageVestingEscrowWalletFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageVestingEscrowWalletFactory(string fileName, uint256 branchId);\n\n    \n    address public logicContract;\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost, address _logicContract) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {emit __FunctionCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',1);\n\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',21);\n        emit __AssertPreCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',1);\nemit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',1);\nrequire(_logicContract != address(0), \"Invalid address\");emit __AssertPostCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',1);\n\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',22);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',2);\nversion = \"1.0.0\";\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',23);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',3);\nname = \"VestingEscrowWallet\";\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',24);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',4);\ntitle = \"Vesting Escrow Wallet\";\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',25);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',5);\ndescription = \"Manage vesting schedules to employees / affiliates\";\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',26);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',6);\ncompatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',27);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',7);\ncompatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',28);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',8);\nlogicContract = _logicContract;\n    }\n\n    /**\n     * @notice Used to launch the Module with the help of factory\n     * _data Data used for the intialization of the module factory variables\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes _data) external returns(address) {emit __FunctionCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',2);\n\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',37);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',9);\nif (setupCost > 0) {emit __BranchCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',2,0);\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',38);\n            emit __AssertPreCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',3);\nemit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',10);\nrequire(polyToken.transferFrom(msg.sender, owner, setupCost), \"Failed transferFrom due to insufficent Allowance provided\");emit __AssertPostCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',3);\n\n        }else { emit __BranchCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',2,1);}\n\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',40);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',11);\nVestingEscrowWalletProxy vestingEscrowWallet = new VestingEscrowWalletProxy(msg.sender, address(polyToken), logicContract);\n        //Checks that _data is valid (not calling anything it shouldn't)\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',42);\n        emit __AssertPreCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',4);\nemit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',12);\nrequire(Util.getSig(_data) == IBoot(vestingEscrowWallet).getInitFunction(), \"Invalid data\");emit __AssertPostCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',4);\n\n        /*solium-disable-next-line security/no-low-level-calls*/\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',44);\n        emit __AssertPreCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',5);\nemit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',13);\nrequire(address(vestingEscrowWallet).call(_data), \"Unsuccessfull call\");emit __AssertPostCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',5);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',46);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',14);\nemit GenerateModuleFromFactory(address(vestingEscrowWallet), getName(), address(this), msg.sender, setupCost, now);\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',47);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',15);\nreturn address(vestingEscrowWallet);\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {emit __FunctionCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',3);\n\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',54);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',16);\nuint8[] memory res = new uint8[](1);\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',55);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',17);\nres[0] = 6;\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',56);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',18);\nreturn res;\n    }\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {emit __FunctionCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',4);\n\n        /*solium-disable-next-line max-len*/\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',64);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',19);\nreturn \"Issuer can deposit tokens to the contract and create the vesting schedule for the given address (Affiliate/Employee). These address can withdraw tokens according to there vesting schedule.\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {emit __FunctionCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',5);\n\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',71);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',20);\nbytes32[] memory availableTags = new bytes32[](2);\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',72);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',21);\navailableTags[0] = \"Vested\";\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',73);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',22);\navailableTags[1] = \"Escrow Wallet\";\nemit __CoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',74);\n        emit __StatementCoverageVestingEscrowWalletFactory('./contracts/modules/Wallet/VestingEscrowWalletFactory.sol',23);\nreturn availableTags;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Wallet/VestingEscrowWalletStorage.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Wallet for core vesting escrow functionality\n */\ncontract VestingEscrowWalletStorage {event __CoverageVestingEscrowWalletStorage(string fileName, uint256 lineNumber);\nevent __FunctionCoverageVestingEscrowWalletStorage(string fileName, uint256 fnId);\nevent __StatementCoverageVestingEscrowWalletStorage(string fileName, uint256 statementId);\nevent __BranchCoverageVestingEscrowWalletStorage(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageVestingEscrowWalletStorage(string fileName, uint256 branchId);\nevent __AssertPostCoverageVestingEscrowWalletStorage(string fileName, uint256 branchId);\n\n    \n    struct Schedule {\n        // Name of the template\n        bytes32 templateName;\n        // Tokens that were already claimed\n        uint256 claimedTokens;\n        // Start time of the schedule\n        uint256 startTime;\n    }\n\n    struct Template {\n        // Total amount of tokens\n        uint256 numberOfTokens;\n        // Schedule duration (How long the schedule will last)\n        uint256 duration;\n        // Schedule frequency (It is a cliff time period)\n        uint256 frequency;\n        // Index of the template in an array template names\n        uint256 index;\n    }\n\n    // Number of tokens that are hold by the `this` contract but are unassigned to any schedule\n    uint256 public unassignedTokens;\n    // Address of the Treasury wallet. All of the unassigned token will transfer to that address.\n    address public treasuryWallet;\n    // List of all beneficiaries who have the schedules running/completed/created\n    address[] public beneficiaries;\n    // Flag whether beneficiary has been already added or not\n    mapping(address => bool) internal beneficiaryAdded;\n\n    // Holds schedules array corresponds to the affiliate/employee address\n    mapping(address => Schedule[]) public schedules;\n    // Holds template names array corresponds to the affiliate/employee address\n    mapping(address => bytes32[]) internal userToTemplates;\n    // Mapping use to store the indexes for different template names for a user. \n    // affiliate/employee address => template name => index\n    mapping(address => mapping(bytes32 => uint256)) internal userToTemplateIndex;\n    // Holds affiliate/employee addresses coressponds to the template name\n    mapping(bytes32 => address[]) internal templateToUsers;\n    // Mapping use to store the indexes for different users for a template.\n    // template name => affiliate/employee address => index\n    mapping(bytes32 => mapping(address => uint256)) internal templateToUserIndex;\n    // Store the template details corresponds to the template name\n    mapping(bytes32 => Template) templates;\n\n    // List of all template names\n    bytes32[] public templateNames;\n}"},"/home/max/Desktop/Ethereum/polymath-core/contracts/proxy/VolumeRestrictionTMProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../modules/TransferManager/VolumeRestrictionTMStorage.sol\";\nimport \"./OwnedProxy.sol\";\nimport \"../Pausable.sol\";\nimport \"../modules/ModuleStorage.sol\";\n\n/**\n * @title Transfer Manager module for core transfer validation functionality\n */\ncontract VolumeRestrictionTMProxy is VolumeRestrictionTMStorage, ModuleStorage, Pausable, OwnedProxy {event __CoverageVolumeRestrictionTMProxy(string fileName, uint256 lineNumber);\nevent __FunctionCoverageVolumeRestrictionTMProxy(string fileName, uint256 fnId);\nevent __StatementCoverageVolumeRestrictionTMProxy(string fileName, uint256 statementId);\nevent __BranchCoverageVolumeRestrictionTMProxy(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageVolumeRestrictionTMProxy(string fileName, uint256 branchId);\nevent __AssertPostCoverageVolumeRestrictionTMProxy(string fileName, uint256 branchId);\n\n\n    /**\n    * @notice Constructor\n    * @param _securityToken Address of the security token\n    * @param _polyAddress Address of the polytoken\n    * @param _implementation representing the address of the new implementation to be set\n    */\n    constructor (address _securityToken, address _polyAddress, address _implementation)\n    public\n    ModuleStorage(_securityToken, _polyAddress)\n    {emit __FunctionCoverageVolumeRestrictionTMProxy('./contracts/proxy/VolumeRestrictionTMProxy.sol',1);\n\nemit __CoverageVolumeRestrictionTMProxy('./contracts/proxy/VolumeRestrictionTMProxy.sol',23);\n        emit __AssertPreCoverageVolumeRestrictionTMProxy('./contracts/proxy/VolumeRestrictionTMProxy.sol',1);\nemit __StatementCoverageVolumeRestrictionTMProxy('./contracts/proxy/VolumeRestrictionTMProxy.sol',1);\nrequire(\n            _implementation != address(0),\n            \"Implementation address should not be 0x\"\n        );emit __AssertPostCoverageVolumeRestrictionTMProxy('./contracts/proxy/VolumeRestrictionTMProxy.sol',1);\n\nemit __CoverageVolumeRestrictionTMProxy('./contracts/proxy/VolumeRestrictionTMProxy.sol',27);\n        emit __StatementCoverageVolumeRestrictionTMProxy('./contracts/proxy/VolumeRestrictionTMProxy.sol',2);\n__implementation = _implementation;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../../proxy/VolumeRestrictionTMProxy.sol\";\nimport \"../ModuleFactory.sol\";\n\n/**\n * @title Factory for deploying VolumeRestrictionTM module\n */\ncontract VolumeRestrictionTMFactory is ModuleFactory {event __CoverageVolumeRestrictionTMFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageVolumeRestrictionTMFactory(string fileName, uint256 fnId);\nevent __StatementCoverageVolumeRestrictionTMFactory(string fileName, uint256 statementId);\nevent __BranchCoverageVolumeRestrictionTMFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageVolumeRestrictionTMFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageVolumeRestrictionTMFactory(string fileName, uint256 branchId);\n\n    \n    address public logicContract;\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost, address _logicContract) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {emit __FunctionCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',1);\n   \nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',20);\n        emit __AssertPreCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',1);\nemit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',1);\nrequire(_logicContract != address(0), \"Invalid address\");emit __AssertPostCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',1);\n\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',21);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',2);\nversion = \"1.0.0\";\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',22);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',3);\nname = \"VolumeRestrictionTM\";\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',23);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',4);\ntitle = \"Volume Restriction Transfer Manager\";\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',24);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',5);\ndescription = \"Manage transfers based on the volume of tokens that needs to be transact\";\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',25);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',6);\ncompatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',26);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',7);\ncompatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',27);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',8);\nlogicContract = _logicContract;\n    }\n\n\n     /**\n     * @notice Used to launch the Module with the help of factory\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes /* _data */) external returns(address) {emit __FunctionCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',2);\n\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',36);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',9);\nif (setupCost > 0)\n            {emit __AssertPreCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',3);\nemit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',10);\nemit __BranchCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',2,0);emit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',37);\nrequire(polyToken.transferFrom(msg.sender, owner, setupCost), \"Insufficent Allowance\");emit __AssertPostCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',3);\n}else { emit __BranchCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',2,1);}\n\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',38);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',11);\naddress volumeRestrictionTransferManager = new VolumeRestrictionTMProxy(msg.sender, address(polyToken), logicContract);\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',40);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',12);\nemit GenerateModuleFromFactory(volumeRestrictionTransferManager, getName(), address(this), msg.sender, setupCost, now);\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',41);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',13);\nreturn volumeRestrictionTransferManager;\n    }\n\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {emit __FunctionCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',3);\n\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',49);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',14);\nuint8[] memory res = new uint8[](1);\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',50);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',15);\nres[0] = 2;\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',51);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',16);\nreturn res;\n    }\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {emit __FunctionCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',4);\n\n        /*solium-disable-next-line max-len*/\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',59);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',17);\nreturn \"Module used to restrict the volume of tokens traded by the token holders\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() public  returns(bytes32[]) {emit __FunctionCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',5);\n\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',66);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',18);\nbytes32[] memory availableTags = new bytes32[](5);\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',67);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',19);\navailableTags[0] = \"Maximum Volume\";\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',68);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',20);\navailableTags[1] = \"Transfer Restriction\";\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',69);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',21);\navailableTags[2] = \"Daily Restriction\";\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',70);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',22);\navailableTags[3] = \"Individual Restriction\";\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',71);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',23);\navailableTags[4] = \"Default Restriction\";\nemit __CoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',72);\n        emit __StatementCoverageVolumeRestrictionTMFactory('./contracts/modules/TransferManager/VolumeRestrictionTMFactory.sol',24);\nreturn availableTags;\n    }\n\n}"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/VolumeRestrictionTMStorage.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Storage layout for VolumeRestrictionTM\n */\ncontract VolumeRestrictionTMStorage {event __CoverageVolumeRestrictionTMStorage(string fileName, uint256 lineNumber);\nevent __FunctionCoverageVolumeRestrictionTMStorage(string fileName, uint256 fnId);\nevent __StatementCoverageVolumeRestrictionTMStorage(string fileName, uint256 statementId);\nevent __BranchCoverageVolumeRestrictionTMStorage(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageVolumeRestrictionTMStorage(string fileName, uint256 branchId);\nevent __AssertPostCoverageVolumeRestrictionTMStorage(string fileName, uint256 branchId);\n\n\n    enum RestrictionType { Fixed, Percentage }\n\n    struct VolumeRestriction {\n        // If typeOfRestriction is `Percentage` then allowedTokens will be in\n        // the % (w.r.t to totalSupply) with a multiplier of 10**16 . else it \n        // will be fixed amount of tokens\n        uint256 allowedTokens;\n        uint256 startTime;\n        uint256 rollingPeriodInDays;\n        uint256 endTime;\n        RestrictionType typeOfRestriction;\n    }\n\n    struct BucketDetails {\n        uint256 lastTradedDayTime;\n        uint256 sumOfLastPeriod;   // It is the sum of transacted amount within the last rollingPeriodDays \n        uint256 daysCovered;    // No of days covered till (from the startTime of VolumeRestriction)\n        uint256 dailyLastTradedDayTime;\n    }\n\n    // Global restriction that applies to all token holders\n    VolumeRestriction public defaultRestriction;\n    // Daily global restriction that applies to all token holders (Total ST traded daily is restricted)\n    VolumeRestriction public defaultDailyRestriction;\n    // Restriction stored corresponds to a particular token holder\n    mapping(address => VolumeRestriction) public individualRestriction;\n    // Daily restriction stored corresponds to a particular token holder\n    mapping(address => VolumeRestriction) public individualDailyRestriction;\n    // Storing _from => day's timestamp => total amount transact in a day --individual\n    mapping(address => mapping(uint256 => uint256)) internal bucket;\n    // Storing the information that used to validate the transaction\n    mapping(address => BucketDetails) internal userToBucket;\n    // Storing the information related to default restriction\n    mapping(address => BucketDetails) internal defaultUserToBucket;\n    // List of wallets that are exempted from all the restrictions applied by the this contract\n    mapping(address => bool) public exemptList;\n\n}"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/STO/ISTO.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../../Pausable.sol\";\nimport \"../Module.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"./ISTOStorage.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title Interface to be implemented by all STO modules\n */\ncontract ISTO is ISTOStorage, Module, Pausable  {event __CoverageISTO(string fileName, uint256 lineNumber);\nevent __FunctionCoverageISTO(string fileName, uint256 fnId);\nevent __StatementCoverageISTO(string fileName, uint256 statementId);\nevent __BranchCoverageISTO(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageISTO(string fileName, uint256 branchId);\nevent __AssertPostCoverageISTO(string fileName, uint256 branchId);\n\n    using SafeMath for uint256;\n\n    enum FundRaiseType { ETH, POLY, SC }\n    \n    // Event\n    event SetFundRaiseTypes(FundRaiseType[] _fundRaiseTypes);\n\n    /**\n    * @notice Reclaims ERC20Basic compatible tokens\n    * @dev We duplicate here due to the overriden owner & onlyOwner\n    * @param _tokenContract The address of the token contract\n    */\n    function reclaimERC20(address _tokenContract) external onlyOwner {emit __FunctionCoverageISTO('./contracts/modules/STO/ISTO.sol',1);\n\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',26);\n        emit __AssertPreCoverageISTO('./contracts/modules/STO/ISTO.sol',1);\nemit __StatementCoverageISTO('./contracts/modules/STO/ISTO.sol',1);\nrequire(_tokenContract != address(0), \"Invalid address\");emit __AssertPostCoverageISTO('./contracts/modules/STO/ISTO.sol',1);\n\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',27);\n        emit __StatementCoverageISTO('./contracts/modules/STO/ISTO.sol',2);\nIERC20 token = IERC20(_tokenContract);\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',28);\n        emit __StatementCoverageISTO('./contracts/modules/STO/ISTO.sol',3);\nuint256 balance = token.balanceOf(address(this));\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',29);\n        emit __AssertPreCoverageISTO('./contracts/modules/STO/ISTO.sol',2);\nemit __StatementCoverageISTO('./contracts/modules/STO/ISTO.sol',4);\nrequire(token.transfer(msg.sender, balance), \"Transfer failed\");emit __AssertPostCoverageISTO('./contracts/modules/STO/ISTO.sol',2);\n\n    }\n\n    /**\n     * @notice Returns funds raised by the STO\n     */\n    function getRaised(FundRaiseType _fundRaiseType) public  returns (uint256) {emit __FunctionCoverageISTO('./contracts/modules/STO/ISTO.sol',2);\n\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',36);\n        emit __StatementCoverageISTO('./contracts/modules/STO/ISTO.sol',5);\nreturn fundsRaised[uint8(_fundRaiseType)];\n    }\n\n    /**\n     * @notice Returns the total no. of tokens sold\n     */\n    function getTokensSold() public  returns (uint256);\n\n    /**\n     * @notice Pause (overridden function)\n     */\n    function pause() public onlyOwner {emit __FunctionCoverageISTO('./contracts/modules/STO/ISTO.sol',3);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',49);\n        emit __AssertPreCoverageISTO('./contracts/modules/STO/ISTO.sol',3);\nemit __StatementCoverageISTO('./contracts/modules/STO/ISTO.sol',6);\nrequire(now < endTime, \"STO has been finalized\");emit __AssertPostCoverageISTO('./contracts/modules/STO/ISTO.sol',3);\n\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',50);\n        super._pause();\n    }\n\n    /**\n     * @notice Unpause (overridden function)\n     */\n    function unpause() public onlyOwner {emit __FunctionCoverageISTO('./contracts/modules/STO/ISTO.sol',4);\n\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',57);\n        super._unpause();\n    }\n\n    function _setFundRaiseType(FundRaiseType[] _fundRaiseTypes) internal {emit __FunctionCoverageISTO('./contracts/modules/STO/ISTO.sol',5);\n\n        // FundRaiseType[] parameter type ensures only valid values for _fundRaiseTypes\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',62);\n        emit __AssertPreCoverageISTO('./contracts/modules/STO/ISTO.sol',4);\nemit __StatementCoverageISTO('./contracts/modules/STO/ISTO.sol',7);\nrequire(_fundRaiseTypes.length > 0, \"Raise type is not specified\");emit __AssertPostCoverageISTO('./contracts/modules/STO/ISTO.sol',4);\n\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',63);\n        emit __StatementCoverageISTO('./contracts/modules/STO/ISTO.sol',8);\nfundRaiseTypes[uint8(FundRaiseType.ETH)] = false;\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',64);\n        emit __StatementCoverageISTO('./contracts/modules/STO/ISTO.sol',9);\nfundRaiseTypes[uint8(FundRaiseType.POLY)] = false;\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',65);\n        emit __StatementCoverageISTO('./contracts/modules/STO/ISTO.sol',10);\nfundRaiseTypes[uint8(FundRaiseType.SC)] = false;\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',66);\n        emit __StatementCoverageISTO('./contracts/modules/STO/ISTO.sol',11);\nfor (uint8 j = 0; j < _fundRaiseTypes.length; j++) {\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',67);\n            emit __StatementCoverageISTO('./contracts/modules/STO/ISTO.sol',12);\nfundRaiseTypes[uint8(_fundRaiseTypes[j])] = true;\n        }\nemit __CoverageISTO('./contracts/modules/STO/ISTO.sol',69);\n        emit __StatementCoverageISTO('./contracts/modules/STO/ISTO.sol',13);\nemit SetFundRaiseTypes(_fundRaiseTypes);\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/STO/CappedSTO.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ISTO.sol\";\nimport \"../../interfaces/ISecurityToken.sol\";\nimport \"openzeppelin-solidity/contracts/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title STO module for standard capped crowdsale\n */\ncontract CappedSTO is ISTO, ReentrancyGuard {event __CoverageCappedSTO(string fileName, uint256 lineNumber);\nevent __FunctionCoverageCappedSTO(string fileName, uint256 fnId);\nevent __StatementCoverageCappedSTO(string fileName, uint256 statementId);\nevent __BranchCoverageCappedSTO(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageCappedSTO(string fileName, uint256 branchId);\nevent __AssertPostCoverageCappedSTO(string fileName, uint256 branchId);\n\n    using SafeMath for uint256;\n\n    // Determine whether users can invest on behalf of a beneficiary\n    bool public allowBeneficialInvestments = false;\n    // How many token units a buyer gets (multiplied by 10^18) per wei / base unit of POLY\n    // If rate is 10^18, buyer will get 1 token unit for every wei / base unit of poly.\n    uint256 public rate;\n    //How many token base units this STO will be allowed to sell to investors\n    // 1 full token = 10^decimals_of_token base units\n    uint256 public cap;\n\n    mapping (address => uint256) public investors;\n\n    /**\n    * Event for token purchase logging\n    * @param purchaser who paid for the tokens\n    * @param beneficiary who got the tokens\n    * @param value weis paid for purchase\n    * @param amount amount of tokens purchased\n    */\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n    event SetAllowBeneficialInvestments(bool _allowed);\n\n    constructor (address _securityToken, address _polyAddress) public\n    Module(_securityToken, _polyAddress)\n    {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',1);\n\n    }\n\n    //////////////////////////////////\n    /**\n    * @notice fallback function ***DO NOT OVERRIDE***\n    */\n    function () external payable {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',2);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',46);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',1);\nbuyTokens(msg.sender);\n    }\n\n    /**\n     * @notice Function used to intialize the contract variables\n     * @param _startTime Unix timestamp at which offering get started\n     * @param _endTime Unix timestamp at which offering get ended\n     * @param _cap Maximum No. of token base units for sale\n     * @param _rate Token units a buyer gets multiplied by 10^18 per wei / base unit of POLY \n     * @param _fundRaiseTypes Type of currency used to collect the funds\n     * @param _fundsReceiver Ethereum account address to hold the funds\n     */\n    function configure(\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _cap,\n        uint256 _rate,\n        FundRaiseType[] _fundRaiseTypes,\n        address _fundsReceiver\n    )\n    public\n    onlyFactory\n    {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',3);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',69);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',1);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',2);\nrequire(endTime == 0, \"Already configured\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',1);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',70);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',2);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',3);\nrequire(_rate > 0, \"Rate of token should be greater than 0\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',2);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',71);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',3);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',4);\nrequire(_fundsReceiver != address(0), \"Zero address is not permitted\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',3);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',73);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',4);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',5);\nrequire(_startTime >= now && _endTime > _startTime, \"Date parameters are not valid\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',4);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',74);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',5);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',6);\nrequire(_cap > 0, \"Cap should be greater than 0\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',5);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',75);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',6);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',7);\nrequire(_fundRaiseTypes.length == 1, \"It only selects single fund raise type\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',6);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',76);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',8);\nstartTime = _startTime;\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',77);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',9);\nendTime = _endTime;\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',78);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',10);\ncap = _cap;\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',79);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',11);\nrate = _rate;\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',80);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',12);\nwallet = _fundsReceiver;\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',81);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',13);\n_setFundRaiseType(_fundRaiseTypes);\n    }\n\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() public  returns (bytes4) {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',4);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',88);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',14);\nreturn bytes4(keccak256(\"configure(uint256,uint256,uint256,uint256,uint8[],address)\"));\n    }\n\n    /**\n     * @notice Function to set allowBeneficialInvestments (allow beneficiary to be different to funder)\n     * @param _allowBeneficialInvestments Boolean to allow or disallow beneficial investments\n     */\n    function changeAllowBeneficialInvestments(bool _allowBeneficialInvestments) public onlyOwner {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',5);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',96);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',7);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',15);\nrequire(_allowBeneficialInvestments != allowBeneficialInvestments, \"Does not change value\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',7);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',97);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',16);\nallowBeneficialInvestments = _allowBeneficialInvestments;\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',98);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',17);\nemit SetAllowBeneficialInvestments(allowBeneficialInvestments);\n    }\n\n    /**\n      * @notice Low level token purchase ***DO NOT OVERRIDE***\n      * @param _beneficiary Address performing the token purchase\n      */\n    function buyTokens(address _beneficiary) public payable nonReentrant {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',6);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',106);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',18);\nif (!allowBeneficialInvestments) {emit __BranchCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',8,0);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',107);\n            emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',9);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',19);\nrequire(_beneficiary == msg.sender, \"Beneficiary address does not match msg.sender\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',9);\n\n        }else { emit __BranchCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',8,1);}\n\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',110);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',10);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',20);\nrequire(!paused, \"Should not be paused\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',10);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',111);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',11);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',21);\nrequire(fundRaiseTypes[uint8(FundRaiseType.ETH)], \"Mode of investment is not ETH\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',11);\n\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',113);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',22);\nuint256 weiAmount = msg.value;\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',114);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',23);\nuint256 refund = _processTx(_beneficiary, weiAmount);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',115);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',24);\nweiAmount = weiAmount.sub(refund);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',117);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',25);\n_forwardFunds(refund);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',118);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',26);\n_postValidatePurchase(_beneficiary, weiAmount);\n    }\n\n    /**\n      * @notice low level token purchase\n      * @param _investedPOLY Amount of POLY invested\n      */\n    function buyTokensWithPoly(uint256 _investedPOLY) public nonReentrant{emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',7);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',126);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',12);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',27);\nrequire(!paused, \"Should not be paused\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',12);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',127);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',13);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',28);\nrequire(fundRaiseTypes[uint8(FundRaiseType.POLY)], \"Mode of investment is not POLY\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',13);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',128);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',29);\nuint256 refund = _processTx(msg.sender, _investedPOLY);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',129);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',30);\n_forwardPoly(msg.sender, wallet, _investedPOLY.sub(refund));\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',130);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',31);\n_postValidatePurchase(msg.sender, _investedPOLY.sub(refund));\n    }\n\n    /**\n    * @notice Checks whether the cap has been reached.\n    * @return bool Whether the cap was reached\n    */\n    function capReached() public  returns (bool) {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',8);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',138);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',32);\nreturn totalTokensSold >= cap;\n    }\n\n    /**\n     * @notice Return the total no. of tokens sold\n     */\n    function getTokensSold() public  returns (uint256) {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',9);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',145);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',33);\nreturn totalTokensSold;\n    }\n\n    /**\n     * @notice Return the permissions flag that are associated with STO\n     */\n    function getPermissions() public  returns(bytes32[]) {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',10);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',152);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',34);\nbytes32[] memory allPermissions = new bytes32[](0);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',153);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',35);\nreturn allPermissions;\n    }\n\n    /**\n     * @notice Return the STO details\n     * @return Unixtimestamp at which offering gets start.\n     * @return Unixtimestamp at which offering ends.\n     * @return Number of token base units this STO will be allowed to sell to investors.\n     * @return Token units a buyer gets(multiplied by 10^18) per wei / base unit of POLY\n     * @return Amount of funds raised\n     * @return Number of individual investors this STO have.\n     * @return Amount of tokens get sold. \n     * @return Boolean value to justify whether the fund raise type is POLY or not, i.e true for POLY.\n     */\n    function getSTODetails() public  returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, bool) {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',11);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',168);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',36);\nreturn (\n            startTime,\n            endTime,\n            cap,\n            rate,\n            (fundRaiseTypes[uint8(FundRaiseType.POLY)]) ? fundsRaised[uint8(FundRaiseType.POLY)]: fundsRaised[uint8(FundRaiseType.ETH)],\n            investorCount,\n            totalTokensSold,\n            (fundRaiseTypes[uint8(FundRaiseType.POLY)])\n        );\n    }\n\n    // -----------------------------------------\n    // Internal interface (extensible)\n    // -----------------------------------------\n    /**\n      * Processing the purchase as well as verify the required validations\n      * @param _beneficiary Address performing the token purchase\n      * @param _investedAmount Value in wei involved in the purchase\n    */\n    function _processTx(address _beneficiary, uint256 _investedAmount) internal returns(uint256 refund) {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',12);\n\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',190);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',37);\n_preValidatePurchase(_beneficiary, _investedAmount);\n        // calculate token amount to be created\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',192);\n        uint256 tokens;\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',193);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',38);\n(tokens, refund) = _getTokenAmount(_investedAmount);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',194);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',39);\n_investedAmount = _investedAmount.sub(refund);\n\n        // update state\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',197);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',40);\nif (fundRaiseTypes[uint8(FundRaiseType.POLY)]) {emit __BranchCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',14,0);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',198);\n            emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',41);\nfundsRaised[uint8(FundRaiseType.POLY)] = fundsRaised[uint8(FundRaiseType.POLY)].add(_investedAmount);\n        } else {emit __BranchCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',14,1);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',200);\n            emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',42);\nfundsRaised[uint8(FundRaiseType.ETH)] = fundsRaised[uint8(FundRaiseType.ETH)].add(_investedAmount);\n        }\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',202);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',43);\ntotalTokensSold = totalTokensSold.add(tokens);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',204);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',44);\n_processPurchase(_beneficiary, tokens);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',205);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',45);\nemit TokenPurchase(msg.sender, _beneficiary, _investedAmount, tokens);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',207);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',46);\n_updatePurchasingState(_beneficiary, _investedAmount);\n    }\n\n    /**\n    * @notice Validation of an incoming purchase.\n      Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n    * @param _beneficiary Address performing the token purchase\n    * @param _investedAmount Value in wei involved in the purchase\n    */\n    function _preValidatePurchase(address _beneficiary, uint256 _investedAmount) internal  {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',13);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',217);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',15);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',47);\nrequire(_beneficiary != address(0), \"Beneficiary address should not be 0x\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',15);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',218);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',16);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',48);\nrequire(_investedAmount != 0, \"Amount invested should not be equal to 0\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',16);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',219);\n        uint256 tokens;\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',220);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',49);\n(tokens, ) = _getTokenAmount(_investedAmount);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',221);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',17);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',50);\nrequire(totalTokensSold.add(tokens) <= cap, \"Investment more than cap is not allowed\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',17);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',223);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',18);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',51);\nrequire(now >= startTime && now <= endTime, \"Offering is closed/Not yet started\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',18);\n\n    }\n\n    /**\n    * @notice Validation of an executed purchase.\n      Observe state and use revert statements to undo rollback when valid conditions are not met.\n    */\n    function _postValidatePurchase(address /*_beneficiary*/, uint256 /*_investedAmount*/) internal  {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',14);\n\n      // optional override\n    }\n\n    /**\n    * @notice Source of tokens.\n      Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n    * @param _beneficiary Address performing the token purchase\n    * @param _tokenAmount Number of tokens to be emitted\n    */\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',15);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',241);\n        emit __AssertPreCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',19);\nemit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',52);\nrequire(ISecurityToken(securityToken).mint(_beneficiary, _tokenAmount), \"Error in minting the tokens\");emit __AssertPostCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',19);\n\n    }\n\n    /**\n    * @notice Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n    * @param _beneficiary Address receiving the tokens\n    * @param _tokenAmount Number of tokens to be purchased\n    */\n    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',16);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',250);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',53);\nif (investors[_beneficiary] == 0) {emit __BranchCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',20,0);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',251);\n            emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',54);\ninvestorCount = investorCount + 1;\n        }else { emit __BranchCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',20,1);}\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',253);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',55);\ninvestors[_beneficiary] = investors[_beneficiary].add(_tokenAmount);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',255);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',56);\n_deliverTokens(_beneficiary, _tokenAmount);\n    }\n\n    /**\n    * @notice Overrides for extensions that require an internal state to check for validity\n      (current user contributions, etc.)\n    */\n    function _updatePurchasingState(address /*_beneficiary*/, uint256 /*_investedAmount*/) internal  {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',17);\n\n      // optional override\n    }\n\n    /**\n    * @notice Overrides to extend the way in which ether is converted to tokens.\n    * @param _investedAmount Value in wei to be converted into tokens\n    * @return Number of tokens that can be purchased with the specified _investedAmount\n    * @return Remaining amount that should be refunded to the investor\n    */\n    function _getTokenAmount(uint256 _investedAmount) internal  returns (uint256 _tokens, uint256 _refund) {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',18);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',273);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',57);\n_tokens = _investedAmount.mul(rate);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',274);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',58);\n_tokens = _tokens.div(uint256(10) ** 18);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',275);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',59);\nuint256 granularity = ISecurityToken(securityToken).granularity();\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',276);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',60);\n_tokens = _tokens.div(granularity);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',277);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',61);\n_tokens = _tokens.mul(granularity);\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',278);\n        emit __StatementCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',62);\n_refund = _investedAmount.sub((_tokens.mul(uint256(10) ** 18)).div(rate));\n    }\n\n    /**\n    * @notice Determines how ETH is stored/forwarded on purchases.\n    */\n    function _forwardFunds(uint256 _refund) internal {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',19);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',285);\n        wallet.transfer(msg.value.sub(_refund));\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',286);\n        msg.sender.transfer(_refund);\n    }\n\n    /**\n     * @notice Internal function used to forward the POLY raised to beneficiary address\n     * @param _beneficiary Address of the funds reciever\n     * @param _to Address who wants to ST-20 tokens\n     * @param _fundsAmount Amount invested by _to\n     */\n    function _forwardPoly(address _beneficiary, address _to, uint256 _fundsAmount) internal {emit __FunctionCoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',20);\n\nemit __CoverageCappedSTO('./contracts/modules/STO/CappedSTO.sol',296);\n        polyToken.transferFrom(_beneficiary, _to, _fundsAmount);\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/STO/CappedSTOFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./CappedSTO.sol\";\nimport \"../ModuleFactory.sol\";\nimport \"../../libraries/Util.sol\";\n\n/**\n * @title Factory for deploying CappedSTO module\n */\ncontract CappedSTOFactory is ModuleFactory {event __CoverageCappedSTOFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageCappedSTOFactory(string fileName, uint256 fnId);\nevent __StatementCoverageCappedSTOFactory(string fileName, uint256 statementId);\nevent __BranchCoverageCappedSTOFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageCappedSTOFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageCappedSTOFactory(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {emit __FunctionCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',1);\n\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',19);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',1);\nversion = \"2.1.0\";\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',20);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',2);\nname = \"CappedSTO\";\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',21);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',3);\ntitle = \"Capped STO\";\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',22);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',4);\ndescription = \"This smart contract creates a maximum number of tokens (i.e. hard cap) which the total aggregate of tokens acquired by all investors cannot exceed. Security tokens are sent to the investor upon reception of the funds (ETH or POLY), and any security tokens left upon termination of the offering will not be minted.\";\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',23);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',5);\ncompatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',24);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',6);\ncompatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n    }\n\n     /**\n     * @notice Used to launch the Module with the help of factory\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes _data) external returns(address) {emit __FunctionCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',2);\n\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',32);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',7);\nif(setupCost > 0)\n            {emit __AssertPreCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',2);\nemit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',8);\nemit __BranchCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',1,0);emit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',33);\nrequire(polyToken.transferFrom(msg.sender, owner, setupCost), \"Sufficent Allowance is not provided\");emit __AssertPostCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',2);\n}else { emit __BranchCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',1,1);}\n\n        //Check valid bytes - can only call module init function\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',35);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',9);\nCappedSTO cappedSTO = new CappedSTO(msg.sender, address(polyToken));\n        //Checks that _data is valid (not calling anything it shouldn't)\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',37);\n        emit __AssertPreCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',3);\nemit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',10);\nrequire(Util.getSig(_data) == cappedSTO.getInitFunction(), \"Invalid data\");emit __AssertPostCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',3);\n\n        /*solium-disable-next-line security/no-low-level-calls*/\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',39);\n        emit __AssertPreCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',4);\nemit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',11);\nrequire(address(cappedSTO).call(_data), \"Unsuccessfull call\");emit __AssertPostCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',4);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',41);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',12);\nemit GenerateModuleFromFactory(address(cappedSTO), getName(), address(this), msg.sender, setupCost, now);\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',42);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',13);\nreturn address(cappedSTO);\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {emit __FunctionCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',3);\n\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',49);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',14);\nuint8[] memory res = new uint8[](1);\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',50);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',15);\nres[0] = 3;\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',51);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',16);\nreturn res;\n    }\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {emit __FunctionCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',4);\n\n        /*solium-disable-next-line max-len*/\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',59);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',17);\nreturn \"Initialises a capped STO. Init parameters are _startTime (time STO starts), _endTime (time STO ends), _cap (cap in tokens for STO), _rate (POLY/ETH to token rate), _fundRaiseType (whether you are raising in POLY or ETH), _polyToken (address of POLY token), _fundsReceiver (address which will receive funds)\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {emit __FunctionCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',5);\n\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',66);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',18);\nbytes32[] memory availableTags = new bytes32[](4);\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',67);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',19);\navailableTags[0] = \"Capped\";\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',68);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',20);\navailableTags[1] = \"Non-refundable\";\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',69);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',21);\navailableTags[2] = \"POLY\";\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',70);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',22);\navailableTags[3] = \"ETH\";\nemit __CoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',71);\n        emit __StatementCoverageCappedSTOFactory('./contracts/modules/STO/CappedSTOFactory.sol',23);\nreturn availableTags;\n    }\n\n}\n"},"openzeppelin-solidity/contracts/math/SafeMath.sol":{"content":"pragma solidity ^0.4.23;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/STO/DummySTO.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ISTO.sol\";\nimport \"../../interfaces/ISecurityToken.sol\";\n\n/**\n * @title STO module for sample implementation of a different crowdsale module\n */\ncontract DummySTO is ISTO {event __CoverageDummySTO(string fileName, uint256 lineNumber);\nevent __FunctionCoverageDummySTO(string fileName, uint256 fnId);\nevent __StatementCoverageDummySTO(string fileName, uint256 statementId);\nevent __BranchCoverageDummySTO(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageDummySTO(string fileName, uint256 branchId);\nevent __AssertPostCoverageDummySTO(string fileName, uint256 branchId);\n\n\n    bytes32 public constant ADMIN = \"ADMIN\";\n\n    uint256 public investorCount;\n\n    uint256 public cap;\n    string public someString;\n\n    event GenerateTokens(address _investor, uint256 _amount);\n\n    mapping (address => uint256) public investors;\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress) public\n    Module(_securityToken, _polyAddress)\n    {emit __FunctionCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',1);\n\n    }\n\n    /**\n     * @notice Function used to intialize the differnet variables\n     * @param _startTime Unix timestamp at which offering get started\n     * @param _endTime Unix timestamp at which offering get ended\n     * @param _cap Maximum No. of tokens for sale\n     * @param _someString Any string that contails the details\n     */\n    function configure(uint256 _startTime, uint256 _endTime, uint256 _cap, string _someString) public onlyFactory {emit __FunctionCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',2);\n\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',40);\n        emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',1);\nstartTime = _startTime;\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',41);\n        emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',2);\nendTime = _endTime;\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',42);\n        emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',3);\ncap = _cap;\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',43);\n        emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',4);\nsomeString = _someString;\n    }\n\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() public  returns (bytes4) {emit __FunctionCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',3);\n\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',50);\n        emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',5);\nreturn bytes4(keccak256(\"configure(uint256,uint256,uint256,string)\"));\n    }\n\n    /**\n     * @notice Function used to generate the tokens\n     * @param _investor Address of the investor\n     * @param _amount Amount of ETH or Poly invested by the investor\n     */\n    function generateTokens(address _investor, uint256 _amount) public withPerm(ADMIN) {emit __FunctionCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',4);\n\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',59);\n        emit __AssertPreCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',1);\nemit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',6);\nrequire(!paused, \"Should not be paused\");emit __AssertPostCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',1);\n\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',60);\n        emit __AssertPreCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',2);\nemit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',7);\nrequire(_amount > 0, \"Amount should be greater than 0\");emit __AssertPostCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',2);\n\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',61);\n        emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',8);\nISecurityToken(securityToken).mint(_investor, _amount);\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',62);\n        emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',9);\nif (investors[_investor] == 0) {emit __BranchCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',3,0);\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',63);\n            emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',10);\ninvestorCount = investorCount + 1;\n        }else { emit __BranchCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',3,1);}\n\n        //TODO: Add SafeMath maybe\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',66);\n        emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',11);\ninvestors[_investor] = investors[_investor] + _amount;\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',67);\n        emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',12);\nemit GenerateTokens (_investor, _amount);\n    }\n\n    /**\n     * @notice Returns the total no. of investors\n     */\n    function getNumberInvestors() public  returns (uint256) {emit __FunctionCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',5);\n\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',74);\n        emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',13);\nreturn investorCount;\n    }\n\n    /**\n     * @notice Returns the total no. of investors\n     */\n    function getTokensSold() public  returns (uint256) {emit __FunctionCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',6);\n\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',81);\n        emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',14);\nreturn 0;\n    }\n\n    /**\n     * @notice Returns the permissions flag that are associated with STO\n     */\n    function getPermissions() public  returns(bytes32[]) {emit __FunctionCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',7);\n\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',88);\n        emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',15);\nbytes32[] memory allPermissions = new bytes32[](1);\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',89);\n        emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',16);\nallPermissions[0] = ADMIN;\nemit __CoverageDummySTO('./contracts/modules/STO/DummySTO.sol',90);\n        emit __StatementCoverageDummySTO('./contracts/modules/STO/DummySTO.sol',17);\nreturn allPermissions;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/STO/DummySTOFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./DummySTO.sol\";\nimport \"../ModuleFactory.sol\";\nimport \"../../libraries/Util.sol\";\n\n/**\n * @title Factory for deploying DummySTO module\n */\ncontract DummySTOFactory is ModuleFactory {event __CoverageDummySTOFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageDummySTOFactory(string fileName, uint256 fnId);\nevent __StatementCoverageDummySTOFactory(string fileName, uint256 statementId);\nevent __BranchCoverageDummySTOFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageDummySTOFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageDummySTOFactory(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {emit __FunctionCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',1);\n\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',19);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',1);\nversion = \"1.0.0\";\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',20);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',2);\nname = \"DummySTO\";\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',21);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',3);\ntitle = \"Dummy STO\";\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',22);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',4);\ndescription = \"Dummy STO\";\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',23);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',5);\ncompatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',24);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',6);\ncompatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n    }\n    /**\n     * @notice Used to launch the Module with the help of factory\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes _data) external returns(address) {emit __FunctionCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',2);\n\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',31);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',7);\nif (setupCost > 0)\n            {emit __AssertPreCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',2);\nemit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',8);\nemit __BranchCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',1,0);emit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',32);\nrequire(polyToken.transferFrom(msg.sender, owner, setupCost), \"Sufficent Allowance is not provided\");emit __AssertPostCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',2);\n}else { emit __BranchCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',1,1);}\n\n        //Check valid bytes - can only call module init function\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',34);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',9);\nDummySTO dummySTO = new DummySTO(msg.sender, address(polyToken));\n        //Checks that _data is valid (not calling anything it shouldn't)\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',36);\n        emit __AssertPreCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',3);\nemit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',10);\nrequire(Util.getSig(_data) == dummySTO.getInitFunction(), \"Invalid data\");emit __AssertPostCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',3);\n\n        /*solium-disable-next-line security/no-low-level-calls*/\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',38);\n        emit __AssertPreCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',4);\nemit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',11);\nrequire(address(dummySTO).call(_data), \"Unsuccessfull call\");emit __AssertPostCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',4);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',40);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',12);\nemit GenerateModuleFromFactory(address(dummySTO), getName(), address(this), msg.sender, setupCost, now);\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',41);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',13);\nreturn address(dummySTO);\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {emit __FunctionCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',3);\n\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',48);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',14);\nuint8[] memory res = new uint8[](1);\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',49);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',15);\nres[0] = 3;\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',50);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',16);\nreturn res;\n    }\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {emit __FunctionCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',4);\n\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',57);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',17);\nreturn \"Dummy STO - you can mint tokens at will\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {emit __FunctionCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',5);\n\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',64);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',18);\nbytes32[] memory availableTags = new bytes32[](4);\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',65);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',19);\navailableTags[0] = \"Dummy\";\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',66);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',20);\navailableTags[1] = \"Non-refundable\";\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',67);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',21);\navailableTags[2] = \"ETH\";\nemit __CoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',68);\n        emit __StatementCoverageDummySTOFactory('./contracts/modules/STO/DummySTOFactory.sol',22);\nreturn availableTags;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/mocks/MockFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../modules/STO/DummySTOFactory.sol\";\n\n/**\n * @title Mock Contract Not fit for production environment\n */\n\ncontract MockFactory is DummySTOFactory {\n\n    bool public switchTypes = false;\n     /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n      DummySTOFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {\n\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {\n        if (!switchTypes) {\n            uint8[] memory types = new uint8[](0);\n            return types;\n        } else {\n            uint8[] memory res = new uint8[](2);\n            res[0] = 1;\n            res[1] = 1;\n            return res;\n        }\n        \n    }\n\n    function changeTypes() external onlyOwner {\n        switchTypes = !switchTypes;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/mocks/TestSTOFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../modules/STO/DummySTOFactory.sol\";\n\ncontract TestSTOFactory is DummySTOFactory {\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n      DummySTOFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {\n        version = \"1.0.0\";\n        name = \"TestSTO\";\n        title = \"Test STO\";\n        description = \"Test STO\";\n        compatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n        compatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n    }\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {\n        return \"Test STO - you can mint tokens at will\";\n    }\n\n    /**\n     * @notice Gets the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {\n        bytes32[] memory availableTags = new bytes32[](4);\n        availableTags[0] = \"Test\";\n        availableTags[1] = \"Non-refundable\";\n        availableTags[2] = \"ETH\";\n        return availableTags;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/STO/PreSaleSTO.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ISTO.sol\";\nimport \"../../interfaces/ISecurityToken.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title STO module for private presales\n */\ncontract PreSaleSTO is ISTO {event __CoveragePreSaleSTO(string fileName, uint256 lineNumber);\nevent __FunctionCoveragePreSaleSTO(string fileName, uint256 fnId);\nevent __StatementCoveragePreSaleSTO(string fileName, uint256 statementId);\nevent __BranchCoveragePreSaleSTO(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoveragePreSaleSTO(string fileName, uint256 branchId);\nevent __AssertPostCoveragePreSaleSTO(string fileName, uint256 branchId);\n\n    using SafeMath for uint256;\n\n    bytes32 public constant PRE_SALE_ADMIN = \"PRE_SALE_ADMIN\";\n\n    event TokensAllocated(address _investor, uint256 _amount);\n\n    mapping (address => uint256) public investors;\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress) public\n    Module(_securityToken, _polyAddress)\n    {emit __FunctionCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',1);\n\n    }\n\n    /**\n     * @notice Function used to initialize the different variables\n     * @param _endTime Unix timestamp at which offering ends\n     */\n    function configure(uint256 _endTime) public onlyFactory {emit __FunctionCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',2);\n\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',34);\n        emit __AssertPreCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',1);\nemit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',1);\nrequire(_endTime != 0, \"endTime should not be 0\");emit __AssertPostCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',1);\n\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',35);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',2);\nendTime = _endTime;\n    }\n\n    /**\n     * @notice This function returns the signature of the configure function\n     */\n    function getInitFunction() public  returns (bytes4) {emit __FunctionCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',3);\n\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',42);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',3);\nreturn bytes4(keccak256(\"configure(uint256)\"));\n    }\n\n    /**\n     * @notice Returns the total no. of investors\n     */\n    function getNumberInvestors() public  returns (uint256) {emit __FunctionCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',4);\n\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',49);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',4);\nreturn investorCount;\n    }\n\n    /**\n     * @notice Returns the total no. of tokens sold\n     */\n    function getTokensSold() public  returns (uint256) {emit __FunctionCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',5);\n\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',56);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',5);\nreturn totalTokensSold;\n    }\n\n    /**\n     * @notice Returns the permissions flag that are associated with STO\n     */\n    function getPermissions() public  returns(bytes32[]) {emit __FunctionCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',6);\n\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',63);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',6);\nbytes32[] memory allPermissions = new bytes32[](1);\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',64);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',7);\nallPermissions[0] = PRE_SALE_ADMIN;\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',65);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',8);\nreturn allPermissions;\n    }\n\n    /**\n     * @notice Function used to allocate tokens to the investor\n     * @param _investor Address of the investor\n     * @param _amount No. of tokens to be transferred to the investor\n     * @param _etherContributed How much ETH was contributed\n     * @param _polyContributed How much POLY was contributed\n     */\n    function allocateTokens(\n        address _investor,\n        uint256 _amount,\n        uint256 _etherContributed,\n        uint256 _polyContributed\n    )\n        public\n        withPerm(PRE_SALE_ADMIN)\n    {emit __FunctionCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',7);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',85);\n        emit __AssertPreCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',2);\nemit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',9);\nrequire(now <= endTime, \"Already passed Endtime\");emit __AssertPostCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',2);\n\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',86);\n        emit __AssertPreCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',3);\nemit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',10);\nrequire(_amount > 0, \"No. of tokens provided should be greater the zero\");emit __AssertPostCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',3);\n\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',87);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',11);\nISecurityToken(securityToken).mint(_investor, _amount);\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',88);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',12);\nif (investors[_investor] == uint256(0)) {emit __BranchCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',4,0);\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',89);\n            emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',13);\ninvestorCount = investorCount.add(1);\n        }else { emit __BranchCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',4,1);}\n\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',91);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',14);\ninvestors[_investor] = investors[_investor].add(_amount);\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',92);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',15);\nfundsRaised[uint8(FundRaiseType.ETH)] = fundsRaised[uint8(FundRaiseType.ETH)].add(_etherContributed);\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',93);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',16);\nfundsRaised[uint8(FundRaiseType.POLY)] = fundsRaised[uint8(FundRaiseType.POLY)].add(_polyContributed);\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',94);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',17);\ntotalTokensSold = totalTokensSold.add(_amount);\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',95);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',18);\nemit TokensAllocated(_investor, _amount);\n    }\n\n    /**\n     * @notice Function used to allocate tokens to multiple investors\n     * @param _investors Array of address of the investors\n     * @param _amounts Array of no. of tokens to be transferred to the investors\n     * @param _etherContributed Array of amount of ETH contributed by each investor\n     * @param _polyContributed Array of amount of POLY contributed by each investor\n     */\n    function allocateTokensMulti(\n        address[] _investors,\n        uint256[] _amounts,\n        uint256[] _etherContributed,\n        uint256[] _polyContributed\n    )\n        public\n        withPerm(PRE_SALE_ADMIN)\n    {emit __FunctionCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',8);\n\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',114);\n        emit __AssertPreCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',5);\nemit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',19);\nrequire(_investors.length == _amounts.length, \"Mis-match in length of the arrays\");emit __AssertPostCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',5);\n\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',115);\n        emit __AssertPreCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',6);\nemit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',20);\nrequire(_etherContributed.length == _polyContributed.length, \"Mis-match in length of the arrays\");emit __AssertPostCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',6);\n\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',116);\n        emit __AssertPreCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',7);\nemit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',21);\nrequire(_etherContributed.length == _investors.length, \"Mis-match in length of the arrays\");emit __AssertPostCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',7);\n\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',117);\n        emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',22);\nfor (uint256 i = 0; i < _investors.length; i++) {\nemit __CoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',118);\n            emit __StatementCoveragePreSaleSTO('./contracts/modules/STO/PreSaleSTO.sol',23);\nallocateTokens(_investors[i], _amounts[i], _etherContributed[i], _polyContributed[i]);\n        }\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/STO/PreSaleSTOFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./PreSaleSTO.sol\";\nimport \"../ModuleFactory.sol\";\nimport \"../../libraries/Util.sol\";\n\n/**\n * @title Factory for deploying PreSaleSTO module\n */\ncontract PreSaleSTOFactory is ModuleFactory {event __CoveragePreSaleSTOFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoveragePreSaleSTOFactory(string fileName, uint256 fnId);\nevent __StatementCoveragePreSaleSTOFactory(string fileName, uint256 statementId);\nevent __BranchCoveragePreSaleSTOFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoveragePreSaleSTOFactory(string fileName, uint256 branchId);\nevent __AssertPostCoveragePreSaleSTOFactory(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {emit __FunctionCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',1);\n\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',19);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',1);\nversion = \"1.0.0\";\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',20);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',2);\nname = \"PreSaleSTO\";\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',21);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',3);\ntitle = \"PreSale STO\";\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',22);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',4);\ndescription = \"Allows Issuer to configure pre-sale token allocations\";\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',23);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',5);\ncompatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',24);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',6);\ncompatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n    }\n\n    /**\n     * @notice Used to launch the Module with the help of factory\n     * @param _data Data used for the intialization of the module factory variables\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes _data) external returns(address) {emit __FunctionCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',2);\n\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',33);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',7);\nif (setupCost > 0) {emit __BranchCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',1,0);\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',34);\n            emit __AssertPreCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',2);\nemit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',8);\nrequire(polyToken.transferFrom(msg.sender, owner, setupCost), \"Sufficent Allowance is not provided\");emit __AssertPostCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',2);\n\n        }else { emit __BranchCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',1,1);}\n\n        //Check valid bytes - can only call module init function\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',37);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',9);\nPreSaleSTO preSaleSTO = new PreSaleSTO(msg.sender, address(polyToken));\n        //Checks that _data is valid (not calling anything it shouldn't)\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',39);\n        emit __AssertPreCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',3);\nemit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',10);\nrequire(Util.getSig(_data) == preSaleSTO.getInitFunction(), \"Invalid data\");emit __AssertPostCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',3);\n\n        /*solium-disable-next-line security/no-low-level-calls*/\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',41);\n        emit __AssertPreCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',4);\nemit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',11);\nrequire(address(preSaleSTO).call(_data), \"Unsuccessfull call\");emit __AssertPostCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',4);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',43);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',12);\nemit GenerateModuleFromFactory(address(preSaleSTO), getName(), address(this), msg.sender, setupCost, now);\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',44);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',13);\nreturn address(preSaleSTO);\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {emit __FunctionCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',3);\n\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',51);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',14);\nuint8[] memory res = new uint8[](1);\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',52);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',15);\nres[0] = 3;\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',53);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',16);\nreturn res;\n    }\n    \n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {emit __FunctionCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',4);\n\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',60);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',17);\nreturn \"Configure and track pre-sale token allocations\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {emit __FunctionCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',5);\n\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',67);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',18);\nbytes32[] memory availableTags = new bytes32[](1);\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',68);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',19);\navailableTags[0] = \"Presale\";\nemit __CoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',69);\n        emit __StatementCoveragePreSaleSTOFactory('./contracts/modules/STO/PreSaleSTOFactory.sol',20);\nreturn availableTags;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/STO/USDTieredSTO.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ISTO.sol\";\nimport \"../../interfaces/ISecurityToken.sol\";\nimport \"../../interfaces/IOracle.sol\";\nimport \"../../RegistryUpdater.sol\";\nimport \"../../libraries/DecimalMath.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ReentrancyGuard.sol\";\nimport \"./USDTieredSTOStorage.sol\";\n\n/**\n * @title STO module for standard capped crowdsale\n */\ncontract USDTieredSTO is USDTieredSTOStorage, ISTO, ReentrancyGuard {event __CoverageUSDTieredSTO(string fileName, uint256 lineNumber);\nevent __FunctionCoverageUSDTieredSTO(string fileName, uint256 fnId);\nevent __StatementCoverageUSDTieredSTO(string fileName, uint256 statementId);\nevent __BranchCoverageUSDTieredSTO(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageUSDTieredSTO(string fileName, uint256 branchId);\nevent __AssertPostCoverageUSDTieredSTO(string fileName, uint256 branchId);\n\n    using SafeMath for uint256;\n\n    string public constant POLY_ORACLE = \"PolyUsdOracle\";\n    string public constant ETH_ORACLE = \"EthUsdOracle\";\n\n    ////////////\n    // Events //\n    ////////////\n\n    event SetAllowBeneficialInvestments(bool _allowed);\n    event SetNonAccreditedLimit(address _investor, uint256 _limit);\n    event SetAccredited(address _investor, bool _accredited);\n    event TokenPurchase(\n        address indexed _purchaser,\n        address indexed _beneficiary,\n        uint256 _tokens,\n        uint256 _usdAmount,\n        uint256 _tierPrice,\n        uint256 _tier\n    );\n    event FundsReceived(\n        address indexed _purchaser,\n        address indexed _beneficiary,\n        uint256 _usdAmount,\n        FundRaiseType _fundRaiseType,\n        uint256 _receivedValue,\n        uint256 _spentValue,\n        uint256 _rate\n    );\n    event ReserveTokenMint(address indexed _owner, address indexed _wallet, uint256 _tokens, uint256 _latestTier);\n    event SetAddresses(\n        address indexed _wallet,\n        address indexed _reserveWallet,\n        address[] _usdTokens\n    );\n    event SetLimits(\n        uint256 _nonAccreditedLimitUSD,\n        uint256 _minimumInvestmentUSD\n    );\n    event SetTimes(\n        uint256 _startTime,\n        uint256 _endTime\n    );\n    event SetTiers(\n        uint256[] _ratePerTier,\n        uint256[] _ratePerTierDiscountPoly,\n        uint256[] _tokensPerTierTotal,\n        uint256[] _tokensPerTierDiscountPoly\n    );\n\n    ///////////////\n    // Modifiers //\n    ///////////////\n\n    modifier validETH {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',1);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',71);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',1);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',1);\nrequire(_getOracle(bytes32(\"ETH\"), bytes32(\"USD\")) != address(0), \"Invalid Oracle\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',1);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',72);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',2);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',2);\nrequire(fundRaiseTypes[uint8(FundRaiseType.ETH)], \"ETH not allowed\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',2);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',73);\n        _;\n    }\n\n    modifier validPOLY {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',2);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',77);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',3);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',3);\nrequire(_getOracle(bytes32(\"POLY\"), bytes32(\"USD\")) != address(0), \"Invalid Oracle\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',3);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',78);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',4);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',4);\nrequire(fundRaiseTypes[uint8(FundRaiseType.POLY)], \"POLY not allowed\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',4);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',79);\n        _;\n    }\n\n    modifier validSC(address _usdToken) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',3);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',83);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',5);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',5);\nrequire(fundRaiseTypes[uint8(FundRaiseType.SC)] && usdTokenEnabled[_usdToken], \"USD not allowed\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',5);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',84);\n        _;\n    }\n\n    ///////////////////////\n    // STO Configuration //\n    ///////////////////////\n\n    constructor (address _securityToken, address _polyAddress)\n    public\n    Module(_securityToken, _polyAddress)\n    {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',4);\n\n    }\n\n    /**\n     * @notice Function used to intialize the contract variables\n     * @param _startTime Unix timestamp at which offering get started\n     * @param _endTime Unix timestamp at which offering get ended\n     * @param _ratePerTier Rate (in USD) per tier (* 10**18)\n     * @param _tokensPerTierTotal Tokens available in each tier\n     * @param _nonAccreditedLimitUSD Limit in USD (* 10**18) for non-accredited investors\n     * @param _minimumInvestmentUSD Minimun investment in USD (* 10**18)\n     * @param _fundRaiseTypes Types of currency used to collect the funds\n     * @param _wallet Ethereum account address to hold the funds\n     * @param _reserveWallet Ethereum account address to receive unsold tokens\n     * @param _usdTokens Array of contract addressess of the stable coins\n     */\n    function configure(\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256[] _ratePerTier,\n        uint256[] _ratePerTierDiscountPoly,\n        uint256[] _tokensPerTierTotal,\n        uint256[] _tokensPerTierDiscountPoly,\n        uint256 _nonAccreditedLimitUSD,\n        uint256 _minimumInvestmentUSD,\n        FundRaiseType[] _fundRaiseTypes,\n        address _wallet,\n        address _reserveWallet,\n        address[] _usdTokens\n    ) public onlyFactory {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',5);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',124);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',6);\noracleKeys[bytes32(\"ETH\")][bytes32(\"USD\")] = ETH_ORACLE;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',125);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',7);\noracleKeys[bytes32(\"POLY\")][bytes32(\"USD\")] = POLY_ORACLE;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',126);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',6);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',8);\nrequire(endTime == 0, \"Already configured\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',6);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',127);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',9);\n_modifyTimes(_startTime, _endTime);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',128);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',10);\n_modifyTiers(_ratePerTier, _ratePerTierDiscountPoly, _tokensPerTierTotal, _tokensPerTierDiscountPoly);\n        // NB - _setFundRaiseType must come before modifyAddresses\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',130);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',11);\n_setFundRaiseType(_fundRaiseTypes);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',131);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',12);\n_modifyAddresses(_wallet, _reserveWallet, _usdTokens);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',132);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',13);\n_modifyLimits(_nonAccreditedLimitUSD, _minimumInvestmentUSD);\n    }\n\n    /**\n     * @dev Modifies fund raise types\n     * @param _fundRaiseTypes Array of fund raise types to allow\n     */\n    function modifyFunding(FundRaiseType[] _fundRaiseTypes) external onlyOwner {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',6);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',141);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',7);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',14);\nrequire(now < startTime, \"STO already started\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',7);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',142);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',15);\n_setFundRaiseType(_fundRaiseTypes);\n    }\n\n    /**\n     * @dev modifies max non accredited invets limit and overall minimum investment limit\n     * @param _nonAccreditedLimitUSD max non accredited invets limit\n     * @param _minimumInvestmentUSD overall minimum investment limit\n     */\n    function modifyLimits(\n        uint256 _nonAccreditedLimitUSD,\n        uint256 _minimumInvestmentUSD\n    ) external onlyOwner {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',7);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',155);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',8);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',16);\nrequire(now < startTime, \"STO already started\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',8);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',156);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',17);\n_modifyLimits(_nonAccreditedLimitUSD, _minimumInvestmentUSD);\n    }\n\n    /**\n     * @dev modifiers STO tiers. All tiers must be passed, can not edit specific tiers.\n     * @param _ratePerTier Array of rates per tier\n     * @param _ratePerTierDiscountPoly Array of discounted poly rates per tier\n     * @param _tokensPerTierTotal Array of total tokens per tier\n     * @param _tokensPerTierDiscountPoly Array of discounted tokens per tier\n     */\n    function modifyTiers(\n        uint256[] _ratePerTier,\n        uint256[] _ratePerTierDiscountPoly,\n        uint256[] _tokensPerTierTotal,\n        uint256[] _tokensPerTierDiscountPoly\n    ) external onlyOwner {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',8);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',173);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',9);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',18);\nrequire(now < startTime, \"STO already started\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',9);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',174);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',19);\n_modifyTiers(_ratePerTier, _ratePerTierDiscountPoly, _tokensPerTierTotal, _tokensPerTierDiscountPoly);\n    }\n\n    /**\n     * @dev Modifies STO start and end times\n     * @param _startTime start time of sto\n     * @param _endTime end time of sto\n     */\n    function modifyTimes(\n        uint256 _startTime,\n        uint256 _endTime\n    ) external onlyOwner {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',9);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',187);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',10);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',20);\nrequire(now < startTime, \"STO already started\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',10);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',188);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',21);\n_modifyTimes(_startTime, _endTime);\n    }\n\n    /**\n     * @dev Modifies addresses used as wallet, reserve wallet and usd token\n     * @param _wallet Address of wallet where funds are sent\n     * @param _reserveWallet Address of wallet where unsold tokens are sent\n     * @param _usdTokens Address of usd tokens\n     */\n    function modifyAddresses(\n        address _wallet,\n        address _reserveWallet,\n        address[] _usdTokens\n    ) external onlyOwner {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',10);\n\n        /*solium-disable-next-line security/no-block-members*/\n        // require(now < startTime, \"STO already started\");\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',204);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',22);\n_modifyAddresses(_wallet, _reserveWallet, _usdTokens);\n    }\n\n    function _modifyLimits(\n        uint256 _nonAccreditedLimitUSD,\n        uint256 _minimumInvestmentUSD\n    ) internal {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',11);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',211);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',23);\nminimumInvestmentUSD = _minimumInvestmentUSD;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',212);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',24);\nnonAccreditedLimitUSD = _nonAccreditedLimitUSD;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',213);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',25);\nemit SetLimits(minimumInvestmentUSD, nonAccreditedLimitUSD);\n    }\n\n    function _modifyTiers(\n        uint256[] _ratePerTier,\n        uint256[] _ratePerTierDiscountPoly,\n        uint256[] _tokensPerTierTotal,\n        uint256[] _tokensPerTierDiscountPoly\n    ) internal {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',12);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',222);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',11);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',26);\nrequire(_tokensPerTierTotal.length > 0, \"No tiers provided\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',11);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',223);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',12);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',27);\nrequire(_ratePerTier.length == _tokensPerTierTotal.length &&\n            _ratePerTierDiscountPoly.length == _tokensPerTierTotal.length &&\n            _tokensPerTierDiscountPoly.length == _tokensPerTierTotal.length,\n            \"Tier data length mismatch\"\n        );emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',12);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',228);\n        delete tiers;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',229);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',28);\nfor (uint256 i = 0; i < _ratePerTier.length; i++) {\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',230);\n            emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',13);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',29);\nrequire(_ratePerTier[i] > 0, \"Invalid rate\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',13);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',231);\n            emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',14);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',30);\nrequire(_tokensPerTierTotal[i] > 0, \"Invalid token amount\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',14);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',232);\n            emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',15);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',31);\nrequire(_tokensPerTierDiscountPoly[i] <= _tokensPerTierTotal[i], \"Too many discounted tokens\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',15);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',233);\n            emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',16);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',32);\nrequire(_ratePerTierDiscountPoly[i] <= _ratePerTier[i], \"Invalid discount\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',16);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',234);\n            tiers.push(Tier(_ratePerTier[i], _ratePerTierDiscountPoly[i], _tokensPerTierTotal[i], _tokensPerTierDiscountPoly[i], 0, 0));\n        }\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',236);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',33);\nemit SetTiers(_ratePerTier, _ratePerTierDiscountPoly, _tokensPerTierTotal, _tokensPerTierDiscountPoly);\n    }\n\n    function _modifyTimes(\n        uint256 _startTime,\n        uint256 _endTime\n    ) internal {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',13);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',244);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',17);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',34);\nrequire((_endTime > _startTime) && (_startTime > now), \"Invalid times\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',17);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',245);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',35);\nstartTime = _startTime;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',246);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',36);\nendTime = _endTime;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',247);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',37);\nemit SetTimes(_startTime, _endTime);\n    }\n\n    function _modifyAddresses(\n        address _wallet,\n        address _reserveWallet,\n        address[] _usdTokens\n    ) internal {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',14);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',255);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',18);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',38);\nrequire(_wallet != address(0) && _reserveWallet != address(0), \"Invalid wallet\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',18);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',256);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',39);\nwallet = _wallet;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',257);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',40);\nreserveWallet = _reserveWallet;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',258);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',41);\n_modifyUSDTokens(_usdTokens);\n    }\n\n    function _modifyUSDTokens(address[] _usdTokens) internal {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',15);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',262);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',42);\nfor(uint256 i = 0; i < usdTokens.length; i++) {\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',263);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',43);\nusdTokenEnabled[usdTokens[i]] = false;\n        }\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',265);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',44);\nusdTokens = _usdTokens;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',266);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',45);\nfor(i = 0; i < _usdTokens.length; i++) {\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',267);\n            emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',19);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',46);\nrequire(_usdTokens[i] != address(0), \"Invalid USD token\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',19);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',268);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',47);\nusdTokenEnabled[_usdTokens[i]] = true;\n        }\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',270);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',48);\nemit SetAddresses(wallet, reserveWallet, _usdTokens);\n    }\n\n    ////////////////////\n    // STO Management //\n    ////////////////////\n\n    /**\n     * @notice Finalizes the STO and mint remaining tokens to reserve address\n     * @notice Reserve address must be whitelisted to successfully finalize\n     */\n    function finalize() public onlyOwner {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',16);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',282);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',20);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',49);\nrequire(!isFinalized, \"STO is already finalized\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',20);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',283);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',50);\nisFinalized = true;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',284);\n        uint256 tempReturned;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',285);\n        uint256 tempSold;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',286);\n        uint256 remainingTokens;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',287);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',51);\nfor (uint256 i = 0; i < tiers.length; i++) {\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',288);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',52);\nremainingTokens = tiers[i].tokenTotal.sub(tiers[i].mintedTotal);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',289);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',53);\ntempReturned = tempReturned.add(remainingTokens);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',290);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',54);\ntempSold = tempSold.add(tiers[i].mintedTotal);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',291);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',55);\nif (remainingTokens > 0) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',21,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',292);\n                emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',56);\ntiers[i].mintedTotal = tiers[i].tokenTotal;\n            }else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',21,1);}\n\n        }\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',295);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',22);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',57);\nrequire(ISecurityToken(securityToken).mint(reserveWallet, tempReturned), \"Error in minting\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',22);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',296);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',58);\nemit ReserveTokenMint(msg.sender, reserveWallet, tempReturned, currentTier);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',297);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',59);\nfinalAmountReturned = tempReturned;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',298);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',60);\ntotalTokensSold = tempSold;\n    }\n\n    /**\n     * @notice Modifies the list of accredited addresses\n     * @param _investors Array of investor addresses to modify\n     * @param _accredited Array of bools specifying accreditation status\n     */\n    function changeAccredited(address[] _investors, bool[] _accredited) public onlyOwner {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',17);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',307);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',23);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',61);\nrequire(_investors.length == _accredited.length, \"Array length mismatch\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',23);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',308);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',62);\nfor (uint256 i = 0; i < _investors.length; i++) {\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',309);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',63);\naccredited[_investors[i]] = _accredited[i];\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',310);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',64);\nemit SetAccredited(_investors[i], _accredited[i]);\n        }\n    }\n\n    /**\n     * @notice Modifies the list of overrides for non-accredited limits in USD\n     * @param _investors Array of investor addresses to modify\n     * @param _nonAccreditedLimit Array of uints specifying non-accredited limits\n     */\n    function changeNonAccreditedLimit(address[] _investors, uint256[] _nonAccreditedLimit) public onlyOwner {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',18);\n\n        //nonAccreditedLimitUSDOverride\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',321);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',24);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',65);\nrequire(_investors.length == _nonAccreditedLimit.length, \"Array length mismatch\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',24);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',322);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',66);\nfor (uint256 i = 0; i < _investors.length; i++) {\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',323);\n            emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',25);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',67);\nrequire(_nonAccreditedLimit[i] > 0, \"Limit = 0\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',25);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',324);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',68);\nnonAccreditedLimitUSDOverride[_investors[i]] = _nonAccreditedLimit[i];\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',325);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',69);\nemit SetNonAccreditedLimit(_investors[i], _nonAccreditedLimit[i]);\n        }\n    }\n\n    /**\n     * @notice Function to set allowBeneficialInvestments (allow beneficiary to be different to funder)\n     * @param _allowBeneficialInvestments Boolean to allow or disallow beneficial investments\n     */\n    function changeAllowBeneficialInvestments(bool _allowBeneficialInvestments) public onlyOwner {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',19);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',334);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',26);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',70);\nrequire(_allowBeneficialInvestments != allowBeneficialInvestments, \"Value unchanged\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',26);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',335);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',71);\nallowBeneficialInvestments = _allowBeneficialInvestments;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',336);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',72);\nemit SetAllowBeneficialInvestments(allowBeneficialInvestments);\n    }\n\n    //////////////////////////\n    // Investment Functions //\n    //////////////////////////\n\n    /**\n    * @notice fallback function - assumes ETH being invested\n    */\n    function () external payable {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',20);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',347);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',73);\nbuyWithETHRateLimited(msg.sender, 0);\n    }\n\n    // Buy functions without rate restriction\n    function buyWithETH(address _beneficiary) external payable {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',21);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',352);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',74);\nbuyWithETHRateLimited(_beneficiary, 0);\n    }\n\n    function buyWithPOLY(address _beneficiary, uint256 _investedPOLY) external {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',22);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',356);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',75);\nbuyWithPOLYRateLimited(_beneficiary, _investedPOLY, 0);\n    }\n\n    function buyWithUSD(address _beneficiary, uint256 _investedSC, IERC20 _usdToken) external {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',23);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',360);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',76);\nbuyWithUSDRateLimited(_beneficiary, _investedSC, 0, _usdToken);\n    }\n\n    /**\n      * @notice Purchase tokens using ETH\n      * @param _beneficiary Address where security tokens will be sent\n      * @param _minTokens Minumum number of tokens to buy or else revert\n      */\n    function buyWithETHRateLimited(address _beneficiary, uint256 _minTokens) public payable validETH {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',24);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',369);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',77);\nuint256 rate = getRate(FundRaiseType.ETH);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',370);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',78);\nuint256 initialMinted = getTokensMinted();\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',371);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',79);\n(uint256 spentUSD, uint256 spentValue) = _buyTokens(_beneficiary, msg.value, rate, FundRaiseType.ETH);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',372);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',27);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',80);\nrequire(getTokensMinted().sub(initialMinted) >= _minTokens, \"Insufficient tokens minted\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',27);\n\n        // Modify storage\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',374);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',81);\ninvestorInvested[_beneficiary][uint8(FundRaiseType.ETH)] = investorInvested[_beneficiary][uint8(FundRaiseType.ETH)].add(spentValue);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',375);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',82);\nfundsRaised[uint8(FundRaiseType.ETH)] = fundsRaised[uint8(FundRaiseType.ETH)].add(spentValue);\n        // Forward ETH to issuer wallet\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',377);\n        wallet.transfer(spentValue);\n        // Refund excess ETH to investor wallet\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',379);\n        msg.sender.transfer(msg.value.sub(spentValue));\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',380);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',83);\nemit FundsReceived(msg.sender, _beneficiary, spentUSD, FundRaiseType.ETH, msg.value, spentValue, rate);\n    }\n\n    /**\n      * @notice Purchase tokens using POLY\n      * @param _beneficiary Address where security tokens will be sent\n      * @param _investedPOLY Amount of POLY invested\n      * @param _minTokens Minumum number of tokens to buy or else revert\n      */\n    function buyWithPOLYRateLimited(address _beneficiary, uint256 _investedPOLY, uint256 _minTokens) public validPOLY {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',25);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',390);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',84);\n_buyWithTokens(_beneficiary, _investedPOLY, FundRaiseType.POLY, _minTokens, polyToken);\n    }\n\n    /**\n      * @notice Purchase tokens using Stable coins\n      * @param _beneficiary Address where security tokens will be sent\n      * @param _investedSC Amount of Stable coins invested\n      * @param _minTokens Minumum number of tokens to buy or else revert\n      * @param _usdToken Address of USD stable coin to buy tokens with\n      */\n    function buyWithUSDRateLimited(address _beneficiary, uint256 _investedSC, uint256 _minTokens, IERC20 _usdToken)\n        public validSC(_usdToken)\n    {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',26);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',403);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',85);\n_buyWithTokens(_beneficiary, _investedSC, FundRaiseType.SC, _minTokens, _usdToken);\n    }\n\n    function _buyWithTokens(address _beneficiary, uint256 _tokenAmount, FundRaiseType _fundRaiseType, uint256 _minTokens, IERC20 _token) internal {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',27);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',407);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',28);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',86);\nrequire(_fundRaiseType == FundRaiseType.POLY || _fundRaiseType == FundRaiseType.SC, \"Invalid raise type\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',28);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',408);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',87);\nuint256 initialMinted = getTokensMinted();\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',409);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',88);\nuint256 rate = getRate(_fundRaiseType);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',410);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',89);\n(uint256 spentUSD, uint256 spentValue) = _buyTokens(_beneficiary, _tokenAmount, rate, _fundRaiseType);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',411);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',29);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',90);\nrequire(getTokensMinted().sub(initialMinted) >= _minTokens, \"Insufficient tokens minted\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',29);\n\n        // Modify storage\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',413);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',91);\ninvestorInvested[_beneficiary][uint8(_fundRaiseType)] = investorInvested[_beneficiary][uint8(_fundRaiseType)].add(spentValue);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',414);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',92);\nfundsRaised[uint8(_fundRaiseType)] = fundsRaised[uint8(_fundRaiseType)].add(spentValue);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',415);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',93);\nif(address(_token) != address(polyToken))\n            {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',94);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',30,0);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',416);\nstableCoinsRaised[address(_token)] = stableCoinsRaised[address(_token)].add(spentValue);}else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',30,1);}\n\n        // Forward coins to issuer wallet\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',418);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',31);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',95);\nrequire(_token.transferFrom(msg.sender, wallet, spentValue), \"Transfer failed\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',31);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',419);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',96);\nemit FundsReceived(msg.sender, _beneficiary, spentUSD, _fundRaiseType, _tokenAmount, spentValue, rate);\n    }\n\n    /**\n      * @notice Low level token purchase\n      * @param _beneficiary Address where security tokens will be sent\n      * @param _investmentValue Amount of POLY, ETH or Stable coins invested\n      * @param _fundRaiseType Fund raise type (POLY, ETH, SC)\n      */\n    function _buyTokens(\n        address _beneficiary,\n        uint256 _investmentValue,\n        uint256 _rate,\n        FundRaiseType _fundRaiseType\n    )\n        internal\n        nonReentrant\n        whenNotPaused\n        returns(uint256 spentUSD, uint256 spentValue)\n    {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',28);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',439);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',97);\nif (!allowBeneficialInvestments) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',32,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',440);\n            emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',33);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',98);\nrequire(_beneficiary == msg.sender, \"Beneficiary != funder\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',33);\n\n        }else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',32,1);}\n\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',443);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',99);\nuint256 originalUSD = DecimalMath.mul(_rate, _investmentValue);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',444);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',100);\nuint256 allowedUSD = _buyTokensChecks(_beneficiary, _investmentValue, originalUSD);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',446);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',101);\nfor (uint256 i = currentTier; i < tiers.length; i++) {\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',447);\n            bool gotoNextTier;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',448);\n            uint256 tempSpentUSD;\n            // Update current tier if needed\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',450);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',102);\nif (currentTier != i)\n                {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',103);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',34,0);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',451);\ncurrentTier = i;}else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',34,1);}\n\n            // If there are tokens remaining, process investment\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',453);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',104);\nif (tiers[i].mintedTotal < tiers[i].tokenTotal) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',35,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',454);\n                emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',105);\n(tempSpentUSD, gotoNextTier) = _calculateTier(_beneficiary, i, allowedUSD.sub(spentUSD), _fundRaiseType);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',455);\n                emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',106);\nspentUSD = spentUSD.add(tempSpentUSD);\n                // If all funds have been spent, exit the loop\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',457);\n                emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',107);\nif (!gotoNextTier)\n                    {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',36,0);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',458);\nbreak;}else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',36,1);}\n\n            }else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',35,1);}\n\n        }\n\n        // Modify storage\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',463);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',108);\nif (spentUSD > 0) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',37,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',464);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',109);\nif (investorInvestedUSD[_beneficiary] == 0)\n                {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',110);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',38,0);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',465);\ninvestorCount = investorCount + 1;}else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',38,1);}\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',466);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',111);\ninvestorInvestedUSD[_beneficiary] = investorInvestedUSD[_beneficiary].add(spentUSD);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',467);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',112);\nfundsRaisedUSD = fundsRaisedUSD.add(spentUSD);\n        }else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',37,1);}\n\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',470);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',113);\nspentValue = DecimalMath.div(spentUSD, _rate);\n    }\n\n    /**\n      * @notice Getter function for buyer to calculate how many tokens will they get\n      * @param _beneficiary Address where security tokens are to be sent\n      * @param _investmentValue Amount of POLY, ETH or Stable coins invested\n      * @param _fundRaiseType Fund raise type (POLY, ETH, SC)\n      */\n    function buyTokensView(\n        address _beneficiary,\n        uint256 _investmentValue,\n        FundRaiseType _fundRaiseType\n    )\n        public\n        \n        returns(uint256 spentUSD, uint256 spentValue, uint256 tokensMinted)\n    {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',29);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',488);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',39);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',114);\nrequire(_fundRaiseType == FundRaiseType.POLY || _fundRaiseType == FundRaiseType.SC || _fundRaiseType == FundRaiseType.ETH, \"Invalid raise type\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',39);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',489);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',115);\nuint256 rate = getRate(_fundRaiseType);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',490);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',116);\nuint256 originalUSD = DecimalMath.mul(rate, _investmentValue);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',491);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',117);\nuint256 allowedUSD = _buyTokensChecks(_beneficiary, _investmentValue, originalUSD);\n\n        // Iterate over each tier and process payment\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',494);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',118);\nfor (uint256 i = currentTier; i < tiers.length; i++) {\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',495);\n            bool gotoNextTier;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',496);\n            uint256 tempSpentUSD;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',497);\n            uint256 tempTokensMinted;\n            // If there are tokens remaining, process investment\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',499);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',119);\nif (tiers[i].mintedTotal < tiers[i].tokenTotal) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',40,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',500);\n                emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',120);\n(tempSpentUSD, gotoNextTier, tempTokensMinted) = _calculateTierView(i, allowedUSD.sub(spentUSD), _fundRaiseType);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',501);\n                emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',121);\nspentUSD = spentUSD.add(tempSpentUSD);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',502);\n                emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',122);\ntokensMinted = tokensMinted.add(tempTokensMinted);\n                // If all funds have been spent, exit the loop\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',504);\n                emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',123);\nif (!gotoNextTier)\n                    {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',41,0);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',505);\nbreak;}else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',41,1);}\n\n            }else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',40,1);}\n\n        }\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',509);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',124);\nspentValue = DecimalMath.div(spentUSD, rate);\n    }\n\n    function _buyTokensChecks(\n        address _beneficiary,\n        uint256 _investmentValue,\n        uint256 investedUSD\n    )\n        internal\n        \n        returns(uint256 netInvestedUSD)\n    {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',30);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',521);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',42);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',125);\nrequire(isOpen(), \"STO not open\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',42);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',522);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',43);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',126);\nrequire(_investmentValue > 0, \"No funds were sent\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',43);\n\n\n        // Check for minimum investment\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',525);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',44);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',127);\nrequire(investedUSD.add(investorInvestedUSD[_beneficiary]) >= minimumInvestmentUSD, \"Total investment < minimumInvestmentUSD\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',44);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',526);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',128);\nnetInvestedUSD = investedUSD;\n        // Check for non-accredited cap\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',528);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',129);\nif (!accredited[_beneficiary]) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',45,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',529);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',130);\nuint256 investorLimitUSD = (nonAccreditedLimitUSDOverride[_beneficiary] == 0) ? nonAccreditedLimitUSD : nonAccreditedLimitUSDOverride[_beneficiary];\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',530);\n            emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',46);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',131);\nrequire(investorInvestedUSD[_beneficiary] < investorLimitUSD, \"Over Non-accredited investor limit\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',46);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',531);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',132);\nif (investedUSD.add(investorInvestedUSD[_beneficiary]) > investorLimitUSD)\n                {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',133);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',47,0);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',532);\nnetInvestedUSD = investorLimitUSD.sub(investorInvestedUSD[_beneficiary]);}else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',47,1);}\n\n        }else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',45,1);}\n\n    }\n\n    function _calculateTier(\n        address _beneficiary,\n        uint256 _tier,\n        uint256 _investedUSD,\n        FundRaiseType _fundRaiseType\n    )\n        internal\n        returns(uint256 spentUSD, bool gotoNextTier)\n     {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',31);\n\n        // First purchase any discounted tokens if POLY investment\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',546);\n        uint256 tierSpentUSD;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',547);\n        uint256 tierPurchasedTokens;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',548);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',134);\nuint256 investedUSD = _investedUSD;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',549);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',135);\nTier storage tierData = tiers[_tier];\n        // Check whether there are any remaining discounted tokens\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',551);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',136);\nif ((_fundRaiseType == FundRaiseType.POLY) && (tierData.tokensDiscountPoly > tierData.mintedDiscountPoly)) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',48,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',552);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',137);\nuint256 discountRemaining = tierData.tokensDiscountPoly.sub(tierData.mintedDiscountPoly);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',553);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',138);\nuint256 totalRemaining = tierData.tokenTotal.sub(tierData.mintedTotal);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',554);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',139);\nif (totalRemaining < discountRemaining)\n                {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',140);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',49,0);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',555);\n(spentUSD, tierPurchasedTokens, gotoNextTier) = _purchaseTier(_beneficiary, tierData.rateDiscountPoly, totalRemaining, investedUSD, _tier);}\n            else\n                {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',141);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',49,1);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',557);\n(spentUSD, tierPurchasedTokens, gotoNextTier) = _purchaseTier(_beneficiary, tierData.rateDiscountPoly, discountRemaining, investedUSD, _tier);}\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',558);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',142);\ninvestedUSD = investedUSD.sub(spentUSD);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',559);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',143);\ntierData.mintedDiscountPoly = tierData.mintedDiscountPoly.add(tierPurchasedTokens);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',560);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',144);\ntierData.minted[uint8(_fundRaiseType)] = tierData.minted[uint8(_fundRaiseType)].add(tierPurchasedTokens);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',561);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',145);\ntierData.mintedTotal = tierData.mintedTotal.add(tierPurchasedTokens);\n        }else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',48,1);}\n\n        // Now, if there is any remaining USD to be invested, purchase at non-discounted rate\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',564);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',146);\nif (investedUSD > 0 &&\n            tierData.tokenTotal.sub(tierData.mintedTotal) > 0 &&\n            (_fundRaiseType != FundRaiseType.POLY || tierData.tokensDiscountPoly <= tierData.mintedDiscountPoly)\n        ) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',50,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',568);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',147);\n(tierSpentUSD, tierPurchasedTokens, gotoNextTier) = _purchaseTier(_beneficiary, tierData.rate, tierData.tokenTotal.sub(tierData.mintedTotal), investedUSD, _tier);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',569);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',148);\nspentUSD = spentUSD.add(tierSpentUSD);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',570);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',149);\ntierData.minted[uint8(_fundRaiseType)] = tierData.minted[uint8(_fundRaiseType)].add(tierPurchasedTokens);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',571);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',150);\ntierData.mintedTotal = tierData.mintedTotal.add(tierPurchasedTokens);\n        }else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',50,1);}\n\n    }\n\n    function _calculateTierView(\n        uint256 _tier,\n        uint256 _investedUSD,\n        FundRaiseType _fundRaiseType\n    )\n        internal\n        \n        returns(uint256 spentUSD, bool gotoNextTier, uint256 tokensMinted)\n    {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',32);\n\n        // First purchase any discounted tokens if POLY investment\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',585);\n        uint256 tierSpentUSD;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',586);\n        uint256 tierPurchasedTokens;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',587);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',151);\nTier storage tierData = tiers[_tier];\n        // Check whether there are any remaining discounted tokens\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',589);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',152);\nif ((_fundRaiseType == FundRaiseType.POLY) && (tierData.tokensDiscountPoly > tierData.mintedDiscountPoly)) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',51,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',590);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',153);\nuint256 discountRemaining = tierData.tokensDiscountPoly.sub(tierData.mintedDiscountPoly);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',591);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',154);\nuint256 totalRemaining = tierData.tokenTotal.sub(tierData.mintedTotal);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',592);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',155);\nif (totalRemaining < discountRemaining)\n                {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',156);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',52,0);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',593);\n(spentUSD, tokensMinted, gotoNextTier) = _purchaseTierAmount(tierData.rateDiscountPoly, totalRemaining, _investedUSD);}\n            else\n                {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',157);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',52,1);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',595);\n(spentUSD, tokensMinted, gotoNextTier) = _purchaseTierAmount(tierData.rateDiscountPoly, discountRemaining, _investedUSD);}\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',596);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',158);\n_investedUSD = _investedUSD.sub(spentUSD);\n        }else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',51,1);}\n\n        // Now, if there is any remaining USD to be invested, purchase at non-discounted rate\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',599);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',159);\nif (_investedUSD > 0 &&\n            tierData.tokenTotal.sub(tierData.mintedTotal.add(tokensMinted)) > 0 &&\n            (_fundRaiseType != FundRaiseType.POLY || tierData.tokensDiscountPoly <= tierData.mintedDiscountPoly)\n        ) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',53,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',603);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',160);\n(tierSpentUSD, tierPurchasedTokens, gotoNextTier) = _purchaseTierAmount(tierData.rate, tierData.tokenTotal.sub(tierData.mintedTotal), _investedUSD);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',604);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',161);\nspentUSD = spentUSD.add(tierSpentUSD);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',605);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',162);\ntokensMinted = tokensMinted.add(tierPurchasedTokens);\n        }else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',53,1);}\n\n    }\n\n    function _purchaseTier(\n        address _beneficiary,\n        uint256 _tierPrice,\n        uint256 _tierRemaining,\n        uint256 _investedUSD,\n        uint256 _tier\n    )\n        internal\n        returns(uint256 spentUSD, uint256 purchasedTokens, bool gotoNextTier)\n    {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',33);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',619);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',163);\n(spentUSD, purchasedTokens, gotoNextTier) = _purchaseTierAmount(_tierPrice, _tierRemaining, _investedUSD);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',620);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',164);\nif (purchasedTokens > 0) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',54,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',621);\n            emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',55);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',165);\nrequire(ISecurityToken(securityToken).mint(_beneficiary, purchasedTokens), \"Error in minting\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',55);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',622);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',166);\nemit TokenPurchase(msg.sender, _beneficiary, purchasedTokens, spentUSD, _tierPrice, _tier);\n        }else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',54,1);}\n\n    }\n\n    function _purchaseTierAmount(\n        uint256 _tierPrice,\n        uint256 _tierRemaining,\n        uint256 _investedUSD\n    )\n        internal\n        \n        returns(uint256 spentUSD, uint256 purchasedTokens, bool gotoNextTier)\n    {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',34);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',635);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',167);\nuint256 maximumTokens = DecimalMath.div(_investedUSD, _tierPrice);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',636);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',168);\nuint256 granularity = ISecurityToken(securityToken).granularity();\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',637);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',169);\nmaximumTokens = maximumTokens.div(granularity);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',638);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',170);\nmaximumTokens = maximumTokens.mul(granularity);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',639);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',171);\nif (maximumTokens > _tierRemaining) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',56,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',640);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',172);\nspentUSD = DecimalMath.mul(_tierRemaining, _tierPrice);\n            // In case of rounding issues, ensure that spentUSD is never more than investedUSD\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',642);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',173);\nif (spentUSD > _investedUSD) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',57,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',643);\n                emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',174);\nspentUSD = _investedUSD;\n            }else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',57,1);}\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',645);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',175);\npurchasedTokens = _tierRemaining;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',646);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',176);\ngotoNextTier = true;\n        } else {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',56,1);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',648);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',177);\nspentUSD = DecimalMath.mul(maximumTokens, _tierPrice);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',649);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',178);\npurchasedTokens = maximumTokens;\n        }\n    }\n\n    /////////////\n    // Getters //\n    /////////////\n\n    /**\n     * @notice This function returns whether or not the STO is in fundraising mode (open)\n     * @return bool Whether the STO is accepting investments\n     */\n    function isOpen() public  returns(bool) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',35);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',662);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',179);\nif (isFinalized)\n            {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',180);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',58,0);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',663);\nreturn false;}else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',58,1);}\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',665);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',181);\nif (now < startTime)\n            {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',182);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',59,0);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',666);\nreturn false;}else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',59,1);}\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',668);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',183);\nif (now >= endTime)\n            {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',184);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',60,0);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',669);\nreturn false;}else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',60,1);}\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',670);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',185);\nif (capReached())\n            {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',186);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',61,0);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',671);\nreturn false;}else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',61,1);}\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',672);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',187);\nreturn true;\n    }\n\n    /**\n     * @notice Checks whether the cap has been reached.\n     * @return bool Whether the cap was reached\n     */\n    function capReached() public  returns (bool) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',36);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',680);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',188);\nif (isFinalized) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',62,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',681);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',189);\nreturn (finalAmountReturned == 0);\n        }else { emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',62,1);}\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',683);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',190);\nreturn (tiers[tiers.length - 1].mintedTotal == tiers[tiers.length - 1].tokenTotal);\n    }\n\n    /**\n     * @dev returns current conversion rate of funds\n     * @param _fundRaiseType Fund raise type to get rate of\n     */\n    function getRate(FundRaiseType _fundRaiseType) public  returns (uint256) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',37);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',691);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',191);\nif (_fundRaiseType == FundRaiseType.ETH) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',63,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',692);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',192);\nreturn IOracle(_getOracle(bytes32(\"ETH\"), bytes32(\"USD\"))).getPrice();\n        } else {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',193);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',63,1);if (_fundRaiseType == FundRaiseType.POLY) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',64,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',694);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',194);\nreturn IOracle(_getOracle(bytes32(\"POLY\"), bytes32(\"USD\"))).getPrice();\n        } else {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',195);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',64,1);if (_fundRaiseType == FundRaiseType.SC) {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',65,0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',696);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',196);\nreturn 1 * 10**18;\n        } else {emit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',65,1);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',698);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',197);\nrevert(\"Incorrect funding\");\n        }}}\n    }\n\n    /**\n     * @notice This function converts from ETH or POLY to USD\n     * @param _fundRaiseType Currency key\n     * @param _amount Value to convert to USD\n     * @return uint256 Value in USD\n     */\n    function convertToUSD(FundRaiseType _fundRaiseType, uint256 _amount) public  returns(uint256) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',38);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',709);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',198);\nuint256 rate = getRate(_fundRaiseType);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',710);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',199);\nreturn DecimalMath.mul(_amount, rate);\n    }\n\n    /**\n     * @notice This function converts from USD to ETH or POLY\n     * @param _fundRaiseType Currency key\n     * @param _amount Value to convert from USD\n     * @return uint256 Value in ETH or POLY\n     */\n    function convertFromUSD(FundRaiseType _fundRaiseType, uint256 _amount) public  returns(uint256) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',39);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',720);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',200);\nuint256 rate = getRate(_fundRaiseType);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',721);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',201);\nreturn DecimalMath.div(_amount, rate);\n    }\n\n    /**\n     * @notice Return the total no. of tokens sold\n     * @return uint256 Total number of tokens sold\n     */\n    function getTokensSold() public  returns (uint256) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',40);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',729);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',202);\nif (isFinalized)\n            {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',203);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',66,0);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',730);\nreturn totalTokensSold;}\n        else\n            {emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',204);\nemit __BranchCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',66,1);emit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',732);\nreturn getTokensMinted();}\n    }\n\n    /**\n     * @notice Return the total no. of tokens minted\n     * @return uint256 Total number of tokens minted\n     */\n    function getTokensMinted() public  returns (uint256) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',41);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',740);\n        uint256 tokensMinted;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',741);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',205);\nfor (uint256 i = 0; i < tiers.length; i++) {\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',742);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',206);\ntokensMinted = tokensMinted.add(tiers[i].mintedTotal);\n        }\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',744);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',207);\nreturn tokensMinted;\n    }\n\n    /**\n     * @notice Return the total no. of tokens sold for the given fund raise type\n     * param _fundRaiseType The fund raising currency (e.g. ETH, POLY, SC) to calculate sold tokens for\n     * @return uint256 Total number of tokens sold for ETH\n     */\n    function getTokensSoldFor(FundRaiseType _fundRaiseType) public  returns (uint256) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',42);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',753);\n        uint256 tokensSold;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',754);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',208);\nfor (uint256 i = 0; i < tiers.length; i++) {\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',755);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',209);\ntokensSold = tokensSold.add(tiers[i].minted[uint8(_fundRaiseType)]);\n        }\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',757);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',210);\nreturn tokensSold;\n    }\n\n    /**\n     * @notice Return array of minted tokens in each fund raise type for given tier\n     * param _tier The tier to return minted tokens for\n     * @return uint256[] array of minted tokens in each fund raise type\n     */\n    function getTokensMintedByTier(uint256 _tier) public  returns (uint256[]) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',43);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',766);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',67);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',211);\nrequire(_tier < tiers.length, \"Invalid tier\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',67);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',767);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',212);\nuint256[] memory tokensMinted = new uint256[](3);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',768);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',213);\ntokensMinted[0] = tiers[_tier].minted[uint8(FundRaiseType.ETH)];\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',769);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',214);\ntokensMinted[1] = tiers[_tier].minted[uint8(FundRaiseType.POLY)];\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',770);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',215);\ntokensMinted[2] = tiers[_tier].minted[uint8(FundRaiseType.SC)];\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',771);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',216);\nreturn tokensMinted;\n    }\n\n    /**\n     * @notice Return the total no. of tokens sold in a given tier\n     * param _tier The tier to calculate sold tokens for\n     * @return uint256 Total number of tokens sold in the tier\n     */\n    function getTokensSoldByTier(uint256 _tier) public  returns (uint256) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',44);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',780);\n        emit __AssertPreCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',68);\nemit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',217);\nrequire(_tier < tiers.length, \"Incorrect tier\");emit __AssertPostCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',68);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',781);\n        uint256 tokensSold;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',782);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',218);\ntokensSold = tokensSold.add(tiers[_tier].minted[uint8(FundRaiseType.ETH)]);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',783);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',219);\ntokensSold = tokensSold.add(tiers[_tier].minted[uint8(FundRaiseType.POLY)]);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',784);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',220);\ntokensSold = tokensSold.add(tiers[_tier].minted[uint8(FundRaiseType.SC)]);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',785);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',221);\nreturn tokensSold;\n    }\n\n    /**\n     * @notice Return the total no. of tiers\n     * @return uint256 Total number of tiers\n     */\n    function getNumberOfTiers() public  returns (uint256) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',45);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',793);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',222);\nreturn tiers.length;\n    }\n\n    /**\n     * @notice Return the usd tokens accepted by the STO\n     * @return address[] usd tokens\n     */\n    function getUsdTokens() public  returns (address[]) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',46);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',801);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',223);\nreturn usdTokens;\n    }\n\n    /**\n     * @notice Return the permissions flag that are associated with STO\n     */\n    function getPermissions() public  returns(bytes32[]) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',47);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',808);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',224);\nbytes32[] memory allPermissions = new bytes32[](0);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',809);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',225);\nreturn allPermissions;\n    }\n\n    /**\n     * @notice Return the STO details\n     * @return Unixtimestamp at which offering gets start.\n     * @return Unixtimestamp at which offering ends.\n     * @return Currently active tier\n     * @return Array of Number of tokens this STO will be allowed to sell at different tiers.\n     * @return Array Rate at which tokens are sold at different tiers\n     * @return Amount of funds raised\n     * @return Number of individual investors this STO have.\n     * @return Amount of tokens sold.\n     * @return Array of bools to show if funding is allowed in ETH, POLY, SC respectively\n     */\n    function getSTODetails() public  returns(uint256, uint256, uint256, uint256[], uint256[], uint256, uint256, uint256, bool[]) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',48);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',825);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',226);\nuint256[] memory cap = new uint256[](tiers.length);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',826);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',227);\nuint256[] memory rate = new uint256[](tiers.length);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',827);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',228);\nfor(uint256 i = 0; i < tiers.length; i++) {\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',828);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',229);\ncap[i] = tiers[i].tokenTotal;\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',829);\n            emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',230);\nrate[i] = tiers[i].rate;\n        }\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',831);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',231);\nbool[] memory _fundRaiseTypes = new bool[](3);\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',832);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',232);\n_fundRaiseTypes[0] = fundRaiseTypes[uint8(FundRaiseType.ETH)];\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',833);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',233);\n_fundRaiseTypes[1] = fundRaiseTypes[uint8(FundRaiseType.POLY)];\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',834);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',234);\n_fundRaiseTypes[2] = fundRaiseTypes[uint8(FundRaiseType.SC)];\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',835);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',235);\nreturn (\n            startTime,\n            endTime,\n            currentTier,\n            cap,\n            rate,\n            fundsRaisedUSD,\n            investorCount,\n            getTokensSold(),\n            _fundRaiseTypes\n        );\n    }\n\n    /**\n     * @notice This function returns the signature of configure function\n     * @return bytes4 Configure function signature\n     */\n    function getInitFunction() public  returns (bytes4) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',49);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',853);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',236);\nreturn 0xeac2f9e4;\n    }\n\n    function _getOracle(bytes32 _currency, bytes32 _denominatedCurrency) internal  returns (address) {emit __FunctionCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',50);\n\nemit __CoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',857);\n        emit __StatementCoverageUSDTieredSTO('./contracts/modules/STO/USDTieredSTO.sol',237);\nreturn PolymathRegistry(RegistryUpdater(securityToken).polymathRegistry()).getAddress(oracleKeys[_currency][_denominatedCurrency]);\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/interfaces/IOracle.sol":{"content":"pragma solidity ^0.4.24;\n\ninterface IOracle {event __CoverageIOracle(string fileName, uint256 lineNumber);\nevent __FunctionCoverageIOracle(string fileName, uint256 fnId);\nevent __StatementCoverageIOracle(string fileName, uint256 statementId);\nevent __BranchCoverageIOracle(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageIOracle(string fileName, uint256 branchId);\nevent __AssertPostCoverageIOracle(string fileName, uint256 branchId);\n\n\n    /**\n    * @notice Returns address of oracle currency (0x0 for ETH)\n    */\n    function getCurrencyAddress() external  returns(address);\n\n    /**\n    * @notice Returns symbol of oracle currency (0x0 for ETH)\n    */\n    function getCurrencySymbol() external  returns(bytes32);\n\n    /**\n    * @notice Returns denomination of price\n    */\n    function getCurrencyDenominated() external  returns(bytes32);\n\n    /**\n    * @notice Returns price - should throw if not valid\n    */\n    function getPrice() external  returns(uint256);\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/RegistryUpdater.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./PolymathRegistry.sol\";\n\ncontract RegistryUpdater is Ownable {event __CoverageRegistryUpdater(string fileName, uint256 lineNumber);\nevent __FunctionCoverageRegistryUpdater(string fileName, uint256 fnId);\nevent __StatementCoverageRegistryUpdater(string fileName, uint256 statementId);\nevent __BranchCoverageRegistryUpdater(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageRegistryUpdater(string fileName, uint256 branchId);\nevent __AssertPostCoverageRegistryUpdater(string fileName, uint256 branchId);\n\n\n    address public polymathRegistry;\n    address public moduleRegistry;\n    address public securityTokenRegistry;\n    address public featureRegistry;\n    address public polyToken;\n\n    constructor (address _polymathRegistry) public {emit __FunctionCoverageRegistryUpdater('./contracts/RegistryUpdater.sol',1);\n\nemit __CoverageRegistryUpdater('./contracts/RegistryUpdater.sol',15);\n        emit __AssertPreCoverageRegistryUpdater('./contracts/RegistryUpdater.sol',1);\nemit __StatementCoverageRegistryUpdater('./contracts/RegistryUpdater.sol',1);\nrequire(_polymathRegistry != address(0), \"Invalid address\");emit __AssertPostCoverageRegistryUpdater('./contracts/RegistryUpdater.sol',1);\n\nemit __CoverageRegistryUpdater('./contracts/RegistryUpdater.sol',16);\n        emit __StatementCoverageRegistryUpdater('./contracts/RegistryUpdater.sol',2);\npolymathRegistry = _polymathRegistry;\n    }\n\n    function updateFromRegistry() public onlyOwner {emit __FunctionCoverageRegistryUpdater('./contracts/RegistryUpdater.sol',2);\n\nemit __CoverageRegistryUpdater('./contracts/RegistryUpdater.sol',20);\n        emit __StatementCoverageRegistryUpdater('./contracts/RegistryUpdater.sol',3);\nmoduleRegistry = PolymathRegistry(polymathRegistry).getAddress(\"ModuleRegistry\");\nemit __CoverageRegistryUpdater('./contracts/RegistryUpdater.sol',21);\n        emit __StatementCoverageRegistryUpdater('./contracts/RegistryUpdater.sol',4);\nsecurityTokenRegistry = PolymathRegistry(polymathRegistry).getAddress(\"SecurityTokenRegistry\");\nemit __CoverageRegistryUpdater('./contracts/RegistryUpdater.sol',22);\n        emit __StatementCoverageRegistryUpdater('./contracts/RegistryUpdater.sol',5);\nfeatureRegistry = PolymathRegistry(polymathRegistry).getAddress(\"FeatureRegistry\");\nemit __CoverageRegistryUpdater('./contracts/RegistryUpdater.sol',23);\n        emit __StatementCoverageRegistryUpdater('./contracts/RegistryUpdater.sol',6);\npolyToken = PolymathRegistry(polymathRegistry).getAddress(\"PolyToken\");\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/PolymathRegistry.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ReclaimTokens.sol\";\n\n/**\n * @title Core functionality for registry upgradability\n */\ncontract PolymathRegistry is ReclaimTokens {event __CoveragePolymathRegistry(string fileName, uint256 lineNumber);\nevent __FunctionCoveragePolymathRegistry(string fileName, uint256 fnId);\nevent __StatementCoveragePolymathRegistry(string fileName, uint256 statementId);\nevent __BranchCoveragePolymathRegistry(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoveragePolymathRegistry(string fileName, uint256 branchId);\nevent __AssertPostCoveragePolymathRegistry(string fileName, uint256 branchId);\n\n\n    mapping (bytes32 => address) public storedAddresses;\n\n    event ChangeAddress(string _nameKey, address indexed _oldAddress, address indexed _newAddress);\n\n    /**\n     * @notice Gets the contract address\n     * @param _nameKey is the key for the contract address mapping\n     * @return address\n     */\n    function getAddress(string _nameKey) external  returns(address) {emit __FunctionCoveragePolymathRegistry('./contracts/PolymathRegistry.sol',1);\n\nemit __CoveragePolymathRegistry('./contracts/PolymathRegistry.sol',20);\n        emit __StatementCoveragePolymathRegistry('./contracts/PolymathRegistry.sol',1);\nbytes32 key = keccak256(bytes(_nameKey));\nemit __CoveragePolymathRegistry('./contracts/PolymathRegistry.sol',21);\n        emit __AssertPreCoveragePolymathRegistry('./contracts/PolymathRegistry.sol',1);\nemit __StatementCoveragePolymathRegistry('./contracts/PolymathRegistry.sol',2);\nrequire(storedAddresses[key] != address(0), \"Invalid address key\");emit __AssertPostCoveragePolymathRegistry('./contracts/PolymathRegistry.sol',1);\n\nemit __CoveragePolymathRegistry('./contracts/PolymathRegistry.sol',22);\n        emit __StatementCoveragePolymathRegistry('./contracts/PolymathRegistry.sol',3);\nreturn storedAddresses[key];\n    }\n\n    /**\n     * @notice Changes the contract address\n     * @param _nameKey is the key for the contract address mapping\n     * @param _newAddress is the new contract address\n     */\n    function changeAddress(string _nameKey, address _newAddress) external onlyOwner {emit __FunctionCoveragePolymathRegistry('./contracts/PolymathRegistry.sol',2);\n\nemit __CoveragePolymathRegistry('./contracts/PolymathRegistry.sol',31);\n        emit __StatementCoveragePolymathRegistry('./contracts/PolymathRegistry.sol',4);\nbytes32 key = keccak256(bytes(_nameKey));\nemit __CoveragePolymathRegistry('./contracts/PolymathRegistry.sol',32);\n        emit __StatementCoveragePolymathRegistry('./contracts/PolymathRegistry.sol',5);\nemit ChangeAddress(_nameKey, storedAddresses[key], _newAddress);\nemit __CoveragePolymathRegistry('./contracts/PolymathRegistry.sol',33);\n        emit __StatementCoveragePolymathRegistry('./contracts/PolymathRegistry.sol',6);\nstoredAddresses[key] = _newAddress;\n    }\n\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/libraries/DecimalMath.sol":{"content":"pragma solidity  ^0.4.24;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nlibrary DecimalMath {event __CoverageDecimalMath(string fileName, uint256 lineNumber);\nevent __FunctionCoverageDecimalMath(string fileName, uint256 fnId);\nevent __StatementCoverageDecimalMath(string fileName, uint256 statementId);\nevent __BranchCoverageDecimalMath(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageDecimalMath(string fileName, uint256 branchId);\nevent __AssertPostCoverageDecimalMath(string fileName, uint256 branchId);\n\n\n    using SafeMath for uint256;\n\n     /**\n     * @notice This function multiplies two decimals represented as (decimal * 10**DECIMALS)\n     * @return uint256 Result of multiplication represented as (decimal * 10**DECIMALS)\n     */\n    function mul(uint256 x, uint256 y) internal  returns (uint256 z) {emit __FunctionCoverageDecimalMath('./contracts/libraries/DecimalMath.sol',1);\n\nemit __CoverageDecimalMath('./contracts/libraries/DecimalMath.sol',14);\n        emit __StatementCoverageDecimalMath('./contracts/libraries/DecimalMath.sol',1);\nz = SafeMath.add(SafeMath.mul(x, y), (10 ** 18) / 2) / (10 ** 18);\n    }\n\n    /**\n     * @notice This function divides two decimals represented as (decimal * 10**DECIMALS)\n     * @return uint256 Result of division represented as (decimal * 10**DECIMALS)\n     */\n    function div(uint256 x, uint256 y) internal  returns (uint256 z) {emit __FunctionCoverageDecimalMath('./contracts/libraries/DecimalMath.sol',2);\n\nemit __CoverageDecimalMath('./contracts/libraries/DecimalMath.sol',22);\n        emit __StatementCoverageDecimalMath('./contracts/libraries/DecimalMath.sol',2);\nz = SafeMath.add(SafeMath.mul(x, (10 ** 18)), y / 2) / y;\n    }\n\n}"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Module.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../interfaces/IModule.sol\";\nimport \"../interfaces/ISecurityToken.sol\";\nimport \"./ModuleStorage.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\n/**\n * @title Interface that any module contract should implement\n * @notice Contract is abstract\n */\ncontract Module is IModule, ModuleStorage {event __CoverageModule(string fileName, uint256 lineNumber);\nevent __FunctionCoverageModule(string fileName, uint256 fnId);\nevent __StatementCoverageModule(string fileName, uint256 statementId);\nevent __BranchCoverageModule(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageModule(string fileName, uint256 branchId);\nevent __AssertPostCoverageModule(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress) public\n    ModuleStorage(_securityToken, _polyAddress)\n    {emit __FunctionCoverageModule('./contracts/modules/Module.sol',1);\n\n    }\n\n    //Allows owner, factory or permissioned delegate\n    modifier withPerm(bytes32 _perm) {emit __FunctionCoverageModule('./contracts/modules/Module.sol',2);\n\nemit __CoverageModule('./contracts/modules/Module.sol',26);\n        emit __StatementCoverageModule('./contracts/modules/Module.sol',1);\nbool isOwner = msg.sender == Ownable(securityToken).owner();\nemit __CoverageModule('./contracts/modules/Module.sol',27);\n        emit __StatementCoverageModule('./contracts/modules/Module.sol',2);\nbool isFactory = msg.sender == factory;\nemit __CoverageModule('./contracts/modules/Module.sol',28);\n        emit __AssertPreCoverageModule('./contracts/modules/Module.sol',1);\nemit __StatementCoverageModule('./contracts/modules/Module.sol',3);\nrequire(isOwner||isFactory||ISecurityToken(securityToken).checkPermission(msg.sender, address(this), _perm), \"Permission check failed\");emit __AssertPostCoverageModule('./contracts/modules/Module.sol',1);\n\nemit __CoverageModule('./contracts/modules/Module.sol',29);\n        _;\n    }\n\n    modifier onlyOwner {emit __FunctionCoverageModule('./contracts/modules/Module.sol',3);\n\nemit __CoverageModule('./contracts/modules/Module.sol',33);\n        emit __AssertPreCoverageModule('./contracts/modules/Module.sol',2);\nemit __StatementCoverageModule('./contracts/modules/Module.sol',4);\nrequire(msg.sender == Ownable(securityToken).owner(), \"Sender is not owner\");emit __AssertPostCoverageModule('./contracts/modules/Module.sol',2);\n\nemit __CoverageModule('./contracts/modules/Module.sol',34);\n        _;\n    }\n\n    modifier onlyFactory {emit __FunctionCoverageModule('./contracts/modules/Module.sol',4);\n\nemit __CoverageModule('./contracts/modules/Module.sol',38);\n        emit __AssertPreCoverageModule('./contracts/modules/Module.sol',3);\nemit __StatementCoverageModule('./contracts/modules/Module.sol',5);\nrequire(msg.sender == factory, \"Sender is not factory\");emit __AssertPostCoverageModule('./contracts/modules/Module.sol',3);\n\nemit __CoverageModule('./contracts/modules/Module.sol',39);\n        _;\n    }\n\n    modifier onlyFactoryOwner {emit __FunctionCoverageModule('./contracts/modules/Module.sol',5);\n\nemit __CoverageModule('./contracts/modules/Module.sol',43);\n        emit __AssertPreCoverageModule('./contracts/modules/Module.sol',4);\nemit __StatementCoverageModule('./contracts/modules/Module.sol',6);\nrequire(msg.sender == Ownable(factory).owner(), \"Sender is not factory owner\");emit __AssertPostCoverageModule('./contracts/modules/Module.sol',4);\n\nemit __CoverageModule('./contracts/modules/Module.sol',44);\n        _;\n    }\n\n    modifier onlyFactoryOrOwner {emit __FunctionCoverageModule('./contracts/modules/Module.sol',6);\n\nemit __CoverageModule('./contracts/modules/Module.sol',48);\n        emit __AssertPreCoverageModule('./contracts/modules/Module.sol',5);\nemit __StatementCoverageModule('./contracts/modules/Module.sol',7);\nrequire((msg.sender == Ownable(securityToken).owner()) || (msg.sender == factory), \"Sender is not factory or owner\");emit __AssertPostCoverageModule('./contracts/modules/Module.sol',5);\n\nemit __CoverageModule('./contracts/modules/Module.sol',49);\n        _;\n    }\n\n    /**\n     * @notice used to withdraw the fee by the factory owner\n     */\n    function takeFee(uint256 _amount) public withPerm(FEE_ADMIN) returns(bool) {emit __FunctionCoverageModule('./contracts/modules/Module.sol',7);\n\nemit __CoverageModule('./contracts/modules/Module.sol',56);\n        emit __AssertPreCoverageModule('./contracts/modules/Module.sol',6);\nemit __StatementCoverageModule('./contracts/modules/Module.sol',8);\nrequire(polyToken.transferFrom(securityToken, Ownable(factory).owner(), _amount), \"Unable to take fee\");emit __AssertPostCoverageModule('./contracts/modules/Module.sol',6);\n\nemit __CoverageModule('./contracts/modules/Module.sol',57);\n        emit __StatementCoverageModule('./contracts/modules/Module.sol',9);\nreturn true;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/interfaces/IModule.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Interface that every module contract should implement\n */\ninterface IModule {event __CoverageIModule(string fileName, uint256 lineNumber);\nevent __FunctionCoverageIModule(string fileName, uint256 fnId);\nevent __StatementCoverageIModule(string fileName, uint256 statementId);\nevent __BranchCoverageIModule(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageIModule(string fileName, uint256 branchId);\nevent __AssertPostCoverageIModule(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() external  returns (bytes4);\n\n    /**\n     * @notice Return the permission flags that are associated with a module\n     */\n    function getPermissions() external  returns(bytes32[]);\n\n    /**\n     * @notice Used to withdraw the fee by the factory owner\n     */\n    function takeFee(uint256 _amount) external returns(bool);\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Wallet/IWallet.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../../Pausable.sol\";\nimport \"../Module.sol\";\n\n/**\n * @title Interface to be implemented by all Wallet modules\n * @dev abstract contract\n */\ncontract IWallet is Module, Pausable {event __CoverageIWallet(string fileName, uint256 lineNumber);\nevent __FunctionCoverageIWallet(string fileName, uint256 fnId);\nevent __StatementCoverageIWallet(string fileName, uint256 statementId);\nevent __BranchCoverageIWallet(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageIWallet(string fileName, uint256 branchId);\nevent __AssertPostCoverageIWallet(string fileName, uint256 branchId);\n\n\n    function unpause() public onlyOwner {emit __FunctionCoverageIWallet('./contracts/modules/Wallet/IWallet.sol',1);\n\nemit __CoverageIWallet('./contracts/modules/Wallet/IWallet.sol',13);\n        super._unpause();\n    }\n\n    function pause() public onlyOwner {emit __FunctionCoverageIWallet('./contracts/modules/Wallet/IWallet.sol',2);\n\nemit __CoverageIWallet('./contracts/modules/Wallet/IWallet.sol',17);\n        super._pause();\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Wallet/VestingEscrowWallet.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./VestingEscrowWalletStorage.sol\";\nimport \"./IWallet.sol\";\n\n/**\n * @title Wallet for core vesting escrow functionality\n */\ncontract VestingEscrowWallet is VestingEscrowWalletStorage, IWallet {event __CoverageVestingEscrowWallet(string fileName, uint256 lineNumber);\nevent __FunctionCoverageVestingEscrowWallet(string fileName, uint256 fnId);\nevent __StatementCoverageVestingEscrowWallet(string fileName, uint256 statementId);\nevent __BranchCoverageVestingEscrowWallet(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageVestingEscrowWallet(string fileName, uint256 branchId);\nevent __AssertPostCoverageVestingEscrowWallet(string fileName, uint256 branchId);\n\n    using SafeMath for uint256;\n\n    bytes32 public constant ADMIN = \"ADMIN\";\n\n    // States used to represent the status of the schedule\n    enum State {CREATED, STARTED, COMPLETED}\n\n    // Emit when new schedule is added\n    event AddSchedule(\n        address indexed _beneficiary,\n        bytes32 _templateName,\n        uint256 _startTime\n    );\n    // Emit when schedule is modified\n    event ModifySchedule(\n        address indexed _beneficiary,\n        bytes32 _templateName,\n        uint256 _startTime\n    );\n    // Emit when all schedules are revoked for user\n    event RevokeAllSchedules(address indexed _beneficiary);\n    // Emit when schedule is revoked\n    event RevokeSchedule(address indexed _beneficiary, bytes32 _templateName);\n    // Emit when tokes are deposited to wallet\n    event DepositTokens(uint256 _numberOfTokens, address _sender);\n    // Emit when all unassigned tokens are sent to treasury\n    event SendToTreasury(uint256 _numberOfTokens, address _sender);\n    // Emit when is sent tokes to user\n    event SendTokens(address indexed _beneficiary, uint256 _numberOfTokens);\n    // Emit when template is added\n    event AddTemplate(bytes32 _name, uint256 _numberOfTokens, uint256 _duration, uint256 _frequency);\n    // Emit when template is removed\n    event RemoveTemplate(bytes32 _name);\n    // Emit when the treasury wallet gets changed\n    event TreasuryWalletChanged(address _newWallet, address _oldWallet);\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress)\n    public\n    Module(_securityToken, _polyAddress)\n    {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',1);\n\n    }\n\n    /**\n     * @notice This function returns the signature of the configure function\n     */\n    function getInitFunction() public  returns (bytes4) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',2);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',62);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',1);\nreturn bytes4(keccak256(\"configure(address)\"));\n    }\n\n    /**\n     * @notice Used to initialize the treasury wallet address\n     * @param _treasuryWallet Address of the treasury wallet\n     */\n    function configure(address _treasuryWallet) public onlyFactory {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',3);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',70);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',1);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',2);\nrequire(_treasuryWallet != address(0), \"Invalid address\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',1);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',71);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',3);\ntreasuryWallet = _treasuryWallet;\n    }\n\n    /**\n     * @notice Used to change the treasury wallet address\n     * @param _newTreasuryWallet Address of the treasury wallet\n     */\n    function changeTreasuryWallet(address _newTreasuryWallet) public onlyOwner {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',4);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',79);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',2);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',4);\nrequire(_newTreasuryWallet != address(0));emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',2);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',80);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',5);\nemit TreasuryWalletChanged(_newTreasuryWallet, treasuryWallet);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',81);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',6);\ntreasuryWallet = _newTreasuryWallet;\n    }\n\n    /**\n     * @notice Used to deposit tokens from treasury wallet to the vesting escrow wallet\n     * @param _numberOfTokens Number of tokens that should be deposited\n     */\n    function depositTokens(uint256 _numberOfTokens) external withPerm(ADMIN) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',5);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',89);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',7);\n_depositTokens(_numberOfTokens);\n    }\n\n    function _depositTokens(uint256 _numberOfTokens) internal {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',6);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',93);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',3);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',8);\nrequire(_numberOfTokens > 0, \"Should be > 0\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',3);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',94);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',4);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',9);\nrequire(\n            ISecurityToken(securityToken).transferFrom(msg.sender, address(this), _numberOfTokens),\n            \"Failed transferFrom due to insufficent Allowance provided\"\n        );emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',4);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',98);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',10);\nunassignedTokens = unassignedTokens.add(_numberOfTokens);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',99);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',11);\nemit DepositTokens(_numberOfTokens, msg.sender);\n    }\n\n    /**\n     * @notice Sends unassigned tokens to the treasury wallet\n     * @param _amount Amount of tokens that should be send to the treasury wallet\n     */\n    function sendToTreasury(uint256 _amount) external withPerm(ADMIN) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',7);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',107);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',5);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',12);\nrequire(_amount > 0, \"Amount cannot be zero\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',5);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',108);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',6);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',13);\nrequire(_amount <= unassignedTokens, \"Amount is greater than unassigned tokens\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',6);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',109);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',14);\nuint256 amount = unassignedTokens;\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',110);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',15);\nunassignedTokens = 0;\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',111);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',7);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',16);\nrequire(ISecurityToken(securityToken).transfer(treasuryWallet, amount), \"Transfer failed\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',7);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',112);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',17);\nemit SendToTreasury(amount, msg.sender);\n    }\n\n    /**\n     * @notice Pushes available tokens to the beneficiary's address\n     * @param _beneficiary Address of the beneficiary who will receive tokens\n     */\n    function pushAvailableTokens(address _beneficiary) public withPerm(ADMIN) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',8);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',120);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',18);\n_sendTokens(_beneficiary);\n    }\n\n    /**\n     * @notice Used to withdraw available tokens by beneficiary\n     */\n    function pullAvailableTokens() external {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',9);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',127);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',19);\n_sendTokens(msg.sender);\n    }\n\n    /**\n     * @notice Adds template that can be used for creating schedule\n     * @param _name Name of the template will be created\n     * @param _numberOfTokens Number of tokens that should be assigned to schedule\n     * @param _duration Duration of the vesting schedule\n     * @param _frequency Frequency of the vesting schedule\n     */\n    function addTemplate(bytes32 _name, uint256 _numberOfTokens, uint256 _duration, uint256 _frequency) external withPerm(ADMIN) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',10);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',138);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',20);\n_addTemplate(_name, _numberOfTokens, _duration, _frequency);\n    }\n\n    function _addTemplate(bytes32 _name, uint256 _numberOfTokens, uint256 _duration, uint256 _frequency) internal {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',11);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',142);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',8);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',21);\nrequire(_name != bytes32(0), \"Invalid name\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',8);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',143);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',9);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',22);\nrequire(!_isTemplateExists(_name), \"Already exists\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',9);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',144);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',23);\n_validateTemplate(_numberOfTokens, _duration, _frequency);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',145);\n        templateNames.push(_name);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',146);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',24);\ntemplates[_name] = Template(_numberOfTokens, _duration, _frequency, templateNames.length - 1);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',147);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',25);\nemit AddTemplate(_name, _numberOfTokens, _duration, _frequency);\n    }\n\n    /**\n     * @notice Removes template with a given name\n     * @param _name Name of the template that will be removed\n     */\n    function removeTemplate(bytes32 _name) external withPerm(ADMIN) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',12);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',155);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',10);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',26);\nrequire(_isTemplateExists(_name), \"Template not found\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',10);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',156);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',11);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',27);\nrequire(templateToUsers[_name].length == 0, \"Template is used\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',11);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',157);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',28);\nuint256 index = templates[_name].index;\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',158);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',29);\nif (index != templateNames.length - 1) {emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',12,0);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',159);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',30);\ntemplateNames[index] = templateNames[templateNames.length - 1];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',160);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',31);\ntemplates[templateNames[index]].index = index;\n        }else { emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',12,1);}\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',162);\n        templateNames.length--;\n        // delete template data\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',164);\n        delete templates[_name];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',165);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',32);\nemit RemoveTemplate(_name);\n    }\n\n    /**\n     * @notice Returns count of the templates those can be used for creating schedule\n     * @return Count of the templates\n     */\n    function getTemplateCount() external  returns(uint256) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',13);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',173);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',33);\nreturn templateNames.length;\n    }\n\n    /**\n     * @notice Gets the list of the template names those can be used for creating schedule\n     * @return bytes32 Array of all template names were created\n     */\n    function getAllTemplateNames() external  returns(bytes32[]) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',14);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',181);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',34);\nreturn templateNames;\n    }\n\n    /**\n     * @notice Adds vesting schedules for each of the beneficiary's address\n     * @param _beneficiary Address of the beneficiary for whom it is scheduled\n     * @param _templateName Name of the template that will be created\n     * @param _numberOfTokens Total number of tokens for created schedule\n     * @param _duration Duration of the created vesting schedule\n     * @param _frequency Frequency of the created vesting schedule\n     * @param _startTime Start time of the created vesting schedule\n     */\n    function addSchedule(\n        address _beneficiary,\n        bytes32 _templateName,\n        uint256 _numberOfTokens,\n        uint256 _duration,\n        uint256 _frequency,\n        uint256 _startTime\n    )\n        external\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',15);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',204);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',35);\n_addSchedule(_beneficiary, _templateName, _numberOfTokens, _duration, _frequency, _startTime);\n    }\n\n    function _addSchedule(\n        address _beneficiary,\n        bytes32 _templateName,\n        uint256 _numberOfTokens,\n        uint256 _duration,\n        uint256 _frequency,\n        uint256 _startTime\n    )\n        internal\n    {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',16);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',217);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',36);\n_addTemplate(_templateName, _numberOfTokens, _duration, _frequency);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',218);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',37);\n_addScheduleFromTemplate(_beneficiary, _templateName, _startTime);\n    }\n\n    /**\n     * @notice Adds vesting schedules from template for the beneficiary\n     * @param _beneficiary Address of the beneficiary for whom it is scheduled\n     * @param _templateName Name of the exists template\n     * @param _startTime Start time of the created vesting schedule\n     */\n    function addScheduleFromTemplate(address _beneficiary, bytes32 _templateName, uint256 _startTime) external withPerm(ADMIN) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',17);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',228);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',38);\n_addScheduleFromTemplate(_beneficiary, _templateName, _startTime);\n    }\n\n    function _addScheduleFromTemplate(address _beneficiary, bytes32 _templateName, uint256 _startTime) internal {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',18);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',232);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',13);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',39);\nrequire(_beneficiary != address(0), \"Invalid address\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',13);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',233);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',14);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',40);\nrequire(_isTemplateExists(_templateName), \"Template not found\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',14);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',234);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',41);\nuint256 index = userToTemplateIndex[_beneficiary][_templateName];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',235);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',15);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',42);\nrequire(\n            schedules[_beneficiary].length == 0 ||\n            schedules[_beneficiary][index].templateName != _templateName,\n            \"Already added\"\n        );emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',15);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',240);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',16);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',43);\nrequire(_startTime >= now, \"Date in the past\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',16);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',241);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',44);\nuint256 numberOfTokens = templates[_templateName].numberOfTokens;\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',242);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',45);\nif (numberOfTokens > unassignedTokens) {emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',17,0);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',243);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',46);\n_depositTokens(numberOfTokens.sub(unassignedTokens));\n        }else { emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',17,1);}\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',245);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',47);\nunassignedTokens = unassignedTokens.sub(numberOfTokens);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',246);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',48);\nif (!beneficiaryAdded[_beneficiary]) {emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',18,0);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',247);\n            beneficiaries.push(_beneficiary);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',248);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',49);\nbeneficiaryAdded[_beneficiary] = true;\n        }else { emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',18,1);}\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',250);\n        schedules[_beneficiary].push(Schedule(_templateName, 0, _startTime));\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',251);\n        userToTemplates[_beneficiary].push(_templateName);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',252);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',50);\nuserToTemplateIndex[_beneficiary][_templateName] = schedules[_beneficiary].length - 1;\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',253);\n        templateToUsers[_templateName].push(_beneficiary);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',254);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',51);\ntemplateToUserIndex[_templateName][_beneficiary] = templateToUsers[_templateName].length - 1;\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',255);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',52);\nemit AddSchedule(_beneficiary, _templateName, _startTime);\n    }\n\n    /**\n     * @notice Modifies vesting schedules for each of the beneficiary\n     * @param _beneficiary Address of the beneficiary for whom it is modified\n     * @param _templateName Name of the template was used for schedule creation\n     * @param _startTime Start time of the created vesting schedule\n     */\n    function modifySchedule(address _beneficiary, bytes32 _templateName, uint256 _startTime) public withPerm(ADMIN) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',19);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',265);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',53);\n_modifySchedule(_beneficiary, _templateName, _startTime);\n    }\n\n    function _modifySchedule(address _beneficiary, bytes32 _templateName, uint256 _startTime) internal {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',20);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',269);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',54);\n_checkSchedule(_beneficiary, _templateName);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',270);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',19);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',55);\nrequire(_startTime > now, \"Date in the past\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',19);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',271);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',56);\nuint256 index = userToTemplateIndex[_beneficiary][_templateName];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',272);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',57);\nSchedule storage schedule = schedules[_beneficiary][index];\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',274);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',20);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',58);\nrequire(now < schedule.startTime, \"Schedule started\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',20);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',275);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',59);\nschedule.startTime = _startTime;\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',276);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',60);\nemit ModifySchedule(_beneficiary, _templateName, _startTime);\n    }\n\n    /**\n     * @notice Revokes vesting schedule with given template name for given beneficiary\n     * @param _beneficiary Address of the beneficiary for whom it is revoked\n     * @param _templateName Name of the template was used for schedule creation\n     */\n    function revokeSchedule(address _beneficiary, bytes32 _templateName) external withPerm(ADMIN) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',21);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',285);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',61);\n_checkSchedule(_beneficiary, _templateName);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',286);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',62);\nuint256 index = userToTemplateIndex[_beneficiary][_templateName];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',287);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',63);\n_sendTokensPerSchedule(_beneficiary, index);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',288);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',64);\nuint256 releasedTokens = _getReleasedTokens(_beneficiary, index);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',289);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',65);\nunassignedTokens = unassignedTokens.add(templates[_templateName].numberOfTokens.sub(releasedTokens));\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',290);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',66);\n_deleteUserToTemplates(_beneficiary, _templateName);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',291);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',67);\n_deleteTemplateToUsers(_beneficiary, _templateName);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',292);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',68);\nemit RevokeSchedule(_beneficiary, _templateName);\n    }\n\n    function _deleteUserToTemplates(address _beneficiary, bytes32 _templateName) internal {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',22);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',296);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',69);\nuint256 index = userToTemplateIndex[_beneficiary][_templateName];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',297);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',70);\nSchedule[] storage userSchedules = schedules[_beneficiary];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',298);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',71);\nif (index != userSchedules.length - 1) {emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',21,0);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',299);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',72);\nuserSchedules[index] = userSchedules[userSchedules.length - 1];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',300);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',73);\nuserToTemplates[_beneficiary][index] = userToTemplates[_beneficiary][userToTemplates[_beneficiary].length - 1];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',301);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',74);\nuserToTemplateIndex[_beneficiary][userSchedules[index].templateName] = index;\n        }else { emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',21,1);}\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',303);\n        userSchedules.length--;\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',304);\n        userToTemplates[_beneficiary].length--;\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',305);\n        delete userToTemplateIndex[_beneficiary][_templateName];\n    }\n\n    function _deleteTemplateToUsers(address _beneficiary, bytes32 _templateName) internal {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',23);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',309);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',75);\nuint256 templateIndex = templateToUserIndex[_templateName][_beneficiary];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',310);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',76);\nif (templateIndex != templateToUsers[_templateName].length - 1) {emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',22,0);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',311);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',77);\ntemplateToUsers[_templateName][templateIndex] = templateToUsers[_templateName][templateToUsers[_templateName].length - 1];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',312);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',78);\ntemplateToUserIndex[_templateName][templateToUsers[_templateName][templateIndex]] = templateIndex;\n        }else { emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',22,1);}\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',314);\n        templateToUsers[_templateName].length--;\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',315);\n        delete templateToUserIndex[_templateName][_beneficiary];\n    }\n\n    /**\n     * @notice Revokes all vesting schedules for given beneficiary's address\n     * @param _beneficiary Address of the beneficiary for whom all schedules will be revoked\n     */\n    function revokeAllSchedules(address _beneficiary) public withPerm(ADMIN) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',24);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',323);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',79);\n_revokeAllSchedules(_beneficiary);\n    }\n\n    function _revokeAllSchedules(address _beneficiary) internal {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',25);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',327);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',23);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',80);\nrequire(_beneficiary != address(0), \"Invalid address\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',23);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',328);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',81);\n_sendTokens(_beneficiary);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',329);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',82);\nSchedule[] storage userSchedules = schedules[_beneficiary];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',330);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',83);\nfor (uint256 i = 0; i < userSchedules.length; i++) {\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',331);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',84);\nuint256 releasedTokens = _getReleasedTokens(_beneficiary, i);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',332);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',85);\nTemplate memory template = templates[userSchedules[i].templateName];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',333);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',86);\nunassignedTokens = unassignedTokens.add(template.numberOfTokens.sub(releasedTokens));\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',334);\n            delete userToTemplateIndex[_beneficiary][userSchedules[i].templateName];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',335);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',87);\n_deleteTemplateToUsers(_beneficiary, userSchedules[i].templateName);\n        }\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',337);\n        delete schedules[_beneficiary];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',338);\n        delete userToTemplates[_beneficiary];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',339);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',88);\nemit RevokeAllSchedules(_beneficiary);\n    }\n\n    /**\n     * @notice Returns beneficiary's schedule created using template name\n     * @param _beneficiary Address of the beneficiary who will receive tokens\n     * @param _templateName Name of the template was used for schedule creation\n     * @return beneficiary's schedule data (numberOfTokens, duration, frequency, startTime, claimedTokens, State)\n     */\n    function getSchedule(address _beneficiary, bytes32 _templateName) external  returns(uint256, uint256, uint256, uint256, uint256, State) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',26);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',349);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',89);\n_checkSchedule(_beneficiary, _templateName);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',350);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',90);\nuint256 index = userToTemplateIndex[_beneficiary][_templateName];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',351);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',91);\nSchedule memory schedule = schedules[_beneficiary][index];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',352);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',92);\nreturn (\n            templates[schedule.templateName].numberOfTokens,\n            templates[schedule.templateName].duration,\n            templates[schedule.templateName].frequency,\n            schedule.startTime,\n            schedule.claimedTokens,\n            _getScheduleState(_beneficiary, _templateName)\n        );\n    }\n\n    function _getScheduleState(address _beneficiary, bytes32 _templateName) internal  returns(State) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',27);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',363);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',93);\n_checkSchedule(_beneficiary, _templateName);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',364);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',94);\nuint256 index = userToTemplateIndex[_beneficiary][_templateName];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',365);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',95);\nSchedule memory schedule = schedules[_beneficiary][index];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',366);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',96);\nif (now < schedule.startTime) {emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',24,0);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',367);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',97);\nreturn State.CREATED;\n        } else {emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',98);\nemit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',24,1);if (now > schedule.startTime && now < schedule.startTime.add(templates[_templateName].duration)) {emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',25,0);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',369);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',99);\nreturn State.STARTED;\n        } else {emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',25,1);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',371);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',100);\nreturn State.COMPLETED;\n        }}\n    }\n\n    /**\n     * @notice Returns list of the template names for given beneficiary's address\n     * @param _beneficiary Address of the beneficiary\n     * @return List of the template names that were used for schedule creation\n     */\n    function getTemplateNames(address _beneficiary) external  returns(bytes32[]) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',28);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',381);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',26);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',101);\nrequire(_beneficiary != address(0), \"Invalid address\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',26);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',382);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',102);\nreturn userToTemplates[_beneficiary];\n    }\n\n    /**\n     * @notice Returns count of the schedules were created for given beneficiary\n     * @param _beneficiary Address of the beneficiary\n     * @return Count of beneficiary's schedules\n     */\n    function getScheduleCount(address _beneficiary) external  returns(uint256) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',29);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',391);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',27);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',103);\nrequire(_beneficiary != address(0), \"Invalid address\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',27);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',392);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',104);\nreturn schedules[_beneficiary].length;\n    }\n\n    function _getAvailableTokens(address _beneficiary, uint256 _index) internal  returns(uint256) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',30);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',396);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',105);\nSchedule memory schedule = schedules[_beneficiary][_index];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',397);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',106);\nuint256 releasedTokens = _getReleasedTokens(_beneficiary, _index);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',398);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',107);\nreturn releasedTokens.sub(schedule.claimedTokens);\n    }\n\n    function _getReleasedTokens(address _beneficiary, uint256 _index) internal  returns(uint256) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',31);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',402);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',108);\nSchedule memory schedule = schedules[_beneficiary][_index];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',403);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',109);\nTemplate memory template = templates[schedule.templateName];\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',405);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',110);\nif (now > schedule.startTime) {emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',28,0);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',406);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',111);\nuint256 periodCount = template.duration.div(template.frequency);\n            /*solium-disable-next-line security/no-block-members*/\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',408);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',112);\nuint256 periodNumber = (now.sub(schedule.startTime)).div(template.frequency);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',409);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',113);\nif (periodNumber > periodCount) {emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',29,0);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',410);\n                emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',114);\nperiodNumber = periodCount;\n            }else { emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',29,1);}\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',412);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',115);\nreturn template.numberOfTokens.mul(periodNumber).div(periodCount);\n        } else {emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',28,1);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',414);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',116);\nreturn 0;\n        }\n    }\n\n    /**\n     * @notice Used to bulk send available tokens for each of the beneficiaries\n     * @param _fromIndex Start index of array of beneficiary's addresses\n     * @param _toIndex End index of array of beneficiary's addresses\n     */\n    function pushAvailableTokensMulti(uint256 _fromIndex, uint256 _toIndex) external withPerm(ADMIN) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',32);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',424);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',30);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',117);\nrequire(_toIndex <= beneficiaries.length - 1, \"Array out of bound\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',30);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',425);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',118);\nfor (uint256 i = _fromIndex; i <= _toIndex; i++) {\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',426);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',119);\nif (schedules[beneficiaries[i]].length !=0)\n                {emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',120);\nemit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',31,0);emit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',427);\npushAvailableTokens(beneficiaries[i]);}else { emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',31,1);}\n\n        }\n    }\n\n    /**\n     * @notice Used to bulk add vesting schedules for each of beneficiary\n     * @param _beneficiaries Array of the beneficiary's addresses\n     * @param _templateNames Array of the template names\n     * @param _numberOfTokens Array of number of tokens should be assigned to schedules\n     * @param _durations Array of the vesting duration\n     * @param _frequencies Array of the vesting frequency\n     * @param _startTimes Array of the vesting start time\n     */\n    function addScheduleMulti(\n        address[] _beneficiaries,\n        bytes32[] _templateNames,\n        uint256[] _numberOfTokens,\n        uint256[] _durations,\n        uint256[] _frequencies,\n        uint256[] _startTimes\n    )\n        public\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',33);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',451);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',32);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',121);\nrequire(\n            _beneficiaries.length == _templateNames.length && /*solium-disable-line operator-whitespace*/\n            _beneficiaries.length == _numberOfTokens.length && /*solium-disable-line operator-whitespace*/\n            _beneficiaries.length == _durations.length && /*solium-disable-line operator-whitespace*/\n            _beneficiaries.length == _frequencies.length && /*solium-disable-line operator-whitespace*/\n            _beneficiaries.length == _startTimes.length,\n            \"Arrays sizes mismatch\"\n        );emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',32);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',459);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',122);\nfor (uint256 i = 0; i < _beneficiaries.length; i++) {\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',460);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',123);\n_addSchedule(_beneficiaries[i], _templateNames[i], _numberOfTokens[i], _durations[i], _frequencies[i], _startTimes[i]);\n        }\n    }\n\n    /**\n     * @notice Used to bulk add vesting schedules from template for each of the beneficiary\n     * @param _beneficiaries Array of beneficiary's addresses\n     * @param _templateNames Array of the template names were used for schedule creation\n     * @param _startTimes Array of the vesting start time\n     */\n    function addScheduleFromTemplateMulti(address[] _beneficiaries, bytes32[] _templateNames, uint256[] _startTimes) external withPerm(ADMIN) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',34);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',471);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',33);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',124);\nrequire(_beneficiaries.length == _templateNames.length && _beneficiaries.length == _startTimes.length, \"Arrays sizes mismatch\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',33);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',472);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',125);\nfor (uint256 i = 0; i < _beneficiaries.length; i++) {\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',473);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',126);\n_addScheduleFromTemplate(_beneficiaries[i], _templateNames[i], _startTimes[i]);\n        }\n    }\n\n    /**\n     * @notice Used to bulk revoke vesting schedules for each of the beneficiaries\n     * @param _beneficiaries Array of the beneficiary's addresses\n     */\n    function revokeSchedulesMulti(address[] _beneficiaries) external withPerm(ADMIN) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',35);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',482);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',127);\nfor (uint256 i = 0; i < _beneficiaries.length; i++) {\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',483);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',128);\n_revokeAllSchedules(_beneficiaries[i]);\n        }\n    }\n\n    /**\n     * @notice Used to bulk modify vesting schedules for each of the beneficiaries\n     * @param _beneficiaries Array of the beneficiary's addresses\n     * @param _templateNames Array of the template names\n     * @param _startTimes Array of the vesting start time\n     */\n    function modifyScheduleMulti(\n        address[] _beneficiaries,\n        bytes32[] _templateNames,\n        uint256[] _startTimes\n    )\n        public\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',36);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',501);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',34);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',129);\nrequire(\n            _beneficiaries.length == _templateNames.length && /*solium-disable-line operator-whitespace*/\n            _beneficiaries.length == _startTimes.length,\n            \"Arrays sizes mismatch\"\n        );emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',34);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',506);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',130);\nfor (uint256 i = 0; i < _beneficiaries.length; i++) {\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',507);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',131);\n_modifySchedule(_beneficiaries[i], _templateNames[i], _startTimes[i]);\n        }\n    }\n\n    function _checkSchedule(address _beneficiary, bytes32 _templateName) internal  {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',37);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',512);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',35);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',132);\nrequire(_beneficiary != address(0), \"Invalid address\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',35);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',513);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',133);\nuint256 index = userToTemplateIndex[_beneficiary][_templateName];\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',514);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',36);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',134);\nrequire(\n            index < schedules[_beneficiary].length &&\n            schedules[_beneficiary][index].templateName == _templateName,\n            \"Schedule not found\"\n        );emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',36);\n\n    }\n\n    function _isTemplateExists(bytes32 _name) internal  returns(bool) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',38);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',522);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',135);\nreturn templates[_name].numberOfTokens > 0;\n    }\n\n    function _validateTemplate(uint256 _numberOfTokens, uint256 _duration, uint256 _frequency) internal  {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',39);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',526);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',37);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',136);\nrequire(_numberOfTokens > 0, \"Zero amount\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',37);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',527);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',38);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',137);\nrequire(_duration % _frequency == 0, \"Invalid frequency\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',38);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',528);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',138);\nuint256 periodCount = _duration.div(_frequency);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',529);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',39);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',139);\nrequire(_numberOfTokens % periodCount == 0);emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',39);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',530);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',140);\nuint256 amountPerPeriod = _numberOfTokens.div(periodCount);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',531);\n        emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',40);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',141);\nrequire(amountPerPeriod % ISecurityToken(securityToken).granularity() == 0, \"Invalid granularity\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',40);\n\n    }\n\n    function _sendTokens(address _beneficiary) internal {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',40);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',535);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',142);\nfor (uint256 i = 0; i < schedules[_beneficiary].length; i++) {\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',536);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',143);\n_sendTokensPerSchedule(_beneficiary, i);\n        }\n    }\n\n    function _sendTokensPerSchedule(address _beneficiary, uint256 _index) internal {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',41);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',541);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',144);\nuint256 amount = _getAvailableTokens(_beneficiary, _index);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',542);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',145);\nif (amount > 0) {emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',41,0);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',543);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',146);\nschedules[_beneficiary][_index].claimedTokens = schedules[_beneficiary][_index].claimedTokens.add(amount);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',544);\n            emit __AssertPreCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',42);\nemit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',147);\nrequire(ISecurityToken(securityToken).transfer(_beneficiary, amount), \"Transfer failed\");emit __AssertPostCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',42);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',545);\n            emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',148);\nemit SendTokens(_beneficiary, amount);\n        }else { emit __BranchCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',41,1);}\n\n    }\n\n    /**\n     * @notice Return the permissions flag that are associated with VestingEscrowWallet\n     */\n    function getPermissions() public  returns(bytes32[]) {emit __FunctionCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',42);\n\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',553);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',149);\nbytes32[] memory allPermissions = new bytes32[](1);\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',554);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',150);\nallPermissions[0] = ADMIN;\nemit __CoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',555);\n        emit __StatementCoverageVestingEscrowWallet('./contracts/modules/Wallet/VestingEscrowWallet.sol',151);\nreturn allPermissions;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/ITransferManager.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../../Pausable.sol\";\nimport \"../Module.sol\";\n\n/**\n * @title Interface to be implemented by all Transfer Manager modules\n * @dev abstract contract\n */\ncontract ITransferManager is Module, Pausable {event __CoverageITransferManager(string fileName, uint256 lineNumber);\nevent __FunctionCoverageITransferManager(string fileName, uint256 fnId);\nevent __StatementCoverageITransferManager(string fileName, uint256 statementId);\nevent __BranchCoverageITransferManager(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageITransferManager(string fileName, uint256 branchId);\nevent __AssertPostCoverageITransferManager(string fileName, uint256 branchId);\n\n\n    //If verifyTransfer returns:\n    //  FORCE_VALID, the transaction will always be valid, regardless of other TM results\n    //  INVALID, then the transfer should not be allowed regardless of other TM results\n    //  VALID, then the transfer is valid for this TM\n    //  NA, then the result from this TM is ignored\n    enum Result {INVALID, NA, VALID, FORCE_VALID}\n\n    function verifyTransfer(address _from, address _to, uint256 _amount, bytes _data, bool _isTransfer) public returns(Result);\n\n    function unpause() public onlyOwner {emit __FunctionCoverageITransferManager('./contracts/modules/TransferManager/ITransferManager.sol',1);\n\nemit __CoverageITransferManager('./contracts/modules/TransferManager/ITransferManager.sol',22);\n        super._unpause();\n    }\n\n    function pause() public onlyOwner {emit __FunctionCoverageITransferManager('./contracts/modules/TransferManager/ITransferManager.sol',2);\n\nemit __CoverageITransferManager('./contracts/modules/TransferManager/ITransferManager.sol',26);\n        super._pause();\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/tokens/SecurityToken.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IModule.sol\";\nimport \"../interfaces/IModuleFactory.sol\";\nimport \"../interfaces/IModuleRegistry.sol\";\nimport \"../interfaces/IFeatureRegistry.sol\";\nimport \"../modules/TransferManager/ITransferManager.sol\";\nimport \"../RegistryUpdater.sol\";\nimport \"../libraries/Util.sol\";\nimport \"openzeppelin-solidity/contracts/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol\";\nimport \"../libraries/TokenLib.sol\";\n\n/**\n* @title Security Token contract\n* @notice SecurityToken is an ERC20 token with added capabilities:\n* @notice - Implements the ST-20 Interface\n* @notice - Transfers are restricted\n* @notice - Modules can be attached to it to control its behaviour\n* @notice - ST should not be deployed directly, but rather the SecurityTokenRegistry should be used\n* @notice - ST does not inherit from ISecurityToken due to:\n* @notice - https://github.com/ethereum/solidity/issues/4847\n*/\ncontract SecurityToken is StandardToken, DetailedERC20, ReentrancyGuard, RegistryUpdater {event __CoverageSecurityToken(string fileName, uint256 lineNumber);\nevent __FunctionCoverageSecurityToken(string fileName, uint256 fnId);\nevent __StatementCoverageSecurityToken(string fileName, uint256 statementId);\nevent __BranchCoverageSecurityToken(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageSecurityToken(string fileName, uint256 branchId);\nevent __AssertPostCoverageSecurityToken(string fileName, uint256 branchId);\n\n    using SafeMath for uint256;\n\n    TokenLib.InvestorDataStorage investorData;\n\n    // Used to hold the semantic version data\n    struct SemanticVersion {\n        uint8 major;\n        uint8 minor;\n        uint8 patch;\n    }\n\n    SemanticVersion securityTokenVersion;\n\n    // off-chain data\n    string public tokenDetails;\n\n    uint8 constant PERMISSION_KEY = 1;\n    uint8 constant TRANSFER_KEY = 2;\n    uint8 constant MINT_KEY = 3;\n    uint8 constant CHECKPOINT_KEY = 4;\n    uint8 constant BURN_KEY = 5;\n\n    uint256 public granularity;\n\n    // Value of current checkpoint\n    uint256 public currentCheckpointId;\n\n    // Used to temporarily halt all transactions\n    bool public transfersFrozen;\n\n    // Used to permanently halt all minting\n    bool public mintingFrozen;\n\n    // Used to permanently halt controller actions\n    bool public controllerDisabled;\n\n    // Address whitelisted by issuer as controller\n    address public controller;\n\n    // Records added modules - module list should be order agnostic!\n    mapping (uint8 => address[]) modules;\n\n    // Records information about the module\n    mapping (address => TokenLib.ModuleData) modulesToData;\n\n    // Records added module names - module list should be order agnostic!\n    mapping (bytes32 => address[]) names;\n\n    // Map each investor to a series of checkpoints\n    mapping (address => TokenLib.Checkpoint[]) checkpointBalances;\n\n    // List of checkpoints that relate to total supply\n    TokenLib.Checkpoint[] checkpointTotalSupply;\n\n    // Times at which each checkpoint was created\n    uint256[] checkpointTimes;\n\n    // Emit at the time when module get added\n    event ModuleAdded(\n        uint8[] _types,\n        bytes32 _name,\n        address _moduleFactory,\n        address _module,\n        uint256 _moduleCost,\n        uint256 _budget,\n        uint256 _timestamp\n    );\n\n    // Emit when the token details get updated\n    event UpdateTokenDetails(string _oldDetails, string _newDetails);\n    // Emit when the granularity get changed\n    event GranularityChanged(uint256 _oldGranularity, uint256 _newGranularity);\n    // Emit when Module get archived from the securityToken\n    event ModuleArchived(uint8[] _types, address _module, uint256 _timestamp);\n    // Emit when Module get unarchived from the securityToken\n    event ModuleUnarchived(uint8[] _types, address _module, uint256 _timestamp);\n    // Emit when Module get removed from the securityToken\n    event ModuleRemoved(uint8[] _types, address _module, uint256 _timestamp);\n    // Emit when the budget allocated to a module is changed\n    event ModuleBudgetChanged(uint8[] _moduleTypes, address _module, uint256 _oldBudget, uint256 _budget);\n    // Emit when transfers are frozen or unfrozen\n    event FreezeTransfers(bool _status, uint256 _timestamp);\n    // Emit when new checkpoint created\n    event CheckpointCreated(uint256 indexed _checkpointId, uint256 _timestamp);\n    // Emit when is permanently frozen by the issuer\n    event FreezeMinting(uint256 _timestamp);\n    // Events to log minting and burning\n    event Minted(address indexed _to, uint256 _value);\n    event Burnt(address indexed _from, uint256 _value);\n\n    // Events to log controller actions\n    event SetController(address indexed _oldController, address indexed _newController);\n    event ForceTransfer(\n        address indexed _controller,\n        address indexed _from,\n        address indexed _to,\n        uint256 _value,\n        bool _verifyTransfer,\n        bytes _data\n    );\n    event ForceBurn(\n        address indexed _controller,\n        address indexed _from,\n        uint256 _value,\n        bool _verifyTransfer,\n        bytes _data\n    );\n    event DisableController(uint256 _timestamp);\n\n    function _isModule(address _module, uint8 _type) internal  returns (bool) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',1);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',138);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',1);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',1);\nrequire(modulesToData[_module].module == _module, \"Wrong address\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',1);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',139);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',2);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',2);\nrequire(!modulesToData[_module].isArchived, \"Module archived\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',2);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',140);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',3);\nfor (uint256 i = 0; i < modulesToData[_module].moduleTypes.length; i++) {\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',141);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',4);\nif (modulesToData[_module].moduleTypes[i] == _type) {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',3,0);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',142);\n                emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',5);\nreturn true;\n            }else { emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',3,1);}\n\n        }\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',145);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',6);\nreturn false;\n    }\n\n    // Require msg.sender to be the specified module type\n    modifier onlyModule(uint8 _type) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',2);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',150);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',4);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',7);\nrequire(_isModule(msg.sender, _type));emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',4);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',151);\n        _;\n    }\n\n    // Require msg.sender to be the specified module type or the owner of the token\n    modifier onlyModuleOrOwner(uint8 _type) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',3);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',156);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',8);\nif (msg.sender == owner) {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',5,0);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',157);\n            _;\n        } else {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',5,1);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',159);\n            emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',6);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',9);\nrequire(_isModule(msg.sender, _type));emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',6);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',160);\n            _;\n        }\n    }\n\n    modifier checkGranularity(uint256 _value) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',4);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',165);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',7);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',10);\nrequire(_value % granularity == 0, \"Invalid granularity\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',7);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',166);\n        _;\n    }\n\n    modifier isMintingAllowed() {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',5);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',170);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',8);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',11);\nrequire(!mintingFrozen, \"Minting frozen\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',8);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',171);\n        _;\n    }\n\n    modifier isEnabled(string _nameKey) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',6);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',175);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',9);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',12);\nrequire(IFeatureRegistry(featureRegistry).getFeatureStatus(_nameKey));emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',9);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',176);\n        _;\n    }\n\n    /**\n     * @notice Revert if called by an account which is not a controller\n     */\n    modifier onlyController() {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',7);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',183);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',10);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',13);\nrequire(msg.sender == controller, \"Not controller\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',10);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',184);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',11);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',14);\nrequire(!controllerDisabled, \"Controller disabled\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',11);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',185);\n        _;\n    }\n\n    /**\n     * @notice Constructor\n     * @param _name Name of the SecurityToken\n     * @param _symbol Symbol of the Token\n     * @param _decimals Decimals for the securityToken\n     * @param _granularity granular level of the token\n     * @param _tokenDetails Details of the token that are stored off-chain\n     * @param _polymathRegistry Contract address of the polymath registry\n     */\n    constructor (\n        string _name,\n        string _symbol,\n        uint8 _decimals,\n        uint256 _granularity,\n        string _tokenDetails,\n        address _polymathRegistry\n    )\n    public\n    DetailedERC20(_name, _symbol, _decimals)\n    RegistryUpdater(_polymathRegistry)\n    {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',8);\n\n        //When it is created, the owner is the STR\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',210);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',15);\nupdateFromRegistry();\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',211);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',16);\ntokenDetails = _tokenDetails;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',212);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',17);\ngranularity = _granularity;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',213);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',18);\nsecurityTokenVersion = SemanticVersion(2,0,0);\n    }\n\n    /**\n     * @notice Attachs a module to the SecurityToken\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\n     * @dev to control restrictions on transfers.\n     * @param _moduleFactory is the address of the module factory to be added\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\n     * @param _maxCost max amount of POLY willing to pay to the module.\n     * @param _budget max amount of ongoing POLY willing to assign to the module.\n     */\n    function addModule(\n        address _moduleFactory,\n        bytes _data,\n        uint256 _maxCost,\n        uint256 _budget\n    ) external onlyOwner nonReentrant {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',9);\n\n        //Check that the module factory exists in the ModuleRegistry - will throw otherwise\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',232);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',19);\nIModuleRegistry(moduleRegistry).useModule(_moduleFactory);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',233);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',20);\nIModuleFactory moduleFactory = IModuleFactory(_moduleFactory);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',234);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',21);\nuint8[] memory moduleTypes = moduleFactory.getTypes();\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',235);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',22);\nuint256 moduleCost = moduleFactory.getSetupCost();\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',236);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',12);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',23);\nrequire(moduleCost <= _maxCost, \"Invalid cost\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',12);\n\n        //Approve fee for module\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',238);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',24);\nERC20(polyToken).approve(_moduleFactory, moduleCost);\n        //Creates instance of module from factory\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',240);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',25);\naddress module = moduleFactory.deploy(_data);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',241);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',13);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',26);\nrequire(modulesToData[module].module == address(0), \"Module exists\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',13);\n\n        //Approve ongoing budget\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',243);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',27);\nERC20(polyToken).approve(module, _budget);\n        //Add to SecurityToken module map\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',245);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',28);\nbytes32 moduleName = moduleFactory.getName();\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',246);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',29);\nuint256[] memory moduleIndexes = new uint256[](moduleTypes.length);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',247);\n        uint256 i;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',248);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',30);\nfor (i = 0; i < moduleTypes.length; i++) {\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',249);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',31);\nmoduleIndexes[i] = modules[moduleTypes[i]].length;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',250);\n            modules[moduleTypes[i]].push(module);\n        }\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',252);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',32);\nmodulesToData[module] = TokenLib.ModuleData(\n            moduleName, module, _moduleFactory, false, moduleTypes, moduleIndexes, names[moduleName].length\n        );\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',255);\n        names[moduleName].push(module);\n        //Emit log event\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',258);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',33);\nemit ModuleAdded(moduleTypes, moduleName, _moduleFactory, module, moduleCost, _budget, now);\n    }\n\n    /**\n    * @notice Archives a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function archiveModule(address _module) external onlyOwner {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',10);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',266);\n        TokenLib.archiveModule(modulesToData[_module], _module);\n    }\n\n    /**\n    * @notice Unarchives a module attached to the SecurityToken\n    * @param _module address of module to unarchive\n    */\n    function unarchiveModule(address _module) external onlyOwner {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',11);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',274);\n        TokenLib.unarchiveModule(modulesToData[_module], _module);\n    }\n\n    /**\n    * @notice Removes a module attached to the SecurityToken\n    * @param _module address of module to unarchive\n    */\n    function removeModule(address _module) external onlyOwner {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',12);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',282);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',14);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',34);\nrequire(modulesToData[_module].isArchived, \"Not archived\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',14);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',283);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',15);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',35);\nrequire(modulesToData[_module].module != address(0), \"Module missing\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',15);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',285);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',36);\nemit ModuleRemoved(modulesToData[_module].moduleTypes, _module, now);\n        // Remove from module type list\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',287);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',37);\nuint8[] memory moduleTypes = modulesToData[_module].moduleTypes;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',288);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',38);\nfor (uint256 i = 0; i < moduleTypes.length; i++) {\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',289);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',39);\n_removeModuleWithIndex(moduleTypes[i], modulesToData[_module].moduleIndexes[i]);\n            /* modulesToData[_module].moduleType[moduleTypes[i]] = false; */\n        }\n        // Remove from module names list\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',293);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',40);\nuint256 index = modulesToData[_module].nameIndex;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',294);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',41);\nbytes32 name = modulesToData[_module].name;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',295);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',42);\nuint256 length = names[name].length;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',296);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',43);\nnames[name][index] = names[name][length - 1];\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',297);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',44);\nnames[name].length = length - 1;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',298);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',45);\nif ((length - 1) != index) {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',16,0);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',299);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',46);\nmodulesToData[names[name][index]].nameIndex = index;\n        }else { emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',16,1);}\n\n        // Remove from modulesToData\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',302);\n        delete modulesToData[_module];\n    }\n\n    /**\n    * @notice Internal - Removes a module attached to the SecurityToken by index\n    */\n    function _removeModuleWithIndex(uint8 _type, uint256 _index) internal {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',13);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',309);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',47);\nuint256 length = modules[_type].length;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',310);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',48);\nmodules[_type][_index] = modules[_type][length - 1];\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',311);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',49);\nmodules[_type].length = length - 1;\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',313);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',50);\nif ((length - 1) != _index) {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',17,0);\n            //Need to find index of _type in moduleTypes of module we are moving\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',315);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',51);\nuint8[] memory newTypes = modulesToData[modules[_type][_index]].moduleTypes;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',316);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',52);\nfor (uint256 i = 0; i < newTypes.length; i++) {\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',317);\n                emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',53);\nif (newTypes[i] == _type) {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',18,0);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',318);\n                    emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',54);\nmodulesToData[modules[_type][_index]].moduleIndexes[i] = _index;\n                }else { emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',18,1);}\n\n            }\n        }else { emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',17,1);}\n\n    }\n\n    /**\n     * @notice Returns the data associated to a module\n     * @param _module address of the module\n     * @return bytes32 name\n     * @return address module address\n     * @return address module factory address\n     * @return bool module archived\n     * @return uint8 module type\n     */\n    function getModule(address _module) external  returns (bytes32, address, address, bool, uint8[]) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',14);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',334);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',55);\nreturn (modulesToData[_module].name,\n        modulesToData[_module].module,\n        modulesToData[_module].moduleFactory,\n        modulesToData[_module].isArchived,\n        modulesToData[_module].moduleTypes);\n    }\n\n    /**\n     * @notice Returns a list of modules that match the provided name\n     * @param _name name of the module\n     * @return address[] list of modules with this name\n     */\n    function getModulesByName(bytes32 _name) external  returns (address[]) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',15);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',347);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',56);\nreturn names[_name];\n    }\n\n    /**\n     * @notice Returns a list of modules that match the provided module type\n     * @param _type type of the module\n     * @return address[] list of modules with this type\n     */\n    function getModulesByType(uint8 _type) external  returns (address[]) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',16);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',356);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',57);\nreturn modules[_type];\n    }\n\n   /**\n    * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\n    * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\n    * @param _tokenContract Address of the ERC20Basic compliance token\n    * @param _value amount of POLY to withdraw\n    */\n    function withdrawERC20(address _tokenContract, uint256 _value) external onlyOwner {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',17);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',366);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',19);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',58);\nrequire(_tokenContract != address(0));emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',19);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',367);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',59);\nIERC20 token = IERC20(_tokenContract);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',368);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',20);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',60);\nrequire(token.transfer(owner, _value));emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',20);\n\n    }\n\n    /**\n\n    * @notice allows owner to increase/decrease POLY approval of one of the modules\n    * @param _module module address\n    * @param _change change in allowance\n    * @param _increase true if budget has to be increased, false if decrease\n    */\n    function changeModuleBudget(address _module, uint256 _change, bool _increase) external onlyOwner {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',18);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',379);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',21);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',61);\nrequire(modulesToData[_module].module != address(0), \"Module missing\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',21);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',380);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',62);\nuint256 currentAllowance = IERC20(polyToken).allowance(address(this), _module);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',381);\n        uint256 newAllowance;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',382);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',63);\nif (_increase) {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',22,0);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',383);\n            emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',23);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',64);\nrequire(IERC20(polyToken).increaseApproval(_module, _change), \"IncreaseApproval fail\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',23);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',384);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',65);\nnewAllowance = currentAllowance.add(_change);\n        } else {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',22,1);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',386);\n            emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',24);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',66);\nrequire(IERC20(polyToken).decreaseApproval(_module, _change), \"Insufficient allowance\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',24);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',387);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',67);\nnewAllowance = currentAllowance.sub(_change);\n        }\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',389);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',68);\nemit ModuleBudgetChanged(modulesToData[_module].moduleTypes, _module, currentAllowance, newAllowance);\n    }\n\n    /**\n     * @notice updates the tokenDetails associated with the token\n     * @param _newTokenDetails New token details\n     */\n    function updateTokenDetails(string _newTokenDetails) external onlyOwner {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',19);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',397);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',69);\nemit UpdateTokenDetails(tokenDetails, _newTokenDetails);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',398);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',70);\ntokenDetails = _newTokenDetails;\n    }\n\n    /**\n    * @notice Allows owner to change token granularity\n    * @param _granularity granularity level of the token\n    */\n    function changeGranularity(uint256 _granularity) external onlyOwner {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',20);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',406);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',25);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',71);\nrequire(_granularity != 0, \"Invalid granularity\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',25);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',407);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',72);\nemit GranularityChanged(granularity, _granularity);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',408);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',73);\ngranularity = _granularity;\n    }\n\n    /**\n    * @notice Keeps track of the number of non-zero token holders\n    * @param _from sender of transfer\n    * @param _to receiver of transfer\n    * @param _value value of transfer\n    */\n    function _adjustInvestorCount(address _from, address _to, uint256 _value) internal {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',21);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',418);\n        TokenLib.adjustInvestorCount(investorData, _from, _to, _value, balanceOf(_to), balanceOf(_from));\n    }\n\n    /**\n     * @notice returns an array of investors\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\n     * @return list of addresses\n     */\n    function getInvestors() external  returns(address[]) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',22);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',427);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',74);\nreturn investorData.investors;\n    }\n\n    /**\n     * @notice returns an array of investors at a given checkpoint\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\n     * @return list of investors\n     */\n    function getInvestorsAt(uint256 _checkpointId) external  returns(address[]) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',23);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',437);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',75);\nuint256 count = 0;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',438);\n        uint256 i;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',439);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',76);\nfor (i = 0; i < investorData.investors.length; i++) {\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',440);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',77);\nif (balanceOfAt(investorData.investors[i], _checkpointId) > 0) {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',26,0);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',441);\n                count++;\n            }else { emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',26,1);}\n\n        }\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',444);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',78);\naddress[] memory investors = new address[](count);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',445);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',79);\ncount = 0;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',446);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',80);\nfor (i = 0; i < investorData.investors.length; i++) {\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',447);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',81);\nif (balanceOfAt(investorData.investors[i], _checkpointId) > 0) {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',27,0);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',448);\n                emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',82);\ninvestors[count] = investorData.investors[i];\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',449);\n                count++;\n            }else { emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',27,1);}\n\n        }\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',452);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',83);\nreturn investors;\n    }\n\n    /**\n     * @notice generates subset of investors\n     * NB - can be used in batches if investor list is large\n     * @param _start Position of investor to start iteration from\n     * @param _end Position of investor to stop iteration at\n     * @return list of investors\n     */\n    function iterateInvestors(uint256 _start, uint256 _end) external  returns(address[]) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',24);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',463);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',28);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',84);\nrequire(_end <= investorData.investors.length, \"Invalid end\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',28);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',464);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',85);\naddress[] memory investors = new address[](_end.sub(_start));\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',465);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',86);\nuint256 index = 0;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',466);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',87);\nfor (uint256 i = _start; i < _end; i++) {\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',467);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',88);\ninvestors[index] = investorData.investors[i];\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',468);\n            index++;\n        }\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',470);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',89);\nreturn investors;\n    }\n\n    /**\n     * @notice Returns the investor count\n     * @return Investor count\n     */\n    function getInvestorCount() external  returns(uint256) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',25);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',478);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',90);\nreturn investorData.investorCount;\n    }\n\n    /**\n     * @notice freezes transfers\n     */\n    function freezeTransfers() external onlyOwner {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',26);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',485);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',29);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',91);\nrequire(!transfersFrozen, \"Already frozen\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',29);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',486);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',92);\ntransfersFrozen = true;\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',488);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',93);\nemit FreezeTransfers(true, now);\n    }\n\n    /**\n     * @notice Unfreeze transfers\n     */\n    function unfreezeTransfers() external onlyOwner {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',27);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',495);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',30);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',94);\nrequire(transfersFrozen, \"Not frozen\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',30);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',496);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',95);\ntransfersFrozen = false;\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',498);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',96);\nemit FreezeTransfers(false, now);\n    }\n\n    /**\n     * @notice Internal - adjusts totalSupply at checkpoint after minting or burning tokens\n     */\n    function _adjustTotalSupplyCheckpoints() internal {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',28);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',505);\n        TokenLib.adjustCheckpoints(checkpointTotalSupply, totalSupply(), currentCheckpointId);\n    }\n\n    /**\n     * @notice Internal - adjusts token holder balance at checkpoint after a token transfer\n     * @param _investor address of the token holder affected\n     */\n    function _adjustBalanceCheckpoints(address _investor) internal {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',29);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',513);\n        TokenLib.adjustCheckpoints(checkpointBalances[_investor], balanceOf(_investor), currentCheckpointId);\n    }\n\n    /**\n     * @notice Overloaded version of the transfer function\n     * @param _to receiver of transfer\n     * @param _value value of transfer\n     * @return bool success\n     */\n    function transfer(address _to, uint256 _value) public returns (bool success) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',30);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',523);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',97);\nreturn transferWithData(_to, _value, \"\");\n    }\n\n    /**\n     * @notice Overloaded version of the transfer function\n     * @param _to receiver of transfer\n     * @param _value value of transfer\n     * @param _data data to indicate validation\n     * @return bool success\n     */\n    function transferWithData(address _to, uint256 _value, bytes _data) public returns (bool success) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',31);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',534);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',31);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',98);\nrequire(_updateTransfer(msg.sender, _to, _value, _data), \"Transfer invalid\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',31);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',535);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',32);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',99);\nrequire(super.transfer(_to, _value));emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',32);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',536);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',100);\nreturn true;\n    }\n\n    /**\n     * @notice Overloaded version of the transferFrom function\n     * @param _from sender of transfer\n     * @param _to receiver of transfer\n     * @param _value value of transfer\n     * @return bool success\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',32);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',547);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',101);\nreturn transferFromWithData(_from, _to, _value, \"\");\n    }\n\n    /**\n     * @notice Overloaded version of the transferFrom function\n     * @param _from sender of transfer\n     * @param _to receiver of transfer\n     * @param _value value of transfer\n     * @param _data data to indicate validation\n     * @return bool success\n     */\n    function transferFromWithData(address _from, address _to, uint256 _value, bytes _data) public returns(bool) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',33);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',559);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',33);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',102);\nrequire(_updateTransfer(_from, _to, _value, _data), \"Transfer invalid\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',33);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',560);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',34);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',103);\nrequire(super.transferFrom(_from, _to, _value));emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',34);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',561);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',104);\nreturn true;\n    }\n\n    /**\n     * @notice Updates internal variables when performing a transfer\n     * @param _from sender of transfer\n     * @param _to receiver of transfer\n     * @param _value value of transfer\n     * @param _data data to indicate validation\n     * @return bool success\n     */\n    function _updateTransfer(address _from, address _to, uint256 _value, bytes _data) internal nonReentrant returns(bool) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',34);\n\n        // NB - the ordering in this function implies the following:\n        //  - investor counts are updated before transfer managers are called - i.e. transfer managers will see\n        //investor counts including the current transfer.\n        //  - checkpoints are updated after the transfer managers are called. This allows TMs to create\n        //checkpoints as though they have been created before the current transactions,\n        //  - to avoid the situation where a transfer manager transfers tokens, and this function is called recursively,\n        //the function is marked as nonReentrant. This means that no TM can transfer (or mint / burn) tokens.\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',580);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',105);\n_adjustInvestorCount(_from, _to, _value);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',581);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',106);\nbool verified = _verifyTransfer(_from, _to, _value, _data, true);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',582);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',107);\n_adjustBalanceCheckpoints(_from);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',583);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',108);\n_adjustBalanceCheckpoints(_to);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',584);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',109);\nreturn verified;\n    }\n\n    /**\n     * @notice Validate transfer with TransferManager module if it exists\n     * @dev TransferManager module has a key of 2\n     * @dev _isTransfer boolean flag is the deciding factor for whether the\n     * state variables gets modified or not within the different modules. i.e isTransfer = true\n     * leads to change in the modules environment otherwise _verifyTransfer() works as a read-only\n     * function (no change in the state).\n     * @param _from sender of transfer\n     * @param _to receiver of transfer\n     * @param _value value of transfer\n     * @param _data data to indicate validation\n     * @param _isTransfer whether transfer is being executed\n     * @return bool\n     */\n    function _verifyTransfer(\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes _data,\n        bool _isTransfer\n    ) internal checkGranularity(_value) returns (bool) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',35);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',608);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',110);\nif (!transfersFrozen) {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',35,0);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',609);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',111);\nbool isInvalid = false;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',610);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',112);\nbool isValid = false;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',611);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',113);\nbool isForceValid = false;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',612);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',114);\nbool unarchived = false;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',613);\n            address module;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',614);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',115);\nfor (uint256 i = 0; i < modules[TRANSFER_KEY].length; i++) {\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',615);\n                emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',116);\nmodule = modules[TRANSFER_KEY][i];\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',616);\n                emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',117);\nif (!modulesToData[module].isArchived) {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',36,0);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',617);\n                    emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',118);\nunarchived = true;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',618);\n                    emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',119);\nITransferManager.Result valid = ITransferManager(module).verifyTransfer(_from, _to, _value, _data, _isTransfer);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',619);\n                    emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',120);\nif (valid == ITransferManager.Result.INVALID) {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',37,0);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',620);\n                        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',121);\nisInvalid = true;\n                    } else {emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',122);\nemit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',37,1);if (valid == ITransferManager.Result.VALID) {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',38,0);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',622);\n                        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',123);\nisValid = true;\n                    } else {emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',124);\nemit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',38,1);if (valid == ITransferManager.Result.FORCE_VALID) {emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',39,0);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',624);\n                        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',125);\nisForceValid = true;\n                    }else { emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',39,1);}\n}}\n                }else { emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',36,1);}\n\n            }\n            // If no unarchived modules, return true by default\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',629);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',126);\nreturn unarchived ? (isForceValid ? true : (isInvalid ? false : isValid)) : true;\n        }else { emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',35,1);}\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',631);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',127);\nreturn false;\n    }\n\n    /**\n     * @notice Validates a transfer with a TransferManager module if it exists\n     * @dev TransferManager module has a key of 2\n     * @param _from sender of transfer\n     * @param _to receiver of transfer\n     * @param _value value of transfer\n     * @param _data data to indicate validation\n     * @return bool\n     */\n    function verifyTransfer(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',36);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',644);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',128);\nreturn _verifyTransfer(_from, _to, _value, _data, false);\n    }\n\n    /**\n     * @notice Permanently freeze minting of this security token.\n     * @dev It MUST NOT be possible to increase `totalSuppy` after this function is called.\n     */\n    function freezeMinting() external isMintingAllowed() isEnabled(\"freezeMintingAllowed\") onlyOwner {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',37);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',652);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',129);\nmintingFrozen = true;\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',654);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',130);\nemit FreezeMinting(now);\n    }\n\n    /**\n     * @notice Mints new tokens and assigns them to the target _investor.\n     * @dev Can only be called by the issuer or STO attached to the token\n     * @param _investor Address where the minted tokens will be delivered\n     * @param _value Number of tokens be minted\n     * @return success\n     */\n    function mint(address _investor, uint256 _value) public returns (bool success) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',38);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',665);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',131);\nreturn mintWithData(_investor, _value, \"\");\n    }\n\n    /**\n     * @notice mints new tokens and assigns them to the target _investor.\n     * @dev Can only be called by the issuer or STO attached to the token\n     * @param _investor Address where the minted tokens will be delivered\n     * @param _value Number of tokens be minted\n     * @param _data data to indicate validation\n     * @return success\n     */\n    function mintWithData(\n        address _investor,\n        uint256 _value,\n        bytes _data\n        ) public onlyModuleOrOwner(MINT_KEY) isMintingAllowed() returns (bool success) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',39);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',681);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',40);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',132);\nrequire(_investor != address(0), \"Investor is 0\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',40);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',682);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',41);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',133);\nrequire(_updateTransfer(address(0), _investor, _value, _data), \"Transfer invalid\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',41);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',683);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',134);\n_adjustTotalSupplyCheckpoints();\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',684);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',135);\ntotalSupply_ = totalSupply_.add(_value);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',685);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',136);\nbalances[_investor] = balances[_investor].add(_value);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',686);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',137);\nemit Minted(_investor, _value);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',687);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',138);\nemit Transfer(address(0), _investor, _value);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',688);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',139);\nreturn true;\n    }\n\n    /**\n     * @notice Mints new tokens and assigns them to the target _investor.\n     * @dev Can only be called by the issuer or STO attached to the token.\n     * @param _investors A list of addresses to whom the minted tokens will be dilivered\n     * @param _values A list of number of tokens get minted and transfer to corresponding address of the investor from _investor[] list\n     * @return success\n     */\n    function mintMulti(address[] _investors, uint256[] _values) external returns (bool success) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',40);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',699);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',42);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',140);\nrequire(_investors.length == _values.length, \"Incorrect inputs\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',42);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',700);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',141);\nfor (uint256 i = 0; i < _investors.length; i++) {\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',701);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',142);\nmint(_investors[i], _values[i]);\n        }\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',703);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',143);\nreturn true;\n    }\n\n    /**\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n     * @param _delegate address of delegate\n     * @param _module address of PermissionManager module\n     * @param _perm the permissions\n     * @return success\n     */\n    function checkPermission(address _delegate, address _module, bytes32 _perm) public  returns(bool) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',41);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',716);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',144);\nfor (uint256 i = 0; i < modules[PERMISSION_KEY].length; i++) {\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',717);\n            emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',145);\nif (!modulesToData[modules[PERMISSION_KEY][i]].isArchived)\n                {emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',146);\nemit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',43,0);emit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',718);\nreturn TokenLib.checkPermission(modules[PERMISSION_KEY], _delegate, _module, _perm);}else { emit __BranchCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',43,1);}\n\n        }\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',720);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',147);\nreturn false;\n    }\n\n    function _burn(address _from, uint256 _value, bytes _data) internal returns(bool) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',42);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',724);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',44);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',148);\nrequire(_value <= balances[_from], \"Value too high\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',44);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',725);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',149);\nbool verified = _updateTransfer(_from, address(0), _value, _data);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',726);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',150);\n_adjustTotalSupplyCheckpoints();\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',727);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',151);\nbalances[_from] = balances[_from].sub(_value);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',728);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',152);\ntotalSupply_ = totalSupply_.sub(_value);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',729);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',153);\nemit Burnt(_from, _value);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',730);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',154);\nemit Transfer(_from, address(0), _value);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',731);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',155);\nreturn verified;\n    }\n\n    /**\n     * @notice Burn function used to burn the securityToken\n     * @param _value No. of tokens that get burned\n     * @param _data data to indicate validation\n     */\n    function burnWithData(uint256 _value, bytes _data) public onlyModule(BURN_KEY) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',43);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',740);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',45);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',156);\nrequire(_burn(msg.sender, _value, _data), \"Burn invalid\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',45);\n\n    }\n\n    /**\n     * @notice Burn function used to burn the securityToken on behalf of someone else\n     * @param _from Address for whom to burn tokens\n     * @param _value No. of tokens that get burned\n     * @param _data data to indicate validation\n     */\n    function burnFromWithData(address _from, uint256 _value, bytes _data) public onlyModule(BURN_KEY) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',44);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',750);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',46);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',157);\nrequire(_value <= allowed[_from][msg.sender], \"Value too high\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',46);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',751);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',158);\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',752);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',47);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',159);\nrequire(_burn(_from, _value, _data), \"Burn invalid\");emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',47);\n\n    }\n\n    /**\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\n     * @return uint256\n     */\n    function createCheckpoint() external onlyModuleOrOwner(CHECKPOINT_KEY) returns(uint256) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',45);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',760);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',48);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',160);\nrequire(currentCheckpointId < 2**256 - 1);emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',48);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',761);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',161);\ncurrentCheckpointId = currentCheckpointId + 1;\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',763);\n        checkpointTimes.push(now);\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',765);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',162);\nemit CheckpointCreated(currentCheckpointId, now);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',766);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',163);\nreturn currentCheckpointId;\n    }\n\n    /**\n     * @notice Gets list of times that checkpoints were created\n     * @return List of checkpoint times\n     */\n    function getCheckpointTimes() external  returns(uint256[]) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',46);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',774);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',164);\nreturn checkpointTimes;\n    }\n\n    /**\n     * @notice Queries totalSupply as of a defined checkpoint\n     * @param _checkpointId Checkpoint ID to query\n     * @return uint256\n     */\n    function totalSupplyAt(uint256 _checkpointId) external  returns(uint256) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',47);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',783);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',49);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',165);\nrequire(_checkpointId <= currentCheckpointId);emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',49);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',784);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',166);\nreturn TokenLib.getValueAt(checkpointTotalSupply, _checkpointId, totalSupply());\n    }\n\n    /**\n     * @notice Queries balances as of a defined checkpoint\n     * @param _investor Investor to query balance for\n     * @param _checkpointId Checkpoint ID to query as of\n     */\n    function balanceOfAt(address _investor, uint256 _checkpointId) public  returns(uint256) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',48);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',793);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',50);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',167);\nrequire(_checkpointId <= currentCheckpointId);emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',50);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',794);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',168);\nreturn TokenLib.getValueAt(checkpointBalances[_investor], _checkpointId, balanceOf(_investor));\n    }\n\n    /**\n     * @notice Used by the issuer to set the controller addresses\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) public onlyOwner {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',49);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',802);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',51);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',169);\nrequire(!controllerDisabled);emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',51);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',803);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',170);\nemit SetController(controller, _controller);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',804);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',171);\ncontroller = _controller;\n    }\n\n    /**\n     * @notice Used by the issuer to permanently disable controller functionality\n     * @dev enabled via feature switch \"disableControllerAllowed\"\n     */\n    function disableController() external isEnabled(\"disableControllerAllowed\") onlyOwner {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',50);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',812);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',52);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',172);\nrequire(!controllerDisabled);emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',52);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',813);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',173);\ncontrollerDisabled = true;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',814);\n        delete controller;\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',816);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',174);\nemit DisableController(now);\n    }\n\n    /**\n     * @notice Used by a controller to execute a forced transfer\n     * @param _from address from which to take tokens\n     * @param _to address where to send tokens\n     * @param _value amount of tokens to transfer\n     * @param _data data to indicate validation\n     * @param _log data attached to the transfer by controller to emit in event\n     */\n    function forceTransfer(address _from, address _to, uint256 _value, bytes _data, bytes _log) public onlyController {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',51);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',828);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',53);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',175);\nrequire(_to != address(0));emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',53);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',829);\n        emit __AssertPreCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',54);\nemit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',176);\nrequire(_value <= balances[_from]);emit __AssertPostCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',54);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',830);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',177);\nbool verified = _updateTransfer(_from, _to, _value, _data);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',831);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',178);\nbalances[_from] = balances[_from].sub(_value);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',832);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',179);\nbalances[_to] = balances[_to].add(_value);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',833);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',180);\nemit ForceTransfer(msg.sender, _from, _to, _value, verified, _log);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',834);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',181);\nemit Transfer(_from, _to, _value);\n    }\n\n    /**\n     * @notice Used by a controller to execute a forced burn\n     * @param _from address from which to take tokens\n     * @param _value amount of tokens to transfer\n     * @param _data data to indicate validation\n     * @param _log data attached to the transfer by controller to emit in event\n     */\n    function forceBurn(address _from, uint256 _value, bytes _data, bytes _log) public onlyController {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',52);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',845);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',182);\nbool verified = _burn(_from, _value, _data);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',846);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',183);\nemit ForceBurn(msg.sender, _from, _value, verified, _log);\n    }\n\n    /**\n     * @notice Returns the version of the SecurityToken\n     */\n    function getVersion() external  returns(uint8[]) {emit __FunctionCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',53);\n\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',853);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',184);\nuint8[] memory _version = new uint8[](3);\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',854);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',185);\n_version[0] = securityTokenVersion.major;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',855);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',186);\n_version[1] = securityTokenVersion.minor;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',856);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',187);\n_version[2] = securityTokenVersion.patch;\nemit __CoverageSecurityToken('./contracts/tokens/SecurityToken.sol',857);\n        emit __StatementCoverageSecurityToken('./contracts/tokens/SecurityToken.sol',188);\nreturn _version;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/tokens/STFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./SecurityToken.sol\";\nimport \"../interfaces/ISTFactory.sol\";\n\n/**\n * @title Proxy for deploying SecurityToken instances\n */\ncontract STFactory is ISTFactory {event __CoverageSTFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageSTFactory(string fileName, uint256 fnId);\nevent __StatementCoverageSTFactory(string fileName, uint256 statementId);\nevent __BranchCoverageSTFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageSTFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageSTFactory(string fileName, uint256 branchId);\n\n\n    address public transferManagerFactory;\n\n    constructor (address _transferManagerFactory) public {emit __FunctionCoverageSTFactory('./contracts/tokens/STFactory.sol',1);\n\nemit __CoverageSTFactory('./contracts/tokens/STFactory.sol',14);\n        emit __StatementCoverageSTFactory('./contracts/tokens/STFactory.sol',1);\ntransferManagerFactory = _transferManagerFactory;\n    }\n\n    /**\n     * @notice deploys the token and adds default modules like the GeneralTransferManager.\n     * Future versions of the proxy can attach different modules or pass different parameters.\n     */\n    function deployToken(\n        string _name,\n        string _symbol,\n        uint8 _decimals,\n        string _tokenDetails,\n        address _issuer,\n        bool _divisible,\n        address _polymathRegistry\n        ) external returns (address) {emit __FunctionCoverageSTFactory('./contracts/tokens/STFactory.sol',2);\n\nemit __CoverageSTFactory('./contracts/tokens/STFactory.sol',30);\n        emit __StatementCoverageSTFactory('./contracts/tokens/STFactory.sol',2);\naddress newSecurityTokenAddress = new SecurityToken(\n            _name,\n            _symbol,\n            _decimals,\n            _divisible ? 1 : uint256(10)**_decimals,\n            _tokenDetails,\n            _polymathRegistry\n        );\nemit __CoverageSTFactory('./contracts/tokens/STFactory.sol',38);\n        emit __StatementCoverageSTFactory('./contracts/tokens/STFactory.sol',3);\nSecurityToken(newSecurityTokenAddress).addModule(transferManagerFactory, \"\", 0, 0);\nemit __CoverageSTFactory('./contracts/tokens/STFactory.sol',39);\n        emit __StatementCoverageSTFactory('./contracts/tokens/STFactory.sol',4);\nSecurityToken(newSecurityTokenAddress).transferOwnership(_issuer);\nemit __CoverageSTFactory('./contracts/tokens/STFactory.sol',40);\n        emit __StatementCoverageSTFactory('./contracts/tokens/STFactory.sol',5);\nreturn newSecurityTokenAddress;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/interfaces/ISTFactory.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Interface for security token proxy deployment\n */\ninterface ISTFactory {event __CoverageISTFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageISTFactory(string fileName, uint256 fnId);\nevent __StatementCoverageISTFactory(string fileName, uint256 statementId);\nevent __BranchCoverageISTFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageISTFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageISTFactory(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice Deploys the token and adds default modules like permission manager and transfer manager.\n     * Future versions of the proxy can attach different modules or pass some other paramters.\n     * @param _name is the name of the Security token\n     * @param _symbol is the symbol of the Security Token\n     * @param _decimals is the number of decimals of the Security Token\n     * @param _tokenDetails is the off-chain data associated with the Security Token\n     * @param _issuer is the owner of the Security Token\n     * @param _divisible whether the token is divisible or not\n     * @param _polymathRegistry is the address of the Polymath Registry contract\n     */\n    function deployToken(\n        string _name,\n        string _symbol,\n        uint8 _decimals,\n        string _tokenDetails,\n        address _issuer,\n        bool _divisible,\n        address _polymathRegistry\n    )\n        external\n        returns (address);\n}\n"},"openzeppelin-solidity/contracts/math/Math.sol":{"content":"pragma solidity ^0.4.23;\n\n\n/**\n * @title Math\n * @dev Assorted math operations\n */\nlibrary Math {\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n}\n"},"openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol":{"content":"pragma solidity ^0.4.23;\n\nimport \"./BasicToken.sol\";\nimport \"./ERC20.sol\";\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n"},"openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol":{"content":"pragma solidity ^0.4.23;\n\n\nimport \"./ERC20Basic.sol\";\nimport \"../../math/SafeMath.sol\";\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n"},"openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol":{"content":"pragma solidity ^0.4.23;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n"},"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol":{"content":"pragma solidity ^0.4.23;\n\nimport \"./ERC20Basic.sol\";\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n"},"openzeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol":{"content":"pragma solidity ^0.4.23;\n\nimport \"./ERC20.sol\";\n\n\n/**\n * @title DetailedERC20 token\n * @dev The decimals are only for visualization purposes.\n * All the operations are done using the smallest and indivisible token unit,\n * just as on Ethereum all the operations are done in wei.\n */\ncontract DetailedERC20 is ERC20 {\n  string public name;\n  string public symbol;\n  uint8 public decimals;\n\n  constructor(string _name, string _symbol, uint8 _decimals) public {\n    name = _name;\n    symbol = _symbol;\n    decimals = _decimals;\n  }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/libraries/TokenLib.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../modules/PermissionManager/IPermissionManager.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nlibrary TokenLib {event __CoverageTokenLib(string fileName, uint256 lineNumber);\nevent __FunctionCoverageTokenLib(string fileName, uint256 fnId);\nevent __StatementCoverageTokenLib(string fileName, uint256 statementId);\nevent __BranchCoverageTokenLib(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageTokenLib(string fileName, uint256 branchId);\nevent __AssertPostCoverageTokenLib(string fileName, uint256 branchId);\n\n\n    using SafeMath for uint256;\n\n    // Struct for module data\n    struct ModuleData {\n        bytes32 name;\n        address module;\n        address moduleFactory;\n        bool isArchived;\n        uint8[] moduleTypes;\n        uint256[] moduleIndexes;\n        uint256 nameIndex;\n    }\n\n    // Structures to maintain checkpoints of balances for governance / dividends\n    struct Checkpoint {\n        uint256 checkpointId;\n        uint256 value;\n    }\n\n    struct InvestorDataStorage {\n        // List of investors who have ever held a non-zero token balance\n        mapping (address => bool) investorListed;\n        // List of token holders\n        address[] investors;\n        // Total number of non-zero token holders\n        uint256 investorCount;\n    }\n\n    // Emit when Module is archived from the SecurityToken\n    event ModuleArchived(uint8[] _types, address _module, uint256 _timestamp);\n    // Emit when Module is unarchived from the SecurityToken\n    event ModuleUnarchived(uint8[] _types, address _module, uint256 _timestamp);\n\n    /**\n    * @notice Archives a module attached to the SecurityToken\n    * @param _moduleData Storage data\n    * @param _module Address of module to archive\n    */\n    function archiveModule(ModuleData storage _moduleData, address _module) public {emit __FunctionCoverageTokenLib('./contracts/libraries/TokenLib.sol',1);\n\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',47);\n        emit __AssertPreCoverageTokenLib('./contracts/libraries/TokenLib.sol',1);\nemit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',1);\nrequire(!_moduleData.isArchived, \"Module archived\");emit __AssertPostCoverageTokenLib('./contracts/libraries/TokenLib.sol',1);\n\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',48);\n        emit __AssertPreCoverageTokenLib('./contracts/libraries/TokenLib.sol',2);\nemit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',2);\nrequire(_moduleData.module != address(0), \"Module missing\");emit __AssertPostCoverageTokenLib('./contracts/libraries/TokenLib.sol',2);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',50);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',3);\nemit ModuleArchived(_moduleData.moduleTypes, _module, now);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',51);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',4);\n_moduleData.isArchived = true;\n    }\n\n    /**\n    * @notice Unarchives a module attached to the SecurityToken\n    * @param _moduleData Storage data\n    * @param _module Address of module to unarchive\n    */\n    function unarchiveModule(ModuleData storage _moduleData, address _module) public {emit __FunctionCoverageTokenLib('./contracts/libraries/TokenLib.sol',2);\n\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',60);\n        emit __AssertPreCoverageTokenLib('./contracts/libraries/TokenLib.sol',3);\nemit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',5);\nrequire(_moduleData.isArchived, \"Module unarchived\");emit __AssertPostCoverageTokenLib('./contracts/libraries/TokenLib.sol',3);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',62);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',6);\nemit ModuleUnarchived(_moduleData.moduleTypes, _module, now);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',63);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',7);\n_moduleData.isArchived = false;\n    }\n\n    /**\n     * @notice Validates permissions with PermissionManager if it exists. If there's no permission return false\n     * @dev Note that IModule withPerm will allow ST owner all permissions by default\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n     * @param _modules is the modules to check permissions on\n     * @param _delegate is the address of the delegate\n     * @param _module is the address of the PermissionManager module\n     * @param _perm is the permissions data\n     * @return success\n     */\n    function checkPermission(address[] storage _modules, address _delegate, address _module, bytes32 _perm) public  returns(bool) {emit __FunctionCoverageTokenLib('./contracts/libraries/TokenLib.sol',3);\n\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',77);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',8);\nif (_modules.length == 0) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',4,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',78);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',9);\nreturn false;\n        }else { emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',4,1);}\n\n\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',81);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',10);\nfor (uint8 i = 0; i < _modules.length; i++) {\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',82);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',11);\nif (IPermissionManager(_modules[i]).checkPermission(_delegate, _module, _perm)) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',5,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',83);\n                emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',12);\nreturn true;\n            }else { emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',5,1);}\n\n        }\n\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',87);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',13);\nreturn false;\n    }\n\n    /**\n     * @notice Queries a value at a defined checkpoint\n     * @param _checkpoints is array of Checkpoint objects\n     * @param _checkpointId is the Checkpoint ID to query\n     * @param _currentValue is the Current value of checkpoint\n     * @return uint256\n     */\n    function getValueAt(Checkpoint[] storage _checkpoints, uint256 _checkpointId, uint256 _currentValue) public  returns(uint256) {emit __FunctionCoverageTokenLib('./contracts/libraries/TokenLib.sol',4);\n\n        //Checkpoint id 0 is when the token is first created - everyone has a zero balance\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',99);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',14);\nif (_checkpointId == 0) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',6,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',100);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',15);\nreturn 0;\n        }else { emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',6,1);}\n\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',102);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',16);\nif (_checkpoints.length == 0) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',7,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',103);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',17);\nreturn _currentValue;\n        }else { emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',7,1);}\n\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',105);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',18);\nif (_checkpoints[0].checkpointId >= _checkpointId) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',8,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',106);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',19);\nreturn _checkpoints[0].value;\n        }else { emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',8,1);}\n\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',108);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',20);\nif (_checkpoints[_checkpoints.length - 1].checkpointId < _checkpointId) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',9,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',109);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',21);\nreturn _currentValue;\n        }else { emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',9,1);}\n\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',111);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',22);\nif (_checkpoints[_checkpoints.length - 1].checkpointId == _checkpointId) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',10,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',112);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',23);\nreturn _checkpoints[_checkpoints.length - 1].value;\n        }else { emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',10,1);}\n\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',114);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',24);\nuint256 min = 0;\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',115);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',25);\nuint256 max = _checkpoints.length - 1;\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',116);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',26);\nwhile (max > min) {\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',117);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',27);\nuint256 mid = (max + min) / 2;\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',118);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',28);\nif (_checkpoints[mid].checkpointId == _checkpointId) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',11,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',119);\n                emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',29);\nmax = mid;\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',120);\n                break;\n            }else { emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',11,1);}\n\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',122);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',30);\nif (_checkpoints[mid].checkpointId < _checkpointId) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',12,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',123);\n                emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',31);\nmin = mid + 1;\n            } else {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',12,1);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',125);\n                emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',32);\nmax = mid;\n            }\n        }\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',128);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',33);\nreturn _checkpoints[max].value;\n    }\n\n    /**\n     * @notice Stores the changes to the checkpoint objects\n     * @param _checkpoints is the affected checkpoint object array\n     * @param _newValue is the new value that needs to be stored\n     */\n    function adjustCheckpoints(TokenLib.Checkpoint[] storage _checkpoints, uint256 _newValue, uint256 _currentCheckpointId) public {emit __FunctionCoverageTokenLib('./contracts/libraries/TokenLib.sol',5);\n\n        //No checkpoints set yet\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',138);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',34);\nif (_currentCheckpointId == 0) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',13,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',139);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',35);\nreturn;\n        }else { emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',13,1);}\n\n        //No new checkpoints since last update\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',142);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',36);\nif ((_checkpoints.length > 0) && (_checkpoints[_checkpoints.length - 1].checkpointId == _currentCheckpointId)) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',14,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',143);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',37);\nreturn;\n        }else { emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',14,1);}\n\n        //New checkpoint, so record balance\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',146);\n        _checkpoints.push(\n            TokenLib.Checkpoint({\n                checkpointId: _currentCheckpointId,\n                value: _newValue\n            })\n        );\n    }\n\n    /**\n    * @notice Keeps track of the number of non-zero token holders\n    * @param _investorData Date releated to investor metrics\n    * @param _from Sender of transfer\n    * @param _to Receiver of transfer\n    * @param _value Value of transfer\n    * @param _balanceTo Balance of the _to address\n    * @param _balanceFrom Balance of the _from address\n    */\n    function adjustInvestorCount(\n        InvestorDataStorage storage _investorData,\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _balanceTo,\n        uint256 _balanceFrom\n        ) public  {emit __FunctionCoverageTokenLib('./contracts/libraries/TokenLib.sol',6);\n\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',171);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',38);\nif ((_value == 0) || (_from == _to)) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',15,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',172);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',39);\nreturn;\n        }else { emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',15,1);}\n\n        // Check whether receiver is a new token holder\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',175);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',40);\nif ((_balanceTo == 0) && (_to != address(0))) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',16,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',176);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',41);\n_investorData.investorCount = (_investorData.investorCount).add(1);\n        }else { emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',16,1);}\n\n        // Check whether sender is moving all of their tokens\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',179);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',42);\nif (_value == _balanceFrom) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',17,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',180);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',43);\n_investorData.investorCount = (_investorData.investorCount).sub(1);\n        }else { emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',17,1);}\n\n        //Also adjust investor list\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',183);\n        emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',44);\nif (!_investorData.investorListed[_to] && (_to != address(0))) {emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',18,0);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',184);\n            _investorData.investors.push(_to);\nemit __CoverageTokenLib('./contracts/libraries/TokenLib.sol',185);\n            emit __StatementCoverageTokenLib('./contracts/libraries/TokenLib.sol',45);\n_investorData.investorListed[_to] = true;\n        }else { emit __BranchCoverageTokenLib('./contracts/libraries/TokenLib.sol',18,1);}\n\n\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/PermissionManager/IPermissionManager.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Interface to be implemented by all permission manager modules\n */\ninterface IPermissionManager {event __CoverageIPermissionManager(string fileName, uint256 lineNumber);\nevent __FunctionCoverageIPermissionManager(string fileName, uint256 fnId);\nevent __StatementCoverageIPermissionManager(string fileName, uint256 statementId);\nevent __BranchCoverageIPermissionManager(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageIPermissionManager(string fileName, uint256 branchId);\nevent __AssertPostCoverageIPermissionManager(string fileName, uint256 branchId);\n\n\n    /**\n    * @notice Used to check the permission on delegate corresponds to module contract address\n    * @param _delegate Ethereum address of the delegate\n    * @param _module Ethereum contract address of the module\n    * @param _perm Permission flag\n    * @return bool\n    */\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external  returns(bool);\n\n    /**\n    * @notice Used to add a delegate\n    * @param _delegate Ethereum address of the delegate\n    * @param _details Details about the delegate i.e `Belongs to financial firm`\n    */\n    function addDelegate(address _delegate, bytes32 _details) external;\n\n    /**\n    * @notice Used to delete a delegate\n    * @param _delegate Ethereum address of the delegate\n    */\n    function deleteDelegate(address _delegate) external;\n\n    /**\n    * @notice Used to check if an address is a delegate or not\n    * @param _potentialDelegate the address of potential delegate\n    * @return bool\n    */\n    function checkDelegate(address _potentialDelegate) external  returns(bool);\n\n    /**\n    * @notice Used to provide/change the permission to the delegate corresponds to the module contract\n    * @param _delegate Ethereum address of the delegate\n    * @param _module Ethereum contract address of the module\n    * @param _perm Permission flag\n    * @param _valid Bool flag use to switch on/off the permission\n    * @return bool\n    */\n    function changePermission(\n        address _delegate,\n        address _module,\n        bytes32 _perm,\n        bool _valid\n    )\n    external;\n\n    /**\n    * @notice Used to change one or more permissions for a single delegate at once\n    * @param _delegate Ethereum address of the delegate\n    * @param _modules Multiple module matching the multiperms, needs to be same length\n    * @param _perms Multiple permission flag needs to be changed\n    * @param _valids Bool array consist the flag to switch on/off the permission\n    * @return nothing\n    */\n    function changePermissionMulti(\n        address _delegate,\n        address[] _modules,\n        bytes32[] _perms,\n        bool[] _valids\n    )\n    external;\n\n    /**\n    * @notice Used to return all delegates with a given permission and module\n    * @param _module Ethereum contract address of the module\n    * @param _perm Permission flag\n    * @return address[]\n    */\n    function getAllDelegatesWithPerm(address _module, bytes32 _perm) external  returns(address[]);\n\n     /**\n    * @notice Used to return all permission of a single or multiple module\n    * @dev possible that function get out of gas is there are lot of modules and perm related to them\n    * @param _delegate Ethereum address of the delegate\n    * @param _types uint8[] of types\n    * @return address[] the address array of Modules this delegate has permission\n    * @return bytes32[] the permission array of the corresponding Modules\n    */\n    function getAllModulesAndPermsFromTypes(address _delegate, uint8[] _types) external  returns(address[], bytes32[]);\n\n    /**\n    * @notice Used to get the Permission flag related the `this` contract\n    * @return Array of permission flags\n    */\n    function getPermissions() external  returns(bytes32[]);\n\n    /**\n    * @notice Used to get all delegates\n    * @return address[]\n    */\n    function getAllDelegates() external  returns(address[]);\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/BlacklistTransferManager.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ITransferManager.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title Transfer Manager module to automate blacklist and restrict transfers\n */\ncontract BlacklistTransferManager is ITransferManager {event __CoverageBlacklistTransferManager(string fileName, uint256 lineNumber);\nevent __FunctionCoverageBlacklistTransferManager(string fileName, uint256 fnId);\nevent __StatementCoverageBlacklistTransferManager(string fileName, uint256 statementId);\nevent __BranchCoverageBlacklistTransferManager(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageBlacklistTransferManager(string fileName, uint256 branchId);\nevent __AssertPostCoverageBlacklistTransferManager(string fileName, uint256 branchId);\n\n    using SafeMath for uint256;\n\n    bytes32 public constant ADMIN = \"ADMIN\";\n    \n    struct BlacklistsDetails {\n        uint256 startTime;\n        uint256 endTime;\n        uint256 repeatPeriodTime;\n    }\n\n    //hold the different blacklist details corresponds to its name\n    mapping(bytes32 => BlacklistsDetails) public blacklists;\n\n    //hold the different name of blacklist corresponds to a investor\n    mapping(address => bytes32[]) investorToBlacklist;\n\n    //get list of the addresses for a particular blacklist\n    mapping(bytes32 => address[]) blacklistToInvestor;\n\n    //mapping use to store the indexes for different blacklist types for a investor\n    mapping(address => mapping(bytes32 => uint256)) investorToIndex;\n\n    //mapping use to store the indexes for different investor for a blacklist type\n    mapping(bytes32 => mapping(address => uint256)) blacklistToIndex;\n\n    bytes32[] allBlacklists;\n   \n    // Emit when new blacklist type is added\n    event AddBlacklistType(\n        uint256 _startTime, \n        uint256 _endTime, \n        bytes32 _blacklistName, \n        uint256 _repeatPeriodTime\n    );\n    \n    // Emit when there is a change in the blacklist type\n    event ModifyBlacklistType(\n        uint256 _startTime,\n        uint256 _endTime, \n        bytes32 _blacklistName, \n        uint256 _repeatPeriodTime\n    );\n    \n    // Emit when the added blacklist type is deleted\n    event DeleteBlacklistType(\n        bytes32 _blacklistName\n    );\n\n    // Emit when new investor is added to the blacklist type\n    event AddInvestorToBlacklist(\n        address indexed _investor, \n        bytes32 _blacklistName\n    );\n    \n    // Emit when investor is deleted from the blacklist type\n    event DeleteInvestorFromBlacklist(\n        address indexed _investor,\n        bytes32 _blacklistName\n    );\n\n   \n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress)\n    public\n    Module(_securityToken, _polyAddress)\n    {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',1);\n\n    }\n\n    /**\n    * @notice This function returns the signature of configure function\n    */\n    function getInitFunction() public  returns (bytes4) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',2);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',86);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',1);\nreturn bytes4(0);\n    }\n\n\n    /** \n    * @notice Used to verify the transfer transaction\n    * @param _from Address of the sender\n    * @dev Restrict the blacklist address to transfer tokens \n    * if the current time is between the timeframe define for the \n    * blacklist type associated with the _from address\n    */\n    function verifyTransfer(address _from, address /* _to */, uint256 /* _amount */, bytes /* _data */, bool /* _isTransfer */) public returns(Result) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',3);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',98);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',2);\nif (!paused) {emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',1,0);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',99);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',3);\nif (investorToBlacklist[_from].length != 0) {emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',2,0);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',100);\n                emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',4);\nfor (uint256 i = 0; i < investorToBlacklist[_from].length; i++) {\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',101);\n                    emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',5);\nuint256 endTimeTemp = blacklists[investorToBlacklist[_from][i]].endTime;\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',102);\n                    emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',6);\nuint256 startTimeTemp = blacklists[investorToBlacklist[_from][i]].startTime;\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',103);\n                    emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',7);\nuint256 repeatPeriodTimeTemp = blacklists[investorToBlacklist[_from][i]].repeatPeriodTime * 1 days;\n                    /*solium-disable-next-line security/no-block-members*/\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',105);\n                    emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',8);\nif (now > startTimeTemp) {emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',3,0);\n                    // Find the repeating parameter that will be used to calculate the new startTime and endTime\n                    // based on the new current time value   \n                    /*solium-disable-next-line security/no-block-members*/\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',109);\n                        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',9);\nuint256 repeater = (now.sub(startTimeTemp)).div(repeatPeriodTimeTemp); \n                        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',111);\n                        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',10);\nif (startTimeTemp.add(repeatPeriodTimeTemp.mul(repeater)) <= now && endTimeTemp.add(repeatPeriodTimeTemp.mul(repeater)) >= now) {emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',4,0);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',112);\n                            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',11);\nreturn Result.INVALID;\n                        }else { emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',4,1);}\n    \n                    }else { emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',3,1);}\n   \n                }    \n            }else { emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',2,1);}\n     \n        }else { emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',1,1);}\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',118);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',12);\nreturn Result.NA;\n    }\n\n    /**\n    * @notice Used to add the blacklist type\n    * @param _startTime Start date of the blacklist type\n    * @param _endTime End date of the blacklist type\n    * @param _blacklistName Name of the blacklist type\n    * @param _repeatPeriodTime Repeat period of the blacklist type\n    */\n    function addBlacklistType(uint256 _startTime, uint256 _endTime, bytes32 _blacklistName, uint256 _repeatPeriodTime) public withPerm(ADMIN) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',4);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',129);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',13);\n_addBlacklistType(_startTime, _endTime, _blacklistName, _repeatPeriodTime);\n    }\n    \n    /**\n    * @notice Used to add the multiple blacklist type\n    * @param _startTimes Start date of the blacklist type\n    * @param _endTimes End date of the blacklist type\n    * @param _blacklistNames Name of the blacklist type\n    * @param _repeatPeriodTimes Repeat period of the blacklist type\n    */\n    function addBlacklistTypeMulti(uint256[] _startTimes, uint256[] _endTimes, bytes32[] _blacklistNames, uint256[] _repeatPeriodTimes) external withPerm(ADMIN) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',5);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',140);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',5);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',14);\nrequire (_startTimes.length == _endTimes.length && _endTimes.length == _blacklistNames.length && _blacklistNames.length == _repeatPeriodTimes.length, \"Input array's length mismatch\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',5);\n \nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',141);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',15);\nfor (uint256 i = 0; i < _startTimes.length; i++){\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',142);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',16);\n_addBlacklistType(_startTimes[i], _endTimes[i], _blacklistNames[i], _repeatPeriodTimes[i]);\n        }\n    }\n\n    /**\n     * @notice Internal function \n     */\n    function _validParams(uint256 _startTime, uint256 _endTime, bytes32 _blacklistName, uint256 _repeatPeriodTime) internal  {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',6);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',150);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',6);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',17);\nrequire(_blacklistName != bytes32(0), \"Invalid blacklist name\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',6);\n \nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',151);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',7);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',18);\nrequire(_startTime >= now && _startTime < _endTime, \"Invalid start or end date\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',7);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',152);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',8);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',19);\nrequire(_repeatPeriodTime.mul(1 days) >= _endTime.sub(_startTime) || _repeatPeriodTime == 0);emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',8);\n\n    }\n\n    /**\n    * @notice Used to modify the details of a given blacklist type\n    * @param _startTime Start date of the blacklist type\n    * @param _endTime End date of the blacklist type\n    * @param _blacklistName Name of the blacklist type\n    * @param _repeatPeriodTime Repeat period of the blacklist type\n    */\n    function modifyBlacklistType(uint256 _startTime, uint256 _endTime, bytes32 _blacklistName, uint256 _repeatPeriodTime) public withPerm(ADMIN) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',7);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',163);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',9);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',20);\nrequire(blacklists[_blacklistName].endTime != 0, \"Blacklist type doesn't exist\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',9);\n \nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',164);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',21);\n_validParams(_startTime, _endTime, _blacklistName, _repeatPeriodTime);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',165);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',22);\nblacklists[_blacklistName] = BlacklistsDetails(_startTime, _endTime, _repeatPeriodTime);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',166);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',23);\nemit ModifyBlacklistType(_startTime, _endTime, _blacklistName, _repeatPeriodTime);\n    }\n\n    /**\n    * @notice Used to modify the details of a given multpile blacklist types\n    * @param _startTimes Start date of the blacklist type\n    * @param _endTimes End date of the blacklist type\n    * @param _blacklistNames Name of the blacklist type\n    * @param _repeatPeriodTimes Repeat period of the blacklist type\n    */\n    function modifyBlacklistTypeMulti(uint256[] _startTimes, uint256[] _endTimes, bytes32[] _blacklistNames, uint256[] _repeatPeriodTimes) external withPerm(ADMIN) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',8);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',177);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',10);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',24);\nrequire (_startTimes.length == _endTimes.length && _endTimes.length == _blacklistNames.length && _blacklistNames.length == _repeatPeriodTimes.length, \"Input array's length mismatch\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',10);\n \nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',178);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',25);\nfor (uint256 i = 0; i < _startTimes.length; i++){\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',179);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',26);\nmodifyBlacklistType(_startTimes[i], _endTimes[i], _blacklistNames[i], _repeatPeriodTimes[i]);\n        }\n    }\n\n    /**\n    * @notice Used to delete the blacklist type\n    * @param _blacklistName Name of the blacklist type\n    */\n    function deleteBlacklistType(bytes32 _blacklistName) public withPerm(ADMIN) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',9);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',188);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',11);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',27);\nrequire(blacklists[_blacklistName].endTime != 0, \"Blacklist type doesnt exist\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',11);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',189);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',12);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',28);\nrequire(blacklistToInvestor[_blacklistName].length == 0, \"Investors are associated with the blacklist\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',12);\n\n        // delete blacklist type \nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',191);\n        delete(blacklists[_blacklistName]);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',192);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',29);\nuint256 i = 0;\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',193);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',30);\nfor (i = 0; i < allBlacklists.length; i++) {\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',194);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',31);\nif (allBlacklists[i] == _blacklistName) {emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',13,0);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',195);\n                break;\n            }else { emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',13,1);}\n\n        }\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',198);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',32);\nif (i != allBlacklists.length -1) {emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',14,0);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',199);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',33);\nallBlacklists[i] = allBlacklists[allBlacklists.length -1];\n        }else { emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',14,1);}\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',201);\n        allBlacklists.length--;\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',202);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',34);\nemit DeleteBlacklistType(_blacklistName);\n    }\n\n    /**\n    * @notice Used to delete the multiple blacklist type\n    * @param _blacklistNames Name of the blacklist type\n    */\n    function deleteBlacklistTypeMulti(bytes32[] _blacklistNames) external withPerm(ADMIN) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',10);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',210);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',35);\nfor(uint256 i = 0; i < _blacklistNames.length; i++){\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',211);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',36);\ndeleteBlacklistType(_blacklistNames[i]);\n        }\n    }\n\n    /**\n    * @notice Used to assign the blacklist type to the investor\n    * @param _investor Address of the investor\n    * @param _blacklistName Name of the blacklist\n    */\n    function addInvestorToBlacklist(address _investor, bytes32 _blacklistName) public withPerm(ADMIN) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',11);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',221);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',15);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',37);\nrequire(blacklists[_blacklistName].endTime != 0, \"Blacklist type doesn't exist\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',15);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',222);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',16);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',38);\nrequire(_investor != address(0), \"Invalid investor address\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',16);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',223);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',39);\nuint256 index = investorToIndex[_investor][_blacklistName];\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',224);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',40);\nif (index < investorToBlacklist[_investor].length)\n            {emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',18);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',41);\nemit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',17,0);emit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',225);\nrequire(investorToBlacklist[_investor][index] != _blacklistName, \"Blacklist already added to investor\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',18);\n}else { emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',17,1);}\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',226);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',42);\nuint256 investorIndex = investorToBlacklist[_investor].length;\n        // Add blacklist index to the investor \nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',228);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',43);\ninvestorToIndex[_investor][_blacklistName] = investorIndex;\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',229);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',44);\nuint256 blacklistIndex = blacklistToInvestor[_blacklistName].length;\n        // Add investor index to the blacklist\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',231);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',45);\nblacklistToIndex[_blacklistName][_investor] = blacklistIndex;\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',232);\n        investorToBlacklist[_investor].push(_blacklistName);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',233);\n        blacklistToInvestor[_blacklistName].push(_investor);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',234);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',46);\nemit AddInvestorToBlacklist(_investor, _blacklistName);\n    }\n\n    /**\n    * @notice Used to assign the blacklist type to the multiple investor\n    * @param _investors Address of the investor\n    * @param _blacklistName Name of the blacklist\n    */\n    function addInvestorToBlacklistMulti(address[] _investors, bytes32 _blacklistName) external withPerm(ADMIN){emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',12);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',243);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',47);\nfor(uint256 i = 0; i < _investors.length; i++){\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',244);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',48);\naddInvestorToBlacklist(_investors[i], _blacklistName);\n        }\n    }\n\n    /**\n    * @notice Used to assign the multiple blacklist type to the multiple investor\n    * @param _investors Address of the investor\n    * @param _blacklistNames Name of the blacklist\n    */\n    function addMultiInvestorToBlacklistMulti(address[] _investors, bytes32[] _blacklistNames) external withPerm(ADMIN){emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',13);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',254);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',19);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',49);\nrequire (_investors.length == _blacklistNames.length, \"Input array's length mismatch\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',19);\n \nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',255);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',50);\nfor(uint256 i = 0; i < _investors.length; i++){\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',256);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',51);\naddInvestorToBlacklist(_investors[i], _blacklistNames[i]);\n        }\n    }\n\n    /**\n    * @notice Used to assign the new blacklist type to the investor\n    * @param _startTime Start date of the blacklist type\n    * @param _endTime End date of the blacklist type\n    * @param _blacklistName Name of the blacklist type\n    * @param _repeatPeriodTime Repeat period of the blacklist type\n    * @param _investor Address of the investor\n    */\n    function addInvestorToNewBlacklist(uint256 _startTime, uint256 _endTime, bytes32 _blacklistName, uint256 _repeatPeriodTime, address _investor) external withPerm(ADMIN){emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',14);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',269);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',52);\n_addBlacklistType(_startTime, _endTime, _blacklistName, _repeatPeriodTime);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',270);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',53);\naddInvestorToBlacklist(_investor, _blacklistName);\n    }\n\n    /**\n    * @notice Used to delete the investor from all the associated blacklist types\n    * @param _investor Address of the investor\n    */\n    function deleteInvestorFromAllBlacklist(address _investor) public withPerm(ADMIN) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',15);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',278);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',20);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',54);\nrequire(_investor != address(0), \"Invalid investor address\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',20);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',279);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',21);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',55);\nrequire(investorToBlacklist[_investor].length != 0, \"Investor is not associated to any blacklist type\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',21);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',280);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',56);\nuint256 index = investorToBlacklist[_investor].length - 1;\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',281);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',57);\nfor (uint256 i = index; i >= 0 && i <= index; i--){\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',282);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',58);\ndeleteInvestorFromBlacklist(_investor, investorToBlacklist[_investor][i]);\n        }\n    }\n\n     /**\n    * @notice Used to delete the multiple investor from all the associated blacklist types\n    * @param _investor Address of the investor\n    */\n    function deleteInvestorFromAllBlacklistMulti(address[] _investor) external withPerm(ADMIN) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',16);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',291);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',59);\nfor(uint256 i = 0; i < _investor.length; i++){\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',292);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',60);\ndeleteInvestorFromAllBlacklist(_investor[i]);\n        }\n    }\n\n    /**\n    * @notice Used to delete the investor from the blacklist\n    * @param _investor Address of the investor\n    * @param _blacklistName Name of the blacklist\n    */\n    function deleteInvestorFromBlacklist(address _investor, bytes32 _blacklistName) public withPerm(ADMIN) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',17);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',302);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',22);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',61);\nrequire(_investor != address(0), \"Invalid investor address\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',22);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',303);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',23);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',62);\nrequire(_blacklistName != bytes32(0),\"Invalid blacklist name\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',23);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',304);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',24);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',63);\nrequire(investorToBlacklist[_investor][investorToIndex[_investor][_blacklistName]] == _blacklistName, \"Investor not associated to the blacklist\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',24);\n\n        // delete the investor from the blacklist type\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',306);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',64);\nuint256 _blacklistIndex = blacklistToIndex[_blacklistName][_investor];\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',307);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',65);\nuint256 _len = blacklistToInvestor[_blacklistName].length;\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',308);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',66);\nif ( _blacklistIndex < _len -1) {emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',25,0);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',309);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',67);\nblacklistToInvestor[_blacklistName][_blacklistIndex] = blacklistToInvestor[_blacklistName][_len - 1];\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',310);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',68);\nblacklistToIndex[_blacklistName][blacklistToInvestor[_blacklistName][_blacklistIndex]] = _blacklistIndex;\n        }else { emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',25,1);}\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',312);\n        blacklistToInvestor[_blacklistName].length--;\n        // delete the investor index from the blacklist\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',314);\n        delete(blacklistToIndex[_blacklistName][_investor]);\n        // delete the blacklist from the investor\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',316);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',69);\nuint256 _investorIndex = investorToIndex[_investor][_blacklistName];\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',317);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',70);\n_len = investorToBlacklist[_investor].length;\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',318);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',71);\nif ( _investorIndex < _len -1) {emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',26,0);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',319);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',72);\ninvestorToBlacklist[_investor][_investorIndex] = investorToBlacklist[_investor][_len - 1];\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',320);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',73);\ninvestorToIndex[_investor][investorToBlacklist[_investor][_investorIndex]] = _investorIndex;\n        }else { emit __BranchCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',26,1);}\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',322);\n        investorToBlacklist[_investor].length--;\n        // delete the blacklist index from the invetsor\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',324);\n        delete(investorToIndex[_investor][_blacklistName]);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',325);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',74);\nemit DeleteInvestorFromBlacklist(_investor, _blacklistName);\n    }\n\n     /**\n    * @notice Used to delete the multiple investor from the blacklist\n    * @param _investors address of the investor\n    * @param _blacklistNames name of the blacklist\n    */\n    function deleteMultiInvestorsFromBlacklistMulti(address[] _investors, bytes32[] _blacklistNames) external withPerm(ADMIN) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',18);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',334);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',27);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',75);\nrequire (_investors.length == _blacklistNames.length, \"Input array's length mismatch\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',27);\n \nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',335);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',76);\nfor(uint256 i = 0; i < _investors.length; i++){\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',336);\n            emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',77);\ndeleteInvestorFromBlacklist(_investors[i], _blacklistNames[i]);\n        }\n    }\n\n    function _addBlacklistType(uint256 _startTime, uint256 _endTime, bytes32 _blacklistName, uint256 _repeatPeriodTime) internal {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',19);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',341);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',28);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',78);\nrequire(blacklists[_blacklistName].endTime == 0, \"Blacklist type already exist\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',28);\n \nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',342);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',79);\n_validParams(_startTime, _endTime, _blacklistName, _repeatPeriodTime);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',343);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',80);\nblacklists[_blacklistName] = BlacklistsDetails(_startTime, _endTime, _repeatPeriodTime);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',344);\n        allBlacklists.push(_blacklistName);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',345);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',81);\nemit AddBlacklistType(_startTime, _endTime, _blacklistName, _repeatPeriodTime);\n    }\n    \n    /**\n    * @notice get the list of the investors of a blacklist type\n    * @param _blacklistName Name of the blacklist type\n    * @return address List of investors associated with the blacklist\n    */\n    function getListOfAddresses(bytes32 _blacklistName) external  returns(address[]) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',20);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',354);\n        emit __AssertPreCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',29);\nemit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',82);\nrequire(blacklists[_blacklistName].endTime != 0, \"Blacklist type doesn't exist\");emit __AssertPostCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',29);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',355);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',83);\nreturn blacklistToInvestor[_blacklistName];\n    }\n\n    /**\n    * @notice get the list of the investors of a blacklist type\n    * @param _user Address of the user\n    * @return bytes32 List of blacklist names associated with the given address\n    */\n    function getBlacklistNamesToUser(address _user) external  returns(bytes32[]) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',21);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',364);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',84);\nreturn investorToBlacklist[_user];\n    }\n\n    /**\n     * @notice get the list of blacklist names\n     * @return bytes32 Array of blacklist names\n     */\n    function getAllBlacklists() external  returns(bytes32[]) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',22);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',372);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',85);\nreturn allBlacklists;\n    }\n\n    /**\n    * @notice Return the permissions flag that are associated with blacklist transfer manager\n    */\n    function getPermissions() public  returns(bytes32[]) {emit __FunctionCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',23);\n\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',379);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',86);\nbytes32[] memory allPermissions = new bytes32[](1);\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',380);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',87);\nallPermissions[0] = ADMIN;\nemit __CoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',381);\n        emit __StatementCoverageBlacklistTransferManager('./contracts/modules/TransferManager/BlacklistTransferManager.sol',88);\nreturn allPermissions;\n    }\n}\n\n\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./BlacklistTransferManager.sol\";\nimport \"../ModuleFactory.sol\";\nimport \"../../libraries/Util.sol\";\n\n/**\n * @title Factory for deploying BlacklistManager module\n */\ncontract BlacklistTransferManagerFactory is ModuleFactory {event __CoverageBlacklistTransferManagerFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageBlacklistTransferManagerFactory(string fileName, uint256 fnId);\nevent __StatementCoverageBlacklistTransferManagerFactory(string fileName, uint256 statementId);\nevent __BranchCoverageBlacklistTransferManagerFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageBlacklistTransferManagerFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageBlacklistTransferManagerFactory(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     * @param _setupCost Setup cost of the module\n     * @param _usageCost Usage cost of the module\n     * @param _subscriptionCost Subscription cost of the module\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {emit __FunctionCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',1);\n   \nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',22);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',1);\nversion = \"2.1.0\";\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',23);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',2);\nname = \"BlacklistTransferManager\";\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',24);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',3);\ntitle = \"Blacklist Transfer Manager\";\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',25);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',4);\ndescription = \"Automate blacklist to restrict selling\";\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',26);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',5);\ncompatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',27);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',6);\ncompatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n    }\n\n     /**\n     * @notice used to launch the Module with the help of factory\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes /* _data */) external returns(address) {emit __FunctionCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',2);\n\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',35);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',7);\nif (setupCost > 0)\n            {emit __AssertPreCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',2);\nemit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',8);\nemit __BranchCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',1,0);emit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',36);\nrequire(polyToken.transferFrom(msg.sender, owner, setupCost), \"Failed transferFrom because of sufficent Allowance is not provided\");emit __AssertPostCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',2);\n}else { emit __BranchCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',1,1);}\n\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',37);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',9);\naddress blacklistTransferManager = new BlacklistTransferManager(msg.sender, address(polyToken));\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',39);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',10);\nemit GenerateModuleFromFactory(address(blacklistTransferManager), getName(), address(this), msg.sender, setupCost, now);\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',40);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',11);\nreturn address(blacklistTransferManager);\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {emit __FunctionCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',3);\n\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',47);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',12);\nuint8[] memory res = new uint8[](1);\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',48);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',13);\nres[0] = 2;\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',49);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',14);\nreturn res;\n    }\n\n    /**\n     * @notice Get the Instructions that helped to used the module\n     */\n    function getInstructions() public  returns(string) {emit __FunctionCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',4);\n\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',56);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',15);\nreturn \"Allows an issuer to blacklist the addresses.\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() public  returns(bytes32[]) {emit __FunctionCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',5);\n\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',63);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',16);\nbytes32[] memory availableTags = new bytes32[](2);\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',64);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',17);\navailableTags[0] = \"Blacklist\";\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',65);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',18);\navailableTags[1] = \"Restricted transfer\";\nemit __CoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',66);\n        emit __StatementCoverageBlacklistTransferManagerFactory('./contracts/modules/TransferManager/BlacklistTransferManagerFactory.sol',19);\nreturn availableTags;\n    }\n\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/CountTransferManager.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ITransferManager.sol\";\n\n/**\n * @title Transfer Manager for limiting maximum number of token holders\n */\ncontract CountTransferManager is ITransferManager {event __CoverageCountTransferManager(string fileName, uint256 lineNumber);\nevent __FunctionCoverageCountTransferManager(string fileName, uint256 fnId);\nevent __StatementCoverageCountTransferManager(string fileName, uint256 statementId);\nevent __BranchCoverageCountTransferManager(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageCountTransferManager(string fileName, uint256 branchId);\nevent __AssertPostCoverageCountTransferManager(string fileName, uint256 branchId);\n\n\n    // The maximum number of concurrent token holders\n    uint256 public maxHolderCount;\n\n    bytes32 public constant ADMIN = \"ADMIN\";\n\n    event ModifyHolderCount(uint256 _oldHolderCount, uint256 _newHolderCount);\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress)\n    public\n    Module(_securityToken, _polyAddress)\n    {emit __FunctionCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',1);\n\n    }\n\n    /** @notice Used to verify the transfer transaction and prevent a transfer if it passes the allowed amount of token holders\n     * @param _from Address of the sender\n     * @param _to Address of the receiver\n     * @param _amount Amount to send\n     */\n    function verifyTransfer(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes /* _data */,\n        bool /* _isTransfer */\n    )\n        public\n        returns(Result)\n    {emit __FunctionCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',2);\n\nemit __CoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',43);\n        emit __StatementCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',1);\nif (!paused) {emit __BranchCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',1,0);\nemit __CoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',44);\n            emit __StatementCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',2);\nif (maxHolderCount < ISecurityToken(securityToken).getInvestorCount()) {emit __BranchCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',2,0);\n                // Allow transfers to existing maxHolders\nemit __CoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',46);\n                emit __StatementCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',3);\nif (ISecurityToken(securityToken).balanceOf(_to) != 0 || ISecurityToken(securityToken).balanceOf(_from) == _amount) {emit __BranchCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',3,0);\nemit __CoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',47);\n                    emit __StatementCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',4);\nreturn Result.NA;\n                }else { emit __BranchCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',3,1);}\n\nemit __CoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',49);\n                emit __StatementCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',5);\nreturn Result.INVALID;\n            }else { emit __BranchCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',2,1);}\n\nemit __CoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',51);\n            emit __StatementCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',6);\nreturn Result.NA;\n        }else { emit __BranchCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',1,1);}\n\nemit __CoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',53);\n        emit __StatementCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',7);\nreturn Result.NA;\n    }\n\n    /**\n     * @notice Used to initialize the variables of the contract\n     * @param _maxHolderCount Maximum no. of holders this module allows the SecurityToken to have\n     */\n    function configure(uint256 _maxHolderCount) public onlyFactory {emit __FunctionCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',3);\n\nemit __CoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',61);\n        emit __StatementCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',8);\nmaxHolderCount = _maxHolderCount;\n    }\n\n    /**\n    * @notice Sets the cap for the amount of token holders there can be\n    * @param _maxHolderCount is the new maximum amount of token holders\n    */\n    function changeHolderCount(uint256 _maxHolderCount) public withPerm(ADMIN) {emit __FunctionCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',4);\n\nemit __CoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',69);\n        emit __StatementCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',9);\nemit ModifyHolderCount(maxHolderCount, _maxHolderCount);\nemit __CoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',70);\n        emit __StatementCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',10);\nmaxHolderCount = _maxHolderCount;\n    }\n\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() public  returns (bytes4) {emit __FunctionCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',5);\n\nemit __CoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',77);\n        emit __StatementCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',11);\nreturn bytes4(keccak256(\"configure(uint256)\"));\n    }\n\n    /**\n     * @notice Returns the permissions flag that are associated with CountTransferManager\n     */\n    function getPermissions() public  returns(bytes32[]) {emit __FunctionCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',6);\n\nemit __CoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',84);\n        emit __StatementCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',12);\nbytes32[] memory allPermissions = new bytes32[](1);\nemit __CoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',85);\n        emit __StatementCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',13);\nallPermissions[0] = ADMIN;\nemit __CoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',86);\n        emit __StatementCoverageCountTransferManager('./contracts/modules/TransferManager/CountTransferManager.sol',14);\nreturn allPermissions;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/CountTransferManagerFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./CountTransferManager.sol\";\nimport \"../ModuleFactory.sol\";\nimport \"../../libraries/Util.sol\";\n\n/**\n * @title Factory for deploying CountTransferManager module\n */\ncontract CountTransferManagerFactory is ModuleFactory {event __CoverageCountTransferManagerFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageCountTransferManagerFactory(string fileName, uint256 fnId);\nevent __StatementCoverageCountTransferManagerFactory(string fileName, uint256 statementId);\nevent __BranchCoverageCountTransferManagerFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageCountTransferManagerFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageCountTransferManagerFactory(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {emit __FunctionCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',1);\n\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',19);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',1);\nversion = \"2.1.0\";\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',20);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',2);\nname = \"CountTransferManager\";\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',21);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',3);\ntitle = \"Count Transfer Manager\";\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',22);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',4);\ndescription = \"Restrict the number of investors\";\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',23);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',5);\ncompatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',24);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',6);\ncompatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n    }\n\n    /**\n     * @notice Used to launch the Module with the help of factory\n     * @param _data Data used for the intialization of the module factory variables\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes _data) external returns(address) {emit __FunctionCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',2);\n\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',33);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',7);\nif(setupCost > 0)\n            {emit __AssertPreCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',2);\nemit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',8);\nemit __BranchCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',1,0);emit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',34);\nrequire(polyToken.transferFrom(msg.sender, owner, setupCost), \"Failed transferFrom due to insufficent Allowance provided\");emit __AssertPostCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',2);\n}else { emit __BranchCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',1,1);}\n\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',35);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',9);\nCountTransferManager countTransferManager = new CountTransferManager(msg.sender, address(polyToken));\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',36);\n        emit __AssertPreCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',3);\nemit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',10);\nrequire(Util.getSig(_data) == countTransferManager.getInitFunction(), \"Provided data is not valid\");emit __AssertPostCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',3);\n\n        /*solium-disable-next-line security/no-low-level-calls*/\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',38);\n        emit __AssertPreCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',4);\nemit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',11);\nrequire(address(countTransferManager).call(_data), \"Unsuccessful call\");emit __AssertPostCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',4);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',40);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',12);\nemit GenerateModuleFromFactory(address(countTransferManager), getName(), address(this), msg.sender, setupCost, now);\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',41);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',13);\nreturn address(countTransferManager);\n\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {emit __FunctionCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',3);\n\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',49);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',14);\nuint8[] memory res = new uint8[](1);\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',50);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',15);\nres[0] = 2;\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',51);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',16);\nreturn res;\n    }\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {emit __FunctionCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',4);\n\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',58);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',17);\nreturn \"Allows an issuer to restrict the total number of non-zero token holders\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {emit __FunctionCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',5);\n\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',65);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',18);\nbytes32[] memory availableTags = new bytes32[](2);\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',66);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',19);\navailableTags[0] = \"Count\";\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',67);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',20);\navailableTags[1] = \"Transfer Restriction\";\nemit __CoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',68);\n        emit __StatementCoverageCountTransferManagerFactory('./contracts/modules/TransferManager/CountTransferManagerFactory.sol',21);\nreturn availableTags;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/GeneralTransferManager.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ITransferManager.sol\";\nimport \"./GeneralTransferManagerStorage.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title Transfer Manager module for core transfer validation functionality\n */\ncontract GeneralTransferManager is GeneralTransferManagerStorage, ITransferManager {event __CoverageGeneralTransferManager(string fileName, uint256 lineNumber);\nevent __FunctionCoverageGeneralTransferManager(string fileName, uint256 fnId);\nevent __StatementCoverageGeneralTransferManager(string fileName, uint256 statementId);\nevent __BranchCoverageGeneralTransferManager(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageGeneralTransferManager(string fileName, uint256 branchId);\nevent __AssertPostCoverageGeneralTransferManager(string fileName, uint256 branchId);\n\n\n    using SafeMath for uint256;\n\n    // Emit when Issuance address get changed\n    event ChangeIssuanceAddress(address _issuanceAddress);\n    // Emit when there is change in the flag variable called allowAllTransfers\n    event AllowAllTransfers(bool _allowAllTransfers);\n    // Emit when there is change in the flag variable called allowAllWhitelistTransfers\n    event AllowAllWhitelistTransfers(bool _allowAllWhitelistTransfers);\n    // Emit when there is change in the flag variable called allowAllWhitelistIssuances\n    event AllowAllWhitelistIssuances(bool _allowAllWhitelistIssuances);\n    // Emit when there is change in the flag variable called allowAllBurnTransfers\n    event AllowAllBurnTransfers(bool _allowAllBurnTransfers);\n    // Emit when there is change in the flag variable called signingAddress\n    event ChangeSigningAddress(address _signingAddress);\n    // Emit when investor details get modified related to their whitelisting\n    event ChangeDefaults(uint64 _defaultFromTime, uint64 _defaultToTime);\n\n    // _fromTime is the time from which the _investor can send tokens\n    // _toTime is the time from which the _investor can receive tokens\n    // if allowAllWhitelistIssuances is TRUE, then _toTime is ignored when receiving tokens from the issuance address\n    // if allowAllWhitelistTransfers is TRUE, then _toTime and _fromTime is ignored when sending or receiving tokens\n    // in any case, any investor sending or receiving tokens, must have a _expiryTime in the future\n    event ModifyWhitelist(\n        address indexed _investor,\n        uint256 _dateAdded,\n        address indexed _addedBy,\n        uint256 _fromTime,\n        uint256 _toTime,\n        uint256 _expiryTime,\n        bool _canBuyFromSTO\n    );\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress)\n    public\n    Module(_securityToken, _polyAddress)\n    {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',1);\n\n    }\n\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() public  returns (bytes4) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',2);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',59);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',1);\nreturn bytes4(0);\n    }\n\n    /**\n     * @notice Used to change the default times used when fromTime / toTime are zero\n     * @param _defaultFromTime default for zero fromTime\n     * @param _defaultToTime default for zero toTime\n     */\n    function changeDefaults(uint64 _defaultFromTime, uint64 _defaultToTime) public withPerm(FLAGS) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',3);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',68);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',2);\ndefaults.fromTime = _defaultFromTime;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',69);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',3);\ndefaults.toTime = _defaultToTime;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',70);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',4);\nemit ChangeDefaults(_defaultFromTime, _defaultToTime);\n    }\n\n    /**\n     * @notice Used to change the Issuance Address\n     * @param _issuanceAddress new address for the issuance\n     */\n    function changeIssuanceAddress(address _issuanceAddress) public withPerm(FLAGS) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',4);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',78);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',5);\nissuanceAddress = _issuanceAddress;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',79);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',6);\nemit ChangeIssuanceAddress(_issuanceAddress);\n    }\n\n    /**\n     * @notice Used to change the Sigining Address\n     * @param _signingAddress new address for the signing\n     */\n    function changeSigningAddress(address _signingAddress) public withPerm(FLAGS) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',5);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',87);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',7);\nsigningAddress = _signingAddress;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',88);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',8);\nemit ChangeSigningAddress(_signingAddress);\n    }\n\n    /**\n     * @notice Used to change the flag\n            true - It refers there are no transfer restrictions, for any addresses\n            false - It refers transfers are restricted for all addresses.\n     * @param _allowAllTransfers flag value\n     */\n    function changeAllowAllTransfers(bool _allowAllTransfers) public withPerm(FLAGS) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',6);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',98);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',9);\nallowAllTransfers = _allowAllTransfers;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',99);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',10);\nemit AllowAllTransfers(_allowAllTransfers);\n    }\n\n    /**\n     * @notice Used to change the flag\n            true - It refers that time lock is ignored for transfers (address must still be on whitelist)\n            false - It refers transfers are restricted for all addresses.\n     * @param _allowAllWhitelistTransfers flag value\n     */\n    function changeAllowAllWhitelistTransfers(bool _allowAllWhitelistTransfers) public withPerm(FLAGS) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',7);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',109);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',11);\nallowAllWhitelistTransfers = _allowAllWhitelistTransfers;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',110);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',12);\nemit AllowAllWhitelistTransfers(_allowAllWhitelistTransfers);\n    }\n\n    /**\n     * @notice Used to change the flag\n            true - It refers that time lock is ignored for issuances (address must still be on whitelist)\n            false - It refers transfers are restricted for all addresses.\n     * @param _allowAllWhitelistIssuances flag value\n     */\n    function changeAllowAllWhitelistIssuances(bool _allowAllWhitelistIssuances) public withPerm(FLAGS) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',8);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',120);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',13);\nallowAllWhitelistIssuances = _allowAllWhitelistIssuances;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',121);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',14);\nemit AllowAllWhitelistIssuances(_allowAllWhitelistIssuances);\n    }\n\n    /**\n     * @notice Used to change the flag\n            true - It allow to burn the tokens\n            false - It deactivate the burning mechanism.\n     * @param _allowAllBurnTransfers flag value\n     */\n    function changeAllowAllBurnTransfers(bool _allowAllBurnTransfers) public withPerm(FLAGS) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',9);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',131);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',15);\nallowAllBurnTransfers = _allowAllBurnTransfers;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',132);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',16);\nemit AllowAllBurnTransfers(_allowAllBurnTransfers);\n    }\n\n    /**\n     * @notice Default implementation of verifyTransfer used by SecurityToken\n     * If the transfer request comes from the STO, it only checks that the investor is in the whitelist\n     * If the transfer request comes from a token holder, it checks that:\n     * a) Both are on the whitelist\n     * b) Seller's sale lockup period is over\n     * c) Buyer's purchase lockup is over\n     * @param _from Address of the sender\n     * @param _to Address of the receiver\n    */\n    function verifyTransfer(address _from, address _to, uint256 /*_amount*/, bytes /* _data */, bool /* _isTransfer */) public returns(Result) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',10);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',146);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',17);\nif (!paused) {emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',1,0);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',147);\n            emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',18);\nif (allowAllTransfers) {emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',2,0);\n                //All transfers allowed, regardless of whitelist\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',149);\n                emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',19);\nreturn Result.VALID;\n            }else { emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',2,1);}\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',151);\n            emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',20);\nif (allowAllBurnTransfers && (_to == address(0))) {emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',3,0);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',152);\n                emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',21);\nreturn Result.VALID;\n            }else { emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',3,1);}\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',154);\n            emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',22);\nif (allowAllWhitelistTransfers) {emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',4,0);\n                //Anyone on the whitelist can transfer, regardless of time\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',156);\n                emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',23);\nreturn (_onWhitelist(_to) && _onWhitelist(_from)) ? Result.VALID : Result.NA;\n            }else { emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',4,1);}\n\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',159);\n            emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',24);\n(uint64 adjustedFromTime, uint64 adjustedToTime) = _adjustTimes(whitelist[_from].fromTime, whitelist[_to].toTime);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',160);\n            emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',25);\nif (_from == issuanceAddress) {emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',5,0);\n                // Possible STO transaction, but investor not allowed to purchased from STO\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',162);\n                emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',26);\nif ((whitelist[_to].canBuyFromSTO == 0) && _isSTOAttached()) {emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',6,0);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',163);\n                    emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',27);\nreturn Result.NA;\n                }else { emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',6,1);}\n\n                // if allowAllWhitelistIssuances is true, so time stamp ignored\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',166);\n                emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',28);\nif (allowAllWhitelistIssuances) {emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',7,0);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',167);\n                    emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',29);\nreturn _onWhitelist(_to) ? Result.VALID : Result.NA;\n                } else {emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',7,1);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',169);\n                    emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',30);\nreturn (_onWhitelist(_to) && (adjustedToTime <= uint64(now))) ? Result.VALID : Result.NA;\n                }\n            }else { emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',5,1);}\n\n\n            //Anyone on the whitelist can transfer provided the blocknumber is large enough\n            /*solium-disable-next-line security/no-block-members*/\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',175);\n            emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',31);\nreturn ((_onWhitelist(_from) && (adjustedFromTime <= uint64(now))) &&\n                (_onWhitelist(_to) && (adjustedToTime <= uint64(now)))) ? Result.VALID : Result.NA; /*solium-disable-line security/no-block-members*/\n        }else { emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',1,1);}\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',178);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',32);\nreturn Result.NA;\n    }\n\n    /**\n    * @notice Adds or removes addresses from the whitelist.\n    * @param _investor is the address to whitelist\n    * @param _fromTime is the moment when the sale lockup period ends and the investor can freely sell his tokens\n    * @param _toTime is the moment when the purchase lockup period ends and the investor can freely purchase tokens from others\n    * @param _expiryTime is the moment till investors KYC will be validated. After that investor need to do re-KYC\n    * @param _canBuyFromSTO is used to know whether the investor is restricted investor or not.\n    */\n    function modifyWhitelist(\n        address _investor,\n        uint256 _fromTime,\n        uint256 _toTime,\n        uint256 _expiryTime,\n        bool _canBuyFromSTO\n    )\n        public\n        withPerm(WHITELIST)\n    {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',11);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',199);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',33);\n_modifyWhitelist(_investor, _fromTime, _toTime, _expiryTime, _canBuyFromSTO);\n    }\n\n    /**\n    * @notice Adds or removes addresses from the whitelist.\n    * @param _investor is the address to whitelist\n    * @param _fromTime is the moment when the sale lockup period ends and the investor can freely sell his tokens\n    * @param _toTime is the moment when the purchase lockup period ends and the investor can freely purchase tokens from others\n    * @param _expiryTime is the moment till investors KYC will be validated. After that investor need to do re-KYC\n    * @param _canBuyFromSTO is used to know whether the investor is restricted investor or not.\n    */\n    function _modifyWhitelist(\n        address _investor,\n        uint256 _fromTime,\n        uint256 _toTime,\n        uint256 _expiryTime,\n        bool _canBuyFromSTO\n    )\n        internal\n    {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',12);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',219);\n        emit __AssertPreCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',8);\nemit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',34);\nrequire(_investor != address(0), \"Invalid investor\");emit __AssertPostCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',8);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',220);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',35);\nuint8 canBuyFromSTO = 0;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',221);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',36);\nif (_canBuyFromSTO) {emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',9,0);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',222);\n            emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',37);\ncanBuyFromSTO = 1;\n        }else { emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',9,1);}\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',224);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',38);\nif (whitelist[_investor].added == uint8(0)) {emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',10,0);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',225);\n            investors.push(_investor);\n        }else { emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',10,1);}\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',227);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',39);\nwhitelist[_investor] = TimeRestriction(uint64(_fromTime), uint64(_toTime), uint64(_expiryTime), canBuyFromSTO, uint8(1));\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',228);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',40);\nemit ModifyWhitelist(_investor, now, msg.sender, _fromTime, _toTime, _expiryTime, _canBuyFromSTO);\n    }\n\n    /**\n    * @notice Adds or removes addresses from the whitelist.\n    * @param _investors List of the addresses to whitelist\n    * @param _fromTimes An array of the moment when the sale lockup period ends and the investor can freely sell his tokens\n    * @param _toTimes An array of the moment when the purchase lockup period ends and the investor can freely purchase tokens from others\n    * @param _expiryTimes An array of the moment till investors KYC will be validated. After that investor need to do re-KYC\n    * @param _canBuyFromSTO An array of boolean values\n    */\n    function modifyWhitelistMulti(\n        address[] _investors,\n        uint256[] _fromTimes,\n        uint256[] _toTimes,\n        uint256[] _expiryTimes,\n        bool[] _canBuyFromSTO\n    ) public withPerm(WHITELIST) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',13);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',246);\n        emit __AssertPreCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',11);\nemit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',41);\nrequire(_investors.length == _fromTimes.length, \"Mismatched input lengths\");emit __AssertPostCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',11);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',247);\n        emit __AssertPreCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',12);\nemit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',42);\nrequire(_fromTimes.length == _toTimes.length, \"Mismatched input lengths\");emit __AssertPostCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',12);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',248);\n        emit __AssertPreCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',13);\nemit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',43);\nrequire(_toTimes.length == _expiryTimes.length, \"Mismatched input lengths\");emit __AssertPostCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',13);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',249);\n        emit __AssertPreCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',14);\nemit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',44);\nrequire(_canBuyFromSTO.length == _toTimes.length, \"Mismatched input length\");emit __AssertPostCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',14);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',250);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',45);\nfor (uint256 i = 0; i < _investors.length; i++) {\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',251);\n            emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',46);\n_modifyWhitelist(_investors[i], _fromTimes[i], _toTimes[i], _expiryTimes[i], _canBuyFromSTO[i]);\n        }\n    }\n\n    /**\n    * @notice Adds or removes addresses from the whitelist - can be called by anyone with a valid signature\n    * @param _investor is the address to whitelist\n    * @param _fromTime is the moment when the sale lockup period ends and the investor can freely sell his tokens\n    * @param _toTime is the moment when the purchase lockup period ends and the investor can freely purchase tokens from others\n    * @param _expiryTime is the moment till investors KYC will be validated. After that investor need to do re-KYC\n    * @param _canBuyFromSTO is used to know whether the investor is restricted investor or not.\n    * @param _validFrom is the time that this signature is valid from\n    * @param _validTo is the time that this signature is valid until\n    * @param _nonce nonce of signature (avoid replay attack)\n    * @param _v issuer signature\n    * @param _r issuer signature\n    * @param _s issuer signature\n    */\n    function modifyWhitelistSigned(\n        address _investor,\n        uint256 _fromTime,\n        uint256 _toTime,\n        uint256 _expiryTime,\n        bool _canBuyFromSTO,\n        uint256 _validFrom,\n        uint256 _validTo,\n        uint256 _nonce,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',14);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',283);\n        emit __AssertPreCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',15);\nemit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',47);\nrequire(_validFrom <= now, \"ValidFrom is too early\");emit __AssertPostCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',15);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',285);\n        emit __AssertPreCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',16);\nemit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',48);\nrequire(_validTo >= now, \"ValidTo is too late\");emit __AssertPostCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',16);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',286);\n        emit __AssertPreCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',17);\nemit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',49);\nrequire(!nonceMap[_investor][_nonce], \"Already used signature\");emit __AssertPostCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',17);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',287);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',50);\nnonceMap[_investor][_nonce] = true;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',288);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',51);\nbytes32 hash = keccak256(\n            abi.encodePacked(this, _investor, _fromTime, _toTime, _expiryTime, _canBuyFromSTO, _validFrom, _validTo, _nonce)\n        );\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',291);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',52);\n_checkSig(hash, _v, _r, _s);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',292);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',53);\n_modifyWhitelist(_investor, _fromTime, _toTime, _expiryTime, _canBuyFromSTO);\n    }\n\n    /**\n     * @notice Used to verify the signature\n     */\n    function _checkSig(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) internal  {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',15);\n\n        //Check that the signature is valid\n        //sig should be signing - _investor, _fromTime, _toTime & _expiryTime and be signed by the issuer address\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',301);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',54);\naddress signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash)), _v, _r, _s);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',302);\n        emit __AssertPreCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',18);\nemit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',55);\nrequire(signer == Ownable(securityToken).owner() || signer == signingAddress, \"Incorrect signer\");emit __AssertPostCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',18);\n\n    }\n\n    /**\n     * @notice Internal function used to check whether the investor is in the whitelist or not\n            & also checks whether the KYC of investor get expired or not\n     * @param _investor Address of the investor\n     */\n    function _onWhitelist(address _investor) internal  returns(bool) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',16);\n\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',56);\nreturn (whitelist[_investor].expiryTime >= uint64(now)); /*solium-disable-line security/no-block-members*/\n    }\n\n    /**\n     * @notice Internal function use to know whether the STO is attached or not\n     */\n    function _isSTOAttached() internal  returns(bool) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',17);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',318);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',57);\nbool attached = ISecurityToken(securityToken).getModulesByType(3).length > 0;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',319);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',58);\nreturn attached;\n    }\n\n    /**\n     * @notice Internal function to adjust times using default values\n     */\n    function _adjustTimes(uint64 _fromTime, uint64 _toTime) internal  returns(uint64, uint64) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',18);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',326);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',59);\nuint64 adjustedFromTime = _fromTime;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',327);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',60);\nuint64 adjustedToTime = _toTime;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',328);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',61);\nif (_fromTime == 0) {emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',19,0);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',329);\n            emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',62);\nadjustedFromTime = defaults.fromTime;\n        }else { emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',19,1);}\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',331);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',63);\nif (_toTime == 0) {emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',20,0);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',332);\n            emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',64);\nadjustedToTime = defaults.toTime;\n        }else { emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',20,1);}\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',334);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',65);\nreturn (adjustedFromTime, adjustedToTime);\n    }\n\n    /**\n     * @dev Returns list of all investors\n     */\n    function getInvestors() external  returns(address[]) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',19);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',341);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',66);\nreturn investors;\n    }\n\n    /**\n     * @dev Returns list of all investors data\n     */\n    function getAllInvestorsData() external  returns(address[], uint256[], uint256[], uint256[], bool[]) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',20);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',348);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',67);\n(uint256[] memory fromTimes, uint256[] memory toTimes, uint256[] memory expiryTimes, bool[] memory canBuyFromSTOs)\n          = _investorsData(investors);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',350);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',68);\nreturn (investors, fromTimes, toTimes, expiryTimes, canBuyFromSTOs);\n\n    }\n\n    /**\n     * @dev Returns list of specified investors data\n     */\n    function getInvestorsData(address[] _investors) external  returns(uint256[], uint256[], uint256[], bool[]) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',21);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',358);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',69);\nreturn _investorsData(_investors);\n    }\n\n    function _investorsData(address[] _investors) internal  returns(uint256[], uint256[], uint256[], bool[]) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',22);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',362);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',70);\nuint256[] memory fromTimes = new uint256[](_investors.length);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',363);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',71);\nuint256[] memory toTimes = new uint256[](_investors.length);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',364);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',72);\nuint256[] memory expiryTimes = new uint256[](_investors.length);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',365);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',73);\nbool[] memory canBuyFromSTOs = new bool[](_investors.length);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',366);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',74);\nfor (uint256 i = 0; i < _investors.length; i++) {\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',367);\n            emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',75);\nfromTimes[i] = whitelist[_investors[i]].fromTime;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',368);\n            emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',76);\ntoTimes[i] = whitelist[_investors[i]].toTime;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',369);\n            emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',77);\nexpiryTimes[i] = whitelist[_investors[i]].expiryTime;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',370);\n            emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',78);\nif (whitelist[_investors[i]].canBuyFromSTO == 0) {emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',21,0);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',371);\n                emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',79);\ncanBuyFromSTOs[i] = false;\n            } else {emit __BranchCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',21,1);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',373);\n                emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',80);\ncanBuyFromSTOs[i] = true;\n            }\n        }\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',376);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',81);\nreturn (fromTimes, toTimes, expiryTimes, canBuyFromSTOs);\n    }\n\n    /**\n     * @notice Return the permissions flag that are associated with general trnasfer manager\n     */\n    function getPermissions() public  returns(bytes32[]) {emit __FunctionCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',23);\n\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',383);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',82);\nbytes32[] memory allPermissions = new bytes32[](2);\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',384);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',83);\nallPermissions[0] = WHITELIST;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',385);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',84);\nallPermissions[1] = FLAGS;\nemit __CoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',386);\n        emit __StatementCoverageGeneralTransferManager('./contracts/modules/TransferManager/GeneralTransferManager.sol',85);\nreturn allPermissions;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/ManualApprovalTransferManager.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ITransferManager.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title Transfer Manager module for manually approving transactions between accounts\n */\ncontract ManualApprovalTransferManager is ITransferManager {event __CoverageManualApprovalTransferManager(string fileName, uint256 lineNumber);\nevent __FunctionCoverageManualApprovalTransferManager(string fileName, uint256 fnId);\nevent __StatementCoverageManualApprovalTransferManager(string fileName, uint256 statementId);\nevent __BranchCoverageManualApprovalTransferManager(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageManualApprovalTransferManager(string fileName, uint256 branchId);\nevent __AssertPostCoverageManualApprovalTransferManager(string fileName, uint256 branchId);\n\n    using SafeMath for uint256;\n\n    //Address from which issuances come\n    address public issuanceAddress = address(0);\n\n    //Address which can sign whitelist changes\n    address public signingAddress = address(0);\n\n    bytes32 public constant TRANSFER_APPROVAL = \"TRANSFER_APPROVAL\";\n\n    //Manual approval is an allowance (that has been approved) with an expiry time\n    struct ManualApproval {\n        address from;\n        address to;\n        uint256 allowance;\n        uint256 expiryTime;\n        bytes32 description;\n    }\n\n    mapping (address => mapping (address => uint256)) public approvalIndex;\n    // An array to track all approvals\n    ManualApproval[] public approvals;\n\n    event AddManualApproval(\n        address indexed _from,\n        address indexed _to,\n        uint256 _allowance,\n        uint256 _expiryTime,\n        bytes32 _description,\n        address indexed _addedBy\n    );\n\n    event ModifyManualApproval(\n        address indexed _from,\n        address indexed _to,\n        uint256 _expiryTime,\n        uint256 _allowance,\n        bytes32 _description,\n        address indexed _edittedBy\n    );\n\n    event RevokeManualApproval(\n        address indexed _from,\n        address indexed _to,\n        address indexed _addedBy\n    );\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress)\n    public\n    Module(_securityToken, _polyAddress)\n    {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',1);\n\n    }\n\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() public  returns (bytes4) {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',2);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',72);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',1);\nreturn bytes4(0);\n    }\n\n    /** \n     * @notice Used to verify the transfer transaction and allow a manually approved transqaction to bypass other restrictions\n     * @param _from Address of the sender\n     * @param _to Address of the receiver\n     * @param _amount The amount of tokens to transfer\n     * @param _isTransfer Whether or not this is an actual transfer or just a test to see if the tokens would be transferrable\n     */\n    function verifyTransfer(address _from, address _to, uint256 _amount, bytes /* _data */, bool _isTransfer) public returns(Result) {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',3);\n\n        // function must only be called by the associated security token if _isTransfer == true\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',84);\n        emit __AssertPreCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',1);\nemit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',2);\nrequire(_isTransfer == false || msg.sender == securityToken, \"Sender is not the owner\");emit __AssertPostCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',1);\n\n       \nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',86);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',3);\nif (!paused && approvalIndex[_from][_to] != 0) {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',2,0);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',87);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',4);\nuint256 index = approvalIndex[_from][_to] - 1;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',88);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',5);\nManualApproval storage approval = approvals[index];\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',89);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',6);\nif ((approval.expiryTime >= now) && (approval.allowance >= _amount)) {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',3,0);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',90);\n                emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',7);\nif (_isTransfer) {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',4,0);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',91);\n                    emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',8);\napproval.allowance = approval.allowance.sub(_amount);\n                }else { emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',4,1);}\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',93);\n                emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',9);\nreturn Result.VALID;\n            }else { emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',3,1);}\n\n        }else { emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',2,1);}\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',96);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',10);\nreturn Result.NA;\n    }\n\n    /**\n    * @notice Adds a pair of addresses to manual approvals\n    * @param _from is the address from which transfers are approved\n    * @param _to is the address to which transfers are approved\n    * @param _allowance is the approved amount of tokens\n    * @param _expiryTime is the time until which the transfer is allowed\n    * @param _description Description about the manual approval\n    */\n    function addManualApproval(\n        address _from,\n        address _to,\n        uint256 _allowance,\n        uint256 _expiryTime,\n        bytes32 _description\n    ) \n        external \n        withPerm(TRANSFER_APPROVAL)\n    {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',4);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',117);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',11);\n_addManualApproval(_from, _to, _allowance, _expiryTime, _description);\n    }\n\n    function _addManualApproval(address _from, address _to, uint256 _allowance, uint256 _expiryTime, bytes32 _description) internal {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',5);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',121);\n        emit __AssertPreCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',5);\nemit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',12);\nrequire(_to != address(0), \"Invalid to address\");emit __AssertPostCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',5);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',122);\n        emit __AssertPreCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',6);\nemit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',13);\nrequire(_expiryTime > now, \"Invalid expiry time\");emit __AssertPostCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',6);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',123);\n        emit __AssertPreCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',7);\nemit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',14);\nrequire(_allowance > 0, \"Invalid allowance\");emit __AssertPostCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',7);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',124);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',15);\nif (approvalIndex[_from][_to] != 0) {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',8,0);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',125);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',16);\nuint256 index = approvalIndex[_from][_to] - 1;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',126);\n            emit __AssertPreCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',9);\nemit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',17);\nrequire(approvals[index].expiryTime < now || approvals[index].allowance == 0, \"Approval already exists\");emit __AssertPostCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',9);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',127);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',18);\n_revokeManualApproval(_from, _to);\n        }else { emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',8,1);}\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',129);\n        approvals.push(ManualApproval(_from, _to, _allowance, _expiryTime, _description));\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',130);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',19);\napprovalIndex[_from][_to] = approvals.length;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',131);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',20);\nemit AddManualApproval(_from, _to, _allowance, _expiryTime, _description, msg.sender);\n    }\n\n    /**\n    * @notice Adds mutiple manual approvals in batch\n    * @param _from is the address array from which transfers are approved\n    * @param _to is the address array to which transfers are approved\n    * @param _allowances is the array of approved amounts \n    * @param _expiryTimes is the array of the times until which eath transfer is allowed\n    * @param _descriptions is the description array for these manual approvals\n    */\n    function addManualApprovalMulti(\n        address[] _from,\n        address[] _to,\n        uint256[] _allowances,\n        uint256[] _expiryTimes,\n        bytes32[] _descriptions\n    ) \n        external \n        withPerm(TRANSFER_APPROVAL)\n    {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',6);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',152);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',21);\n_checkInputLengthArray(_from, _to, _allowances, _expiryTimes, _descriptions);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',153);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',22);\nfor (uint256 i = 0; i < _from.length; i++){\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',154);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',23);\n_addManualApproval(_from[i], _to[i], _allowances[i], _expiryTimes[i], _descriptions[i]);\n        }\n    }\n\n    /**\n    * @notice Modify the existing manual approvals\n    * @param _from is the address from which transfers are approved\n    * @param _to is the address to which transfers are approved\n    * @param _expiryTime is the time until which the transfer is allowed\n    * @param _changedAllowance is the changed allowance\n    * @param _description Description about the manual approval\n    * @param _change uint values which tells whether the allowances will be increased (1) or decreased (0)\n    * or any value when there is no change in allowances\n    */\n    function modifyManualApproval(\n        address _from,\n        address _to,\n        uint256 _expiryTime,\n        uint256 _changedAllowance,\n        bytes32 _description,\n        uint8 _change\n    ) \n        external\n        withPerm(TRANSFER_APPROVAL)\n    {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',7);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',179);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',24);\n_modifyManualApproval(_from, _to, _expiryTime, _changedAllowance, _description, _change);\n    }\n\n    function _modifyManualApproval(\n        address _from,\n        address _to,\n        uint256 _expiryTime,\n        uint256 _changedAllowance,\n        bytes32 _description,\n        uint8 _change\n    ) \n        internal \n    {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',8);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',192);\n        emit __AssertPreCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',10);\nemit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',25);\nrequire(_to != address(0), \"Invalid to address\");emit __AssertPostCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',10);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',194);\n        emit __AssertPreCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',11);\nemit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',26);\nrequire(_expiryTime > now, \"Invalid expiry time\");emit __AssertPostCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',11);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',195);\n        emit __AssertPreCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',12);\nemit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',27);\nrequire(approvalIndex[_from][_to] != 0, \"Approval not present\");emit __AssertPostCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',12);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',196);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',28);\nuint256 index = approvalIndex[_from][_to] - 1;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',197);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',29);\nManualApproval storage approval = approvals[index];\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',198);\n        emit __AssertPreCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',13);\nemit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',30);\nrequire(approval.allowance != 0 && approval.expiryTime > now, \"Not allowed\");emit __AssertPostCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',13);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',199);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',31);\nuint256 currentAllowance = approval.allowance;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',200);\n        uint256 newAllowance;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',201);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',32);\nif (_change == 1) {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',14,0);\n            // Allowance get increased\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',203);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',33);\nnewAllowance = currentAllowance.add(_changedAllowance);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',204);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',34);\napproval.allowance = newAllowance;\n        } else {emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',35);\nemit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',14,1);if (_change == 0) {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',15,0);\n            // Allowance get decreased\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',207);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',36);\nif (_changedAllowance > currentAllowance) {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',16,0);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',208);\n                emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',37);\nnewAllowance = 0;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',209);\n                emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',38);\napproval.allowance = newAllowance;\n            } else {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',16,1);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',211);\n                emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',39);\nnewAllowance = currentAllowance.sub(_changedAllowance);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',212);\n                emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',40);\napproval.allowance = newAllowance;\n            }\n        } else {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',15,1);\n            // No change in the Allowance\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',216);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',41);\nnewAllowance = currentAllowance;\n        }}\n        // Greedy storage technique\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',219);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',42);\nif (approval.expiryTime != _expiryTime) {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',17,0);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',220);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',43);\napproval.expiryTime = _expiryTime;\n        }else { emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',17,1);}\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',222);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',44);\nif (approval.description != _description) {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',18,0);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',223);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',45);\napproval.description = _description;\n        }else { emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',18,1);}\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',225);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',46);\nemit ModifyManualApproval(_from, _to, _expiryTime, newAllowance, _description, msg.sender);\n    }\n\n    /**\n     * @notice Adds mutiple manual approvals in batch\n     * @param _from is the address array from which transfers are approved\n     * @param _to is the address array to which transfers are approved\n     * @param _expiryTimes is the array of the times until which eath transfer is allowed\n     * @param _changedAllowances is the array of approved amounts \n     * @param _descriptions is the description array for these manual approvals\n     * @param _changes Array of uint values which tells whether the allowances will be increased (1) or decreased (0)\n     * or any value when there is no change in allowances\n     */\n    function modifyManualApprovalMulti(\n        address[] _from,\n        address[] _to,\n        uint256[] _expiryTimes,\n        uint256[] _changedAllowances,\n        bytes32[] _descriptions,\n        uint8[] _changes\n    )\n        public\n        withPerm(TRANSFER_APPROVAL)\n    {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',9);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',249);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',47);\n_checkInputLengthArray(_from, _to, _changedAllowances, _expiryTimes, _descriptions);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',250);\n        emit __AssertPreCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',19);\nemit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',48);\nrequire(_changes.length == _changedAllowances.length, \"Input length array mismatch\");emit __AssertPostCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',19);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',251);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',49);\nfor (uint256 i = 0; i < _from.length; i++) {\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',252);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',50);\n_modifyManualApproval(_from[i], _to[i], _expiryTimes[i], _changedAllowances[i], _descriptions[i], _changes[i]);\n        }\n    }\n\n    /**\n    * @notice Removes a pairs of addresses from manual approvals\n    * @param _from is the address from which transfers are approved\n    * @param _to is the address to which transfers are approved\n    */\n    function revokeManualApproval(address _from, address _to) external withPerm(TRANSFER_APPROVAL) {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',10);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',262);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',51);\n_revokeManualApproval(_from, _to);\n    }\n\n    function _revokeManualApproval(address _from, address _to) internal {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',11);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',266);\n        emit __AssertPreCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',20);\nemit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',52);\nrequire(approvalIndex[_from][_to] != 0, \"Approval not exist\");emit __AssertPostCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',20);\n \n\n        // find the record in active approvals array & delete it\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',269);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',53);\nuint256 index = approvalIndex[_from][_to] - 1;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',270);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',54);\nif (index != approvals.length -1) {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',21,0);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',271);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',55);\napprovals[index] = approvals[approvals.length -1];\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',272);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',56);\napprovalIndex[approvals[index].from][approvals[index].to] = index + 1; \n        }else { emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',21,1);}\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',274);\n        delete approvalIndex[_from][_to];\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',275);\n        approvals.length--;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',276);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',57);\nemit RevokeManualApproval(_from, _to, msg.sender);\n    }\n\n    /**\n    * @notice Removes mutiple pairs of addresses from manual approvals\n    * @param _from is the address array from which transfers are approved\n    * @param _to is the address array to which transfers are approved\n    */\n    function revokeManualApprovalMulti(address[] _from, address[] _to) external withPerm(TRANSFER_APPROVAL) {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',12);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',285);\n        emit __AssertPreCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',22);\nemit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',58);\nrequire(_from.length == _to.length, \"Input array length mismatch\");emit __AssertPostCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',22);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',286);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',59);\nfor(uint256 i = 0; i < _from.length; i++){\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',287);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',60);\n_revokeManualApproval(_from[i], _to[i]);\n        }\n    }\n\n    function _checkInputLengthArray(\n        address[] _from,\n        address[] _to,\n        uint256[] _expiryTimes,\n        uint256[] _allowances,\n        bytes32[] _descriptions\n    ) \n        internal\n         \n    {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',13);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',301);\n        emit __AssertPreCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',23);\nemit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',61);\nrequire(_from.length == _to.length &&\n        _to.length == _allowances.length &&\n        _allowances.length == _expiryTimes.length &&\n        _expiryTimes.length == _descriptions.length,\n        \"Input array length mismatch\"\n        );emit __AssertPostCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',23);\n\n    }\n\n    /**\n     * @notice Returns the all active approvals corresponds to an address\n     * @param _user Address of the holder corresponds to whom list of manual approvals \n     * need to return\n     * @return address[] addresses from\n     * @return address[] addresses to\n     * @return uint256[] allowances provided to the approvals\n     * @return uint256[] expiry times provided to the approvals\n     * @return bytes32[] descriptions provided to the approvals\n     */\n    function getActiveApprovalsToUser(address _user) external  returns(address[], address[], uint256[], uint256[], bytes32[]) {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',14);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',320);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',62);\nuint256 counter = 0;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',321);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',63);\nfor (uint256 i = 0; i < approvals.length; i++) {\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',322);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',64);\nif ((approvals[i].from == _user || approvals[i].to == _user)\n                && approvals[i].expiryTime >= now)\n                {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',24,0);emit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',324);\ncounter ++;}else { emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',24,1);}\n\n        }\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',327);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',65);\naddress[] memory from = new address[](counter);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',328);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',66);\naddress[] memory to = new address[](counter);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',329);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',67);\nuint256[] memory allowance = new uint256[](counter);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',330);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',68);\nuint256[] memory expiryTime = new uint256[](counter);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',331);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',69);\nbytes32[] memory description = new bytes32[](counter);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',333);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',70);\ncounter = 0;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',334);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',71);\nfor (i = 0; i < approvals.length; i++) {\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',335);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',72);\nif ((approvals[i].from == _user || approvals[i].to == _user)\n                && approvals[i].expiryTime >= now) {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',25,0);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',338);\n                emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',73);\nfrom[counter]=approvals[i].from;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',339);\n                emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',74);\nto[counter]=approvals[i].to;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',340);\n                emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',75);\nallowance[counter]=approvals[i].allowance;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',341);\n                emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',76);\nexpiryTime[counter]=approvals[i].expiryTime;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',342);\n                emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',77);\ndescription[counter]=approvals[i].description;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',343);\n                counter ++;\n            }else { emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',25,1);}\n \n        }\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',346);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',78);\nreturn (from, to, allowance, expiryTime, description);\n    }\n\n    /**\n     * @notice Get the details of the approval corresponds to _from & _to addresses\n     * @param _from Address of the sender\n     * @param _to Address of the receiver\n     * @return uint256 expiryTime of the approval\n     * @return uint256 allowance provided to the approval\n     * @return uint256 Description provided to the approval\n     */\n    function getApprovalDetails(address _from, address _to) external  returns(uint256, uint256, bytes32) {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',15);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',358);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',79);\nif (approvalIndex[_from][_to] != 0) {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',26,0);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',359);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',80);\nuint256 index = approvalIndex[_from][_to] - 1;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',360);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',81);\nif (index < approvals.length) {emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',27,0);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',361);\n                emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',82);\nManualApproval storage approval = approvals[index];\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',362);\n                emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',83);\nreturn(\n                    approval.expiryTime,\n                    approval.allowance,\n                    approval.description\n                );\n            }else { emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',27,1);}\n\n        }else { emit __BranchCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',26,1);}\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',369);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',84);\nreturn (uint256(0), uint256(0), bytes32(0));\n    }\n\n    /**\n    * @notice Returns the current number of active approvals\n    */\n    function getTotalApprovalsLength() external  returns(uint256) {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',16);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',376);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',85);\nreturn approvals.length;\n    }\n\n    /**\n     * @notice Get the details of all approvals\n     * @return address[] addresses from\n     * @return address[] addresses to\n     * @return uint256[] allowances provided to the approvals\n     * @return uint256[] expiry times provided to the approvals\n     * @return bytes32[] descriptions provided to the approvals\n     */\n    function getAllApprovals() external  returns(address[], address[], uint256[], uint256[], bytes32[]) {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',17);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',388);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',86);\naddress[] memory from = new address[](approvals.length);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',389);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',87);\naddress[] memory to = new address[](approvals.length);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',390);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',88);\nuint256[] memory allowance = new uint256[](approvals.length);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',391);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',89);\nuint256[] memory expiryTime = new uint256[](approvals.length);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',392);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',90);\nbytes32[] memory description = new bytes32[](approvals.length);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',394);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',91);\nfor (uint256 i = 0; i < approvals.length; i++) {\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',396);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',92);\nfrom[i]=approvals[i].from;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',397);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',93);\nto[i]=approvals[i].to;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',398);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',94);\nallowance[i]=approvals[i].allowance;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',399);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',95);\nexpiryTime[i]=approvals[i].expiryTime;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',400);\n            emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',96);\ndescription[i]=approvals[i].description;\n\n        }\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',404);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',97);\nreturn (from, to, allowance, expiryTime, description);\n        \n    }\n\n    /**\n     * @notice Returns the permissions flag that are associated with ManualApproval transfer manager\n     */\n    function getPermissions() public  returns(bytes32[]) {emit __FunctionCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',18);\n\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',412);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',98);\nbytes32[] memory allPermissions = new bytes32[](1);\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',413);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',99);\nallPermissions[0] = TRANSFER_APPROVAL;\nemit __CoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',414);\n        emit __StatementCoverageManualApprovalTransferManager('./contracts/modules/TransferManager/ManualApprovalTransferManager.sol',100);\nreturn allPermissions;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ManualApprovalTransferManager.sol\";\nimport \"../ModuleFactory.sol\";\n\n/**\n * @title Factory for deploying ManualApprovalTransferManager module\n */\ncontract ManualApprovalTransferManagerFactory is ModuleFactory {event __CoverageManualApprovalTransferManagerFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageManualApprovalTransferManagerFactory(string fileName, uint256 fnId);\nevent __StatementCoverageManualApprovalTransferManagerFactory(string fileName, uint256 statementId);\nevent __BranchCoverageManualApprovalTransferManagerFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageManualApprovalTransferManagerFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageManualApprovalTransferManagerFactory(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     * @param _setupCost Setup cost of the module\n     * @param _usageCost Usage cost of the module\n     * @param _subscriptionCost Subscription cost of the module\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {emit __FunctionCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',1);\n\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',21);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',1);\nversion = \"2.1.0\";\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',22);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',2);\nname = \"ManualApprovalTransferManager\";\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',23);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',3);\ntitle = \"Manual Approval Transfer Manager\";\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',24);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',4);\ndescription = \"Manage transfers using single approvals\";\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',25);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',5);\ncompatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',26);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',6);\ncompatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n    }\n\n     /**\n     * @notice used to launch the Module with the help of factory\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes /* _data */) external returns(address) {emit __FunctionCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',2);\n\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',34);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',7);\nif (setupCost > 0)\n            {emit __AssertPreCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',2);\nemit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',8);\nemit __BranchCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',1,0);emit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',35);\nrequire(polyToken.transferFrom(msg.sender, owner, setupCost), \"Failed transferFrom because of sufficent Allowance is not provided\");emit __AssertPostCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',2);\n}else { emit __BranchCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',1,1);}\n\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',36);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',9);\naddress manualTransferManager = new ManualApprovalTransferManager(msg.sender, address(polyToken));\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',38);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',10);\nemit GenerateModuleFromFactory(address(manualTransferManager), getName(), address(this), msg.sender, setupCost, now);\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',39);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',11);\nreturn address(manualTransferManager);\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {emit __FunctionCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',3);\n\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',46);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',12);\nuint8[] memory res = new uint8[](1);\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',47);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',13);\nres[0] = 2;\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',48);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',14);\nreturn res;\n    }\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {emit __FunctionCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',4);\n\n        /*solium-disable-next-line max-len*/\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',56);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',15);\nreturn \"Allows an issuer to set manual approvals for specific pairs of addresses and amounts. Init function takes no parameters.\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {emit __FunctionCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',5);\n\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',63);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',16);\nbytes32[] memory availableTags = new bytes32[](2);\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',64);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',17);\navailableTags[0] = \"ManualApproval\";\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',65);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',18);\navailableTags[1] = \"Transfer Restriction\";\nemit __CoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',66);\n        emit __StatementCoverageManualApprovalTransferManagerFactory('./contracts/modules/TransferManager/ManualApprovalTransferManagerFactory.sol',19);\nreturn availableTags;\n    }\n\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/PercentageTransferManager.sol":{"content":"/**\n * DISCLAIMER: Under certain conditions, the limit could be bypassed if a large token holder \n * redeems a huge portion of their tokens. It will cause the total supply to drop \n * which can result in some other token holders having a percentage of tokens \n * higher than the intended limit.\n */\n\npragma solidity ^0.4.24;\n\nimport \"./ITransferManager.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title Transfer Manager module for limiting percentage of token supply a single address can hold\n */\ncontract PercentageTransferManager is ITransferManager {event __CoveragePercentageTransferManager(string fileName, uint256 lineNumber);\nevent __FunctionCoveragePercentageTransferManager(string fileName, uint256 fnId);\nevent __StatementCoveragePercentageTransferManager(string fileName, uint256 statementId);\nevent __BranchCoveragePercentageTransferManager(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoveragePercentageTransferManager(string fileName, uint256 branchId);\nevent __AssertPostCoveragePercentageTransferManager(string fileName, uint256 branchId);\n\n    using SafeMath for uint256;\n\n    // Permission key for modifying the whitelist\n    bytes32 public constant WHITELIST = \"WHITELIST\";\n    bytes32 public constant ADMIN = \"ADMIN\";\n\n    // Maximum percentage that any holder can have, multiplied by 10**16 - e.g. 20% is 20 * 10**16\n    uint256 public maxHolderPercentage;\n\n    // Ignore transactions which are part of the primary issuance\n    bool public allowPrimaryIssuance = true;\n\n    // Addresses on this list are always able to send / receive tokens\n    mapping (address => bool) public whitelist;\n\n    event ModifyHolderPercentage(uint256 _oldHolderPercentage, uint256 _newHolderPercentage);\n    event ModifyWhitelist(\n        address _investor,\n        uint256 _dateAdded,\n        address _addedBy,\n        bool    _valid\n    );\n    event SetAllowPrimaryIssuance(bool _allowPrimaryIssuance, uint256 _timestamp);\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress)\n    public\n    Module(_securityToken, _polyAddress)\n    {emit __FunctionCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',1);\n\n    }\n\n    /** @notice Used to verify the transfer transaction and prevent a given account to end up with more tokens than allowed\n     * @param _from Address of the sender\n     * @param _to Address of the receiver\n     * @param _amount The amount of tokens to transfer\n     */\n    function verifyTransfer(address _from, address _to, uint256 _amount, bytes /* _data */, bool /* _isTransfer */) public returns(Result) {emit __FunctionCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',2);\n\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',58);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',1);\nif (!paused) {emit __BranchCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',1,0);\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',59);\n            emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',2);\nif (_from == address(0) && allowPrimaryIssuance) {emit __BranchCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',2,0);\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',60);\n                emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',3);\nreturn Result.NA;\n            }else { emit __BranchCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',2,1);}\n\n            // If an address is on the whitelist, it is allowed to hold more than maxHolderPercentage of the tokens.\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',63);\n            emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',4);\nif (whitelist[_to]) {emit __BranchCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',3,0);\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',64);\n                emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',5);\nreturn Result.NA;\n            }else { emit __BranchCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',3,1);}\n\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',66);\n            emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',6);\nuint256 newBalance = ISecurityToken(securityToken).balanceOf(_to).add(_amount);\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',67);\n            emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',7);\nif (newBalance.mul(uint256(10)**18).div(ISecurityToken(securityToken).totalSupply()) > maxHolderPercentage) {emit __BranchCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',4,0);\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',68);\n                emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',8);\nreturn Result.INVALID;\n            }else { emit __BranchCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',4,1);}\n\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',70);\n            emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',9);\nreturn Result.NA;\n        }else { emit __BranchCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',1,1);}\n\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',72);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',10);\nreturn Result.NA;\n    }\n\n    /**\n     * @notice Used to intialize the variables of the contract\n     * @param _maxHolderPercentage Maximum amount of ST20 tokens(in %) can hold by the investor\n     */\n    function configure(uint256 _maxHolderPercentage, bool _allowPrimaryIssuance) public onlyFactory {emit __FunctionCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',3);\n\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',80);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',11);\nmaxHolderPercentage = _maxHolderPercentage;\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',81);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',12);\nallowPrimaryIssuance = _allowPrimaryIssuance;\n    }\n\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() public  returns (bytes4) {emit __FunctionCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',4);\n\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',88);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',13);\nreturn bytes4(keccak256(\"configure(uint256,bool)\"));\n    }\n\n    /**\n    * @notice sets the maximum percentage that an individual token holder can hold\n    * @param _maxHolderPercentage is the new maximum percentage (multiplied by 10**16)\n    */\n    function changeHolderPercentage(uint256 _maxHolderPercentage) public withPerm(ADMIN) {emit __FunctionCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',5);\n\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',96);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',14);\nemit ModifyHolderPercentage(maxHolderPercentage, _maxHolderPercentage);\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',97);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',15);\nmaxHolderPercentage = _maxHolderPercentage;\n    }\n\n    /**\n    * @notice adds or removes addresses from the whitelist.\n    * @param _investor is the address to whitelist\n    * @param _valid whether or not the address it to be added or removed from the whitelist\n    */\n    function modifyWhitelist(address _investor, bool _valid) public withPerm(WHITELIST) {emit __FunctionCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',6);\n\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',106);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',16);\nwhitelist[_investor] = _valid;\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',108);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',17);\nemit ModifyWhitelist(_investor, now, msg.sender, _valid);\n    }\n\n    /**\n    * @notice adds or removes addresses from the whitelist.\n    * @param _investors Array of the addresses to whitelist\n    * @param _valids Array of boolean value to decide whether or not the address it to be added or removed from the whitelist\n    */\n    function modifyWhitelistMulti(address[] _investors, bool[] _valids) public withPerm(WHITELIST) {emit __FunctionCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',7);\n\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',117);\n        emit __AssertPreCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',5);\nemit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',18);\nrequire(_investors.length == _valids.length, \"Input array length mis-match\");emit __AssertPostCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',5);\n\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',118);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',19);\nfor (uint i = 0; i < _investors.length; i++) {\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',119);\n            emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',20);\nmodifyWhitelist(_investors[i], _valids[i]);\n        }\n    }\n\n    /**\n    * @notice sets whether or not to consider primary issuance transfers\n    * @param _allowPrimaryIssuance whether to allow all primary issuance transfers\n    */\n    function setAllowPrimaryIssuance(bool _allowPrimaryIssuance) public withPerm(ADMIN) {emit __FunctionCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',8);\n\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',128);\n        emit __AssertPreCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',6);\nemit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',21);\nrequire(_allowPrimaryIssuance != allowPrimaryIssuance, \"Must change setting\");emit __AssertPostCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',6);\n\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',129);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',22);\nallowPrimaryIssuance = _allowPrimaryIssuance;\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',131);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',23);\nemit SetAllowPrimaryIssuance(_allowPrimaryIssuance, now);\n    }\n\n    /**\n     * @notice Return the permissions flag that are associated with Percentage transfer Manager\n     */\n    function getPermissions() public  returns(bytes32[]) {emit __FunctionCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',9);\n\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',138);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',24);\nbytes32[] memory allPermissions = new bytes32[](2);\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',139);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',25);\nallPermissions[0] = WHITELIST;\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',140);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',26);\nallPermissions[1] = ADMIN;\nemit __CoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',141);\n        emit __StatementCoveragePercentageTransferManager('./contracts/modules/TransferManager/PercentageTransferManager.sol',27);\nreturn allPermissions;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/PercentageTransferManagerFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./PercentageTransferManager.sol\";\nimport \"../ModuleFactory.sol\";\nimport \"../../libraries/Util.sol\";\n\n/**\n * @title Factory for deploying PercentageTransferManager module\n */\ncontract PercentageTransferManagerFactory is ModuleFactory {event __CoveragePercentageTransferManagerFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoveragePercentageTransferManagerFactory(string fileName, uint256 fnId);\nevent __StatementCoveragePercentageTransferManagerFactory(string fileName, uint256 statementId);\nevent __BranchCoveragePercentageTransferManagerFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoveragePercentageTransferManagerFactory(string fileName, uint256 branchId);\nevent __AssertPostCoveragePercentageTransferManagerFactory(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {emit __FunctionCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',1);\n\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',19);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',1);\nversion = \"1.0.0\";\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',20);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',2);\nname = \"PercentageTransferManager\";\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',21);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',3);\ntitle = \"Percentage Transfer Manager\";\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',22);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',4);\ndescription = \"Restrict the number of investors\";\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',23);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',5);\ncompatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',24);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',6);\ncompatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n    }\n\n    /**\n     * @notice used to launch the Module with the help of factory\n     * @param _data Data used for the intialization of the module factory variables\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes _data) external returns(address) {emit __FunctionCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',2);\n\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',33);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',7);\nif(setupCost > 0)\n            {emit __AssertPreCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',2);\nemit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',8);\nemit __BranchCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',1,0);emit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',34);\nrequire(polyToken.transferFrom(msg.sender, owner, setupCost), \"Failed transferFrom because of sufficent Allowance is not provided\");emit __AssertPostCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',2);\n}else { emit __BranchCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',1,1);}\n\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',35);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',9);\nPercentageTransferManager percentageTransferManager = new PercentageTransferManager(msg.sender, address(polyToken));\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',36);\n        emit __AssertPreCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',3);\nemit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',10);\nrequire(Util.getSig(_data) == percentageTransferManager.getInitFunction(), \"Provided data is not valid\");emit __AssertPostCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',3);\n\n        /*solium-disable-next-line security/no-low-level-calls*/\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',38);\n        emit __AssertPreCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',4);\nemit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',11);\nrequire(address(percentageTransferManager).call(_data), \"Unsuccessful call\");emit __AssertPostCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',4);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',40);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',12);\nemit GenerateModuleFromFactory(address(percentageTransferManager), getName(), address(this), msg.sender, setupCost, now);\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',41);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',13);\nreturn address(percentageTransferManager);\n\n    }\n\n    /**\n     * @notice Type of the Module factory\n     * @return uint8\n     */\n    function getTypes() external  returns(uint8[]) {emit __FunctionCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',3);\n\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',50);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',14);\nuint8[] memory res = new uint8[](1);\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',51);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',15);\nres[0] = 2;\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',52);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',16);\nreturn res;\n    }\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {emit __FunctionCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',4);\n\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',59);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',17);\nreturn \"Allows an issuer to restrict the total number of non-zero token holders\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {emit __FunctionCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',5);\n\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',66);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',18);\nbytes32[] memory availableTags = new bytes32[](2);\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',67);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',19);\navailableTags[0] = \"Percentage\";\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',68);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',20);\navailableTags[1] = \"Transfer Restriction\";\nemit __CoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',69);\n        emit __StatementCoveragePercentageTransferManagerFactory('./contracts/modules/TransferManager/PercentageTransferManagerFactory.sol',21);\nreturn availableTags;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/TransferManager/VolumeRestrictionTM.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ITransferManager.sol\";\nimport \"./VolumeRestrictionTMStorage.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"../../libraries/BokkyPooBahsDateTimeLibrary.sol\";\n\ncontract VolumeRestrictionTM is VolumeRestrictionTMStorage, ITransferManager {event __CoverageVolumeRestrictionTM(string fileName, uint256 lineNumber);\nevent __FunctionCoverageVolumeRestrictionTM(string fileName, uint256 fnId);\nevent __StatementCoverageVolumeRestrictionTM(string fileName, uint256 statementId);\nevent __BranchCoverageVolumeRestrictionTM(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageVolumeRestrictionTM(string fileName, uint256 branchId);\nevent __AssertPostCoverageVolumeRestrictionTM(string fileName, uint256 branchId);\n\n    \n    using SafeMath for uint256;\n\n    // permission definition\n    bytes32 public constant ADMIN = \"ADMIN\";\n\n    // Emit when the token holder is added/removed from the exemption list\n    event ChangedExemptWalletList(address indexed _wallet, bool _change);\n    // Emit when the new individual restriction is added corresponds to new token holders\n    event AddIndividualRestriction(\n        address indexed _holder,\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _rollingPeriodInDays,\n        uint256 _endTime,\n        uint256 _typeOfRestriction\n    );\n    // Emit when the new daily (Individual) restriction is added\n    event AddIndividualDailyRestriction(\n        address indexed _holder,\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _rollingPeriodInDays,\n        uint256 _endTime,\n        uint256 _typeOfRestriction\n    );\n    // Emit when the individual restriction is modified for a given address\n    event ModifyIndividualRestriction(\n        address indexed _holder,\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _rollingPeriodInDays,\n        uint256 _endTime,\n        uint256 _typeOfRestriction\n    );\n    // Emit when individual daily restriction get modified\n    event ModifyIndividualDailyRestriction(\n        address indexed _holder,\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _rollingPeriodInDays,\n        uint256 _endTime,\n        uint256 _typeOfRestriction\n    );\n    // Emit when the new global restriction is added\n    event AddDefaultRestriction(\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _rollingPeriodInDays,\n        uint256 _endTime,\n        uint256 _typeOfRestriction\n    );\n    // Emit when the new daily (Default) restriction is added\n    event AddDefaultDailyRestriction(\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _rollingPeriodInDays,\n        uint256 _endTime,\n        uint256 _typeOfRestriction\n    );\n    // Emit when default restriction get modified\n    event ModifyDefaultRestriction(\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _rollingPeriodInDays,\n        uint256 _endTime,\n        uint256 _typeOfRestriction\n    );\n    // Emit when daily default restriction get modified\n    event ModifyDefaultDailyRestriction(\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _rollingPeriodInDays,\n        uint256 _endTime,\n        uint256 _typeOfRestriction\n    );\n    // Emit when the individual restriction gets removed\n    event IndividualRestrictionRemoved(address indexed _holder);\n    // Emit when individual daily restriction removed\n    event IndividualDailyRestrictionRemoved(address indexed _holder);\n    // Emit when the default restriction gets removed\n    event DefaultRestrictionRemoved();\n    // Emit when the daily default restriction gets removed\n    event DefaultDailyRestrictionRemoved();\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress)\n    public\n    Module(_securityToken, _polyAddress)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1);\n\n\n    }\n\n    /**\n     * @notice Used to verify the transfer/transferFrom transaction and prevent tranaction\n     * whose volume of tokens will voilate the maximum volume transfer restriction\n     * @param _from Address of the sender\n     * @param _amount The amount of tokens to transfer\n     * @param _isTransfer Whether or not this is an actual transfer or just a test to see if the tokens would be transferrable\n     */\n    function verifyTransfer(address _from, address /*_to */, uint256 _amount, bytes /*_data*/, bool _isTransfer) public returns (Result) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',2);\n\n        // If `_from` is present in the exemptionList or it is `0x0` address then it will not follow the vol restriction\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',115);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1);\nif (!paused && _from != address(0) && !exemptList[_from]) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1,0);\n            // Function must only be called by the associated security token if _isTransfer == true\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',117);\n            emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',2);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',2);\nrequire(msg.sender == securityToken || !_isTransfer);emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',2);\n\n            // Checking the individual restriction if the `_from` comes in the individual category \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',119);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',3);\nif ((individualRestriction[_from].endTime >= now && individualRestriction[_from].startTime <= now) \n                || (individualDailyRestriction[_from].endTime >= now && individualDailyRestriction[_from].startTime <= now)) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',3,0);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',122);\n                emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',4);\nreturn _individualRestrictionCheck(_from, _amount, _isTransfer);\n                // If the `_from` doesn't fall under the individual category. It will processed with in the global category automatically\n            } else {emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',5);\nemit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',3,1);if ((defaultRestriction.endTime >= now && defaultRestriction.startTime <= now)\n                || (defaultDailyRestriction.endTime >= now && defaultDailyRestriction.startTime <= now)) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',4,0);\n                \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',127);\n                emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',6);\nreturn _defaultRestrictionCheck(_from, _amount, _isTransfer);\n            }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',4,1);}\n}\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1,1);}\n \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',130);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',7);\nreturn Result.NA;\n    }\n\n    /**\n     * @notice Add/Remove wallet address from the exempt list\n     * @param _wallet Ethereum wallet/contract address that need to be exempted\n     * @param _change Boolean value used to add (i.e true) or remove (i.e false) from the list \n     */\n    function changeExemptWalletList(address _wallet, bool _change) public withPerm(ADMIN) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',3);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',139);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',5);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',8);\nrequire(_wallet != address(0), \"Invalid address\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',5);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',140);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',9);\nexemptList[_wallet] = _change;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',141);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',10);\nemit ChangedExemptWalletList(_wallet, _change);\n    }\n\n    /**\n     * @notice Use to add the new individual restriction for a given token holder\n     * @param _holder Address of the token holder, whom restriction will be implied\n     * @param _allowedTokens Amount of tokens allowed to be trade for a given address.\n     * @param _startTime Unix timestamp at which restriction get into effect\n     * @param _rollingPeriodInDays Rolling period in days (Minimum value should be 1 day)\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\n     * @param _restrictionType It will be 0 or 1 (i.e 0 for fixed while 1 for Percentage)\n     */\n    function addIndividualRestriction(\n        address _holder,\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _rollingPeriodInDays,\n        uint256 _endTime,\n        uint256 _restrictionType \n    )\n        external\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',4);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',164);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',11);\n_addIndividualRestriction(\n            _holder,\n            _allowedTokens,\n            _startTime,\n            _rollingPeriodInDays,\n            _endTime,\n            _restrictionType\n        );\n    }\n\n    /// @notice Internal function to facilitate the addition of individual restriction\n    function _addIndividualRestriction(\n        address _holder,\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _rollingPeriodInDays,\n        uint256 _endTime,\n        uint256 _restrictionType \n    )\n        internal\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',5);\n   \n        \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',186);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',12);\nuint256 startTime = _startTime;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',187);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',13);\nif (_startTime == 0) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',6,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',188);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',14);\nstartTime = now;\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',6,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',190);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',7);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',15);\nrequire(\n            individualRestriction[_holder].endTime < now,\n            \"Already present\"\n        );emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',7);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',194);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',8);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',16);\nrequire(_holder != address(0) && !exemptList[_holder], \"Invalid address\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',8);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',195);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',9);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',17);\nrequire(startTime >= now, \"Invalid startTime\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',9);\n  \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',196);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',18);\n_checkInputParams(_allowedTokens, startTime, _rollingPeriodInDays, _endTime, _restrictionType);\n        \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',198);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',19);\nif (individualRestriction[_holder].endTime != 0) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',10,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',199);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',20);\n_removeIndividualRestriction(_holder);\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',10,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',201);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',21);\nindividualRestriction[_holder] = VolumeRestriction(\n            _allowedTokens,\n            startTime,\n            _rollingPeriodInDays,\n            _endTime,\n            RestrictionType(_restrictionType)\n        );\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',208);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',22);\nemit AddIndividualRestriction(\n            _holder,\n            _allowedTokens,\n            startTime,\n            _rollingPeriodInDays,\n            _endTime,\n            _restrictionType\n        );\n    }\n\n    /**\n     * @notice Use to add the new individual daily restriction for all token holder\n     * @param _holder Address of the token holder, whom restriction will be implied\n     * @param _allowedTokens Amount of tokens allowed to be traded for all token holder.\n     * @param _startTime Unix timestamp at which restriction get into effect\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\n     * @param _restrictionType It will be 0 or 1 (i.e 0 for fixed while 1 for Percentage)\n     */\n    function addIndividualDailyRestriction(\n        address _holder,\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _restrictionType \n    )\n        external\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',6);\n   \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',236);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',23);\n_addIndividualDailyRestriction(\n            _holder,\n            _allowedTokens,\n            _startTime,\n            _endTime,\n            _restrictionType\n        );\n    }\n\n    /// @notice Internal function to facilitate the addition of individual daily restriction\n    function _addIndividualDailyRestriction(\n        address _holder,\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _restrictionType \n    )\n        internal\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',7);\n   \n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',256);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',24);\nuint256 startTime = _startTime;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',257);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',25);\nif (_startTime == 0) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',11,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',258);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',26);\nstartTime = now;\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',11,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',260);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',12);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',27);\nrequire(\n            individualDailyRestriction[_holder].endTime < now,\n            \"Not Allowed\"\n        );emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',12);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',264);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',13);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',28);\nrequire(startTime >= now, \"Invalid startTime\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',13);\n  \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',265);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',29);\n_checkInputParams(_allowedTokens, startTime, 1, _endTime, _restrictionType);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',266);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',30);\nindividualDailyRestriction[_holder] = VolumeRestriction(\n            _allowedTokens,\n            startTime,\n            1,\n            _endTime,\n            RestrictionType(_restrictionType)\n        );\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',273);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',31);\nemit AddIndividualDailyRestriction(\n            _holder,\n            _allowedTokens,\n            startTime,\n            1,\n            _endTime,\n            _restrictionType\n        );\n    }\n\n    /**\n     * @notice Use to add the new individual daily restriction for multiple token holders\n     * @param _holders Array of address of the token holders, whom restriction will be implied\n     * @param _allowedTokens Array of amount of tokens allowed to be trade for a given address.\n     * @param _startTimes Array of unix timestamps at which restrictions get into effect\n     * @param _endTimes Array of unix timestamps at which restriction effects will gets end.\n     * @param _restrictionTypes Array of restriction types value will be 0 or 1 (i.e 0 for fixed while 1 for Percentage)\n     */\n    function addIndividualDailyRestrictionMulti(\n        address[] _holders,\n        uint256[] _allowedTokens,\n        uint256[] _startTimes,\n        uint256[] _endTimes,\n        uint256[] _restrictionTypes \n    )\n        public\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',8);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',301);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',14);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',32);\nrequire(\n            _allowedTokens.length == _startTimes.length &&\n            _startTimes.length == _holders.length &&\n            _holders.length == _endTimes.length &&\n            _endTimes.length == _restrictionTypes.length,\n            \"Array length mismatch\"\n        );emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',14);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',308);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',33);\nfor (uint256 i = 0; i < _holders.length; i++) {\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',309);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',34);\n_addIndividualDailyRestriction(\n                _holders[i],\n                _allowedTokens[i],\n                _startTimes[i],\n                _endTimes[i],\n                _restrictionTypes[i] \n            );\n        }\n    }\n\n    /**\n     * @notice Use to add the new individual restriction for multiple token holders\n     * @param _holders Array of address of the token holders, whom restriction will be implied\n     * @param _allowedTokens Array of amount of tokens allowed to be trade for a given address.\n     * @param _startTimes Array of unix timestamps at which restrictions get into effect\n     * @param _rollingPeriodInDays Array of rolling period in days (Minimum value should be 1 day)\n     * @param _endTimes Array of unix timestamps at which restriction effects will gets end.\n     * @param _restrictionTypes Array of restriction types value will be 0 or 1 (i.e 0 for fixed while 1 for Percentage)\n     */\n    function addIndividualRestrictionMulti(\n        address[] _holders,\n        uint256[] _allowedTokens,\n        uint256[] _startTimes,\n        uint256[] _rollingPeriodInDays,\n        uint256[] _endTimes,\n        uint256[] _restrictionTypes \n    )\n        public\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',9);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',339);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',35);\n_checkLengthOfArray(_allowedTokens, _startTimes, _rollingPeriodInDays, _endTimes, _restrictionTypes);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',340);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',15);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',36);\nrequire(_holders.length == _allowedTokens.length, \"Length mismatch\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',15);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',341);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',37);\nfor (uint256 i = 0; i < _holders.length; i++) {\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',342);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',38);\n_addIndividualRestriction(\n                _holders[i],\n                _allowedTokens[i],\n                _startTimes[i],\n                _rollingPeriodInDays[i],\n                _endTimes[i],\n                _restrictionTypes[i] \n            );\n        }\n    }\n\n    /**\n     * @notice Use to add the new default restriction for all token holder\n     * @param _allowedTokens Amount of tokens allowed to be traded for all token holder.\n     * @param _startTime Unix timestamp at which restriction get into effect\n     * @param _rollingPeriodInDays Rolling period in days (Minimum value should be 1 day)\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\n     * @param _restrictionType It will be 0 or 1 (i.e 0 for fixed while 1 for Percentage)\n     */\n    function addDefaultRestriction(\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _rollingPeriodInDays,\n        uint256 _endTime,\n        uint256 _restrictionType \n    )\n        external\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',10);\n   \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',371);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',39);\nuint256 startTime = _startTime;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',372);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',40);\nif (_startTime == 0) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',16,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',373);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',41);\nstartTime = now;\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',16,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',375);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',17);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',42);\nrequire(\n            defaultRestriction.endTime < now,\n            \"Not allowed\"\n        );emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',17);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',379);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',18);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',43);\nrequire(startTime >= now, \"Invalid startTime\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',18);\n  \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',380);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',44);\n_checkInputParams(_allowedTokens, startTime, _rollingPeriodInDays, _endTime, _restrictionType);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',381);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',45);\ndefaultRestriction = VolumeRestriction(\n            _allowedTokens,\n            startTime,\n            _rollingPeriodInDays,\n            _endTime,\n            RestrictionType(_restrictionType)\n        );\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',388);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',46);\nemit AddDefaultRestriction(\n            _allowedTokens,\n            startTime,\n            _rollingPeriodInDays,\n            _endTime,\n            _restrictionType\n        );\n    }\n\n    /**\n     * @notice Use to add the new default daily restriction for all token holder\n     * @param _allowedTokens Amount of tokens allowed to be traded for all token holder.\n     * @param _startTime Unix timestamp at which restriction get into effect\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\n     * @param _restrictionType It will be 0 or 1 (i.e 0 for fixed while 1 for Percentage)\n     */\n    function addDefaultDailyRestriction(\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _restrictionType \n    )\n        external\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',11);\n   \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',413);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',47);\nuint256 startTime = _startTime;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',414);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',48);\nif (_startTime == 0) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',19,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',415);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',49);\nstartTime = now;\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',19,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',417);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',20);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',50);\nrequire(\n            defaultDailyRestriction.endTime < now,\n            \"Not Allowed\"\n        );emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',20);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',421);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',21);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',51);\nrequire(startTime >= now, \"Invalid startTime\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',21);\n  \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',422);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',52);\n_checkInputParams(_allowedTokens, startTime, 1, _endTime, _restrictionType);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',423);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',53);\ndefaultDailyRestriction = VolumeRestriction(\n            _allowedTokens,\n            startTime,\n            1,\n            _endTime,\n            RestrictionType(_restrictionType)\n        );\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',430);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',54);\nemit AddDefaultDailyRestriction(\n            _allowedTokens,\n            startTime,\n            1,\n            _endTime,\n            _restrictionType\n        );\n    }\n\n    /**\n     * @notice use to remove the individual restriction for a given address\n     * @param _holder Address of the user \n     */\n    function removeIndividualRestriction(address _holder) external withPerm(ADMIN) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',12);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',444);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',55);\n_removeIndividualRestriction(_holder);\n    }\n\n    /// @notice Internal function to facilitate the removal of individual restriction\n    function _removeIndividualRestriction(address _holder) internal {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',13);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',449);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',22);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',56);\nrequire(_holder != address(0), \"Invalid address\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',22);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',450);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',23);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',57);\nrequire(individualRestriction[_holder].endTime != 0, \"Not present\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',23);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',451);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',58);\nindividualRestriction[_holder] = VolumeRestriction(0, 0, 0, 0, RestrictionType(0));\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',452);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',59);\nuserToBucket[_holder].lastTradedDayTime = 0;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',453);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',60);\nuserToBucket[_holder].sumOfLastPeriod = 0;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',454);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',61);\nuserToBucket[_holder].daysCovered = 0;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',455);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',62);\nemit IndividualRestrictionRemoved(_holder);\n    }\n\n    /**\n     * @notice use to remove the individual restriction for a given address\n     * @param _holders Array of address of the user \n     */\n    function removeIndividualRestrictionMulti(address[] _holders) external withPerm(ADMIN) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',14);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',463);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',63);\nfor (uint256 i = 0; i < _holders.length; i++) {\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',464);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',64);\n_removeIndividualRestriction(_holders[i]);\n        }\n    }\n\n    /**\n     * @notice use to remove the individual daily restriction for a given address\n     * @param _holder Address of the user \n     */\n    function removeIndividualDailyRestriction(address _holder) external withPerm(ADMIN) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',15);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',473);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',65);\n_removeIndividualDailyRestriction(_holder);\n    }\n\n    /// @notice Internal function to facilitate the removal of individual daily restriction\n    function _removeIndividualDailyRestriction(address _holder) internal {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',16);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',478);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',24);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',66);\nrequire(_holder != address(0), \"Invalid address\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',24);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',479);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',25);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',67);\nrequire(individualDailyRestriction[_holder].endTime != 0, \"Not present\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',25);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',480);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',68);\nindividualDailyRestriction[_holder] = VolumeRestriction(0, 0, 0, 0, RestrictionType(0));\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',481);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',69);\nuserToBucket[_holder].dailyLastTradedDayTime = 0;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',482);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',70);\nemit IndividualDailyRestrictionRemoved(_holder);\n    }\n\n    /**\n     * @notice use to remove the individual daily restriction for a given address\n     * @param _holders Array of address of the user \n     */\n    function removeIndividualDailyRestrictionMulti(address[] _holders) external withPerm(ADMIN) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',17);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',490);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',71);\nfor (uint256 i = 0; i < _holders.length; i++) {\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',491);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',72);\n_removeIndividualDailyRestriction(_holders[i]);\n        }\n    }\n\n    /**\n     * @notice Use to remove the default restriction\n     */\n    function removeDefaultRestriction() public withPerm(ADMIN) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',18);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',499);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',26);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',73);\nrequire(defaultRestriction.endTime != 0);emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',26);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',500);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',74);\ndefaultRestriction = VolumeRestriction(0, 0, 0, 0, RestrictionType(0));\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',501);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',75);\nemit DefaultRestrictionRemoved();\n    }\n\n    /**\n     * @notice Use to remove the daily default restriction\n     */\n    function removeDefaultDailyRestriction() external withPerm(ADMIN) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',19);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',508);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',27);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',76);\nrequire(defaultDailyRestriction.endTime != 0);emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',27);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',509);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',77);\ndefaultDailyRestriction = VolumeRestriction(0, 0, 0, 0, RestrictionType(0));\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',510);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',78);\nemit DefaultDailyRestrictionRemoved();\n    } \n\n    /**\n     * @notice Use to modify the existing individual restriction for a given token holder\n     * @param _holder Address of the token holder, whom restriction will be implied\n     * @param _allowedTokens Amount of tokens allowed to be trade for a given address.\n     * @param _startTime Unix timestamp at which restriction get into effect\n     * @param _rollingPeriodInDays Rolling period in days (Minimum value should be 1 day)\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\n     * @param _restrictionType It will be 0 or 1 (i.e 0 for fixed while 1 for Percentage)\n     */\n    function modifyIndividualRestriction(\n        address _holder,\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _rollingPeriodInDays,\n        uint256 _endTime,\n        uint256 _restrictionType \n    )\n        external\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',20);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',533);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',79);\n_modifyIndividualRestriction(\n            _holder,\n            _allowedTokens,\n            _startTime,\n            _rollingPeriodInDays,\n            _endTime,\n            _restrictionType\n        );\n    }\n\n    /// @notice Internal function to facilitate the modification of individual restriction\n    function _modifyIndividualRestriction(\n        address _holder,\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _rollingPeriodInDays,\n        uint256 _endTime,\n        uint256 _restrictionType \n    )\n        internal\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',21);\n   \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',554);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',80);\nuint256 startTime = _startTime;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',555);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',81);\nif (_startTime == 0) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',28,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',556);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',82);\nstartTime = now;\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',28,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',558);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',29);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',83);\nrequire(individualRestriction[_holder].startTime > now, \"Not allowed\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',29);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',559);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',30);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',84);\nrequire(startTime >= now, \"Invalid startTime\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',30);\n  \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',560);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',85);\n_checkInputParams(_allowedTokens, startTime, _rollingPeriodInDays, _endTime, _restrictionType);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',561);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',86);\nindividualRestriction[_holder] = VolumeRestriction(\n            _allowedTokens,\n            startTime,\n            _rollingPeriodInDays,\n            _endTime,\n            RestrictionType(_restrictionType)\n        );\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',568);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',87);\nemit ModifyIndividualRestriction(\n            _holder,\n            _allowedTokens,\n            startTime,\n            _rollingPeriodInDays,\n            _endTime,\n            _restrictionType\n        );\n    }\n\n    /**\n     * @notice Use to modify the existing individual daily restriction for a given token holder\n     * @dev Changing of startTime will affect the 24 hrs span. i.e if in earlier restriction days start with\n     * morning and end on midnight while after the change day may start with afternoon and end with other day afternoon\n     * @param _holder Address of the token holder, whom restriction will be implied\n     * @param _allowedTokens Amount of tokens allowed to be trade for a given address.\n     * @param _startTime Unix timestamp at which restriction get into effect\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\n     * @param _restrictionType It will be 0 or 1 (i.e 0 for fixed while 1 for Percentage)\n     */\n    function modifyIndividualDailyRestriction(\n        address _holder,\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _restrictionType \n    )\n        external\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',22);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',598);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',88);\n_modifyIndividualDailyRestriction(\n            _holder,\n            _allowedTokens,\n            _startTime,\n            _endTime,\n            _restrictionType\n        );\n    }\n\n    /// @notice Internal function to facilitate the modification of individual daily restriction\n    function _modifyIndividualDailyRestriction(\n        address _holder,\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _restrictionType \n    )\n        internal\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',23);\n   \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',617);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',89);\nuint256 startTime = _startTime;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',618);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',90);\nif (_startTime == 0) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',31,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',619);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',91);\nstartTime = now;\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',31,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',621);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',92);\n_checkInputParams(_allowedTokens, startTime, 1, _endTime, _restrictionType);\n        // If old startTime is already passed then new startTime should be greater than or equal to the \n        // old startTime otherwise any past startTime can be allowed in compare to earlier startTime.\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',624);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',93);\nif (individualDailyRestriction[_holder].startTime <= now) \n            {emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',33);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',94);\nemit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',32,0);emit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',625);\nrequire(startTime >= individualDailyRestriction[_holder].startTime, \"Invalid StartTime\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',33);\n}\n        else \n            {emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',34);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',95);\nemit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',32,1);emit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',627);\nrequire(startTime >= now);emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',34);\n}\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',628);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',96);\nindividualDailyRestriction[_holder] = VolumeRestriction(\n            _allowedTokens,\n            startTime,\n            1,\n            _endTime,\n            RestrictionType(_restrictionType)\n        );\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',635);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',97);\nemit ModifyIndividualDailyRestriction(\n            _holder,\n            _allowedTokens,\n            startTime,\n            1,\n            _endTime,\n            _restrictionType\n        );\n    }\n\n    /**\n     * @notice Use to modify the existing individual daily restriction for multiple token holders\n     * @param _holders Array of address of the token holders, whom restriction will be implied\n     * @param _allowedTokens Array of amount of tokens allowed to be trade for a given address.\n     * @param _startTimes Array of unix timestamps at which restrictions get into effect\n     * @param _endTimes Array of unix timestamps at which restriction effects will gets end.\n     * @param _restrictionTypes Array of restriction types value will be 0 or 1 (i.e 0 for fixed while 1 for Percentage)\n     */\n    function modifyIndividualDailyRestrictionMulti(\n        address[] _holders,\n        uint256[] _allowedTokens,\n        uint256[] _startTimes,\n        uint256[] _endTimes,\n        uint256[] _restrictionTypes  \n    )\n        public\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',24);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',663);\n       emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',35);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',98);\nrequire(\n            _allowedTokens.length == _startTimes.length &&\n            _startTimes.length == _holders.length &&\n            _holders.length == _endTimes.length &&\n            _endTimes.length == _restrictionTypes.length,\n            \"Array length mismatch\"\n        );emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',35);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',670);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',36);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',99);\nrequire(_holders.length == _allowedTokens.length, \"Length mismatch\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',36);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',671);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',100);\nfor (uint256 i = 0; i < _holders.length; i++) {\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',672);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',101);\n_modifyIndividualDailyRestriction(\n                _holders[i],\n                _allowedTokens[i],\n                _startTimes[i],\n                _endTimes[i],\n                _restrictionTypes[i] \n            );\n        }\n    } \n\n    /**\n     * @notice Use to modify the existing individual restriction for multiple token holders\n     * @param _holders Array of address of the token holders, whom restriction will be implied\n     * @param _allowedTokens Array of amount of tokens allowed to be trade for a given address.\n     * @param _startTimes Array of unix timestamps at which restrictions get into effect\n     * @param _rollingPeriodInDays Array of rolling period in days (Minimum value should be 1 day)\n     * @param _endTimes Array of unix timestamps at which restriction effects will gets end.\n     * @param _restrictionTypes Array of restriction types value will be 0 or 1 (i.e 0 for fixed while 1 for Percentage)\n     */\n    function modifyIndividualRestrictionMulti(\n        address[] _holders,\n        uint256[] _allowedTokens,\n        uint256[] _startTimes,\n        uint256[] _rollingPeriodInDays,\n        uint256[] _endTimes,\n        uint256[] _restrictionTypes  \n    )\n        public\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',25);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',702);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',102);\n_checkLengthOfArray(_allowedTokens, _startTimes, _rollingPeriodInDays, _endTimes, _restrictionTypes);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',703);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',37);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',103);\nrequire(_holders.length == _allowedTokens.length, \"Length mismatch\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',37);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',704);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',104);\nfor (uint256 i = 0; i < _holders.length; i++) {\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',705);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',105);\n_modifyIndividualRestriction(\n                _holders[i],\n                _allowedTokens[i],\n                _startTimes[i],\n                _rollingPeriodInDays[i],\n                _endTimes[i],\n                _restrictionTypes[i] \n            );\n        }\n    } \n\n    /**\n     * @notice Use to modify the global restriction for all token holder\n     * @param _allowedTokens Amount of tokens allowed to be traded for all token holder.\n     * @param _startTime Unix timestamp at which restriction get into effect\n     * @param _rollingPeriodInDays Rolling period in days (Minimum value should be 1 day)\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\n     * @param _restrictionType It will be 0 or 1 (i.e 0 for fixed while 1 for Percentage)\n     */\n    function modifyDefaultRestriction(\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _rollingPeriodInDays,\n        uint256 _endTime,\n        uint256 _restrictionType\n    )\n        external\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',26);\n   \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',734);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',38);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',106);\nrequire(defaultRestriction.startTime > now, \"Not allowed\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',38);\n \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',735);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',107);\nuint256 startTime = _startTime;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',736);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',108);\nif (_startTime == 0) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',39,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',737);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',109);\nstartTime = now;\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',39,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',739);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',40);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',110);\nrequire(startTime >= now, \"Invalid startTime\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',40);\n      \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',740);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',111);\n_checkInputParams(_allowedTokens, startTime, _rollingPeriodInDays, _endTime, _restrictionType);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',741);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',112);\ndefaultRestriction = VolumeRestriction(\n            _allowedTokens,\n            startTime,\n            _rollingPeriodInDays,\n            _endTime,\n            RestrictionType(_restrictionType)\n        );\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',748);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',113);\nemit ModifyDefaultRestriction(\n            _allowedTokens,\n            startTime,\n            _rollingPeriodInDays,\n            _endTime,\n            _restrictionType\n        );\n    }\n\n    /**\n     * @notice Use to modify the daily default restriction for all token holder\n     * @dev Changing of startTime will affect the 24 hrs span. i.e if in earlier restriction days start with\n     * morning and end on midnight while after the change day may start with afternoon and end with other day afternoon.\n     * @param _allowedTokens Amount of tokens allowed to be traded for all token holder.\n     * @param _startTime Unix timestamp at which restriction get into effect\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\n     * @param _restrictionType It will be 0 or 1 (i.e 0 for fixed while 1 for Percentage)\n     */\n    function modifyDefaultDailyRestriction(\n        uint256 _allowedTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _restrictionType\n    )\n        external\n        withPerm(ADMIN)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',27);\n   \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',775);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',114);\nuint256 startTime = _startTime;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',776);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',115);\nif (_startTime == 0) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',41,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',777);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',116);\nstartTime = now;\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',41,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',779);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',117);\n_checkInputParams(_allowedTokens, startTime, 1, _endTime, _restrictionType);\n        // If old startTime is already passed then new startTime should be greater than or equal to the \n        // old startTime otherwise any past startTime can be allowed in compare to earlier startTime.\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',782);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',118);\nif (defaultDailyRestriction.startTime <= now) \n            {emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',43);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',119);\nemit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',42,0);emit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',783);\nrequire(startTime >= defaultDailyRestriction.startTime, \"Invalid StartTime\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',43);\n}\n        else \n            {emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',44);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',120);\nemit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',42,1);emit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',785);\nrequire(startTime >= now);emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',44);\n} \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',786);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',121);\ndefaultDailyRestriction = VolumeRestriction(\n            _allowedTokens,\n            startTime,\n            1,\n            _endTime,\n            RestrictionType(_restrictionType)\n        );\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',793);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',122);\nemit ModifyDefaultDailyRestriction(\n            _allowedTokens,\n            startTime,\n            1,\n            _endTime,\n            _restrictionType\n        );\n    }\n\n    /**\n    * @notice Internal function used to validate the transaction for a given address\n    * If it validates then it also update the storage corressponds to the default restriction\n    */\n    function _defaultRestrictionCheck(address _from, uint256 _amount, bool _isTransfer) internal returns (Result) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',28);\n   \n        // using the variable to avoid stack too deep error\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',808);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',123);\nBucketDetails memory bucketDetails = defaultUserToBucket[_from];\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',809);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',124);\nuint256 daysCovered = defaultRestriction.rollingPeriodInDays;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',810);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',125);\nuint256 fromTimestamp = 0;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',811);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',126);\nuint256 sumOfLastPeriod = 0;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',812);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',127);\nuint256 dailyTime = 0;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',813);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',128);\nbool allowedDefault = true;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',814);\n        bool allowedDaily;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',815);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',129);\nif (defaultRestriction.endTime >= now && defaultRestriction.startTime <= now) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',45,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',816);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',130);\nif (bucketDetails.lastTradedDayTime < defaultRestriction.startTime) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',46,0);\n                // It will execute when the txn is performed first time after the addition of individual restriction\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',818);\n                emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',131);\nfromTimestamp = defaultRestriction.startTime;\n            } else {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',46,1);\n                // Picking up the last timestamp\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',821);\n                emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',132);\nfromTimestamp = bucketDetails.lastTradedDayTime;\n            }\n        \n            // Check with the bucket and parse all the new timestamps to calculate the sumOfLastPeriod\n            // re-using the local variables to avoid the stack too deep error.\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',826);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',133);\n(sumOfLastPeriod, fromTimestamp, daysCovered) = _bucketCheck(\n                fromTimestamp,\n                BokkyPooBahsDateTimeLibrary.diffDays(fromTimestamp, now),\n                _from,\n                daysCovered,\n                bucketDetails\n            );\n            // validation of the transaction amount\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',834);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',134);\nif (!_checkValidAmountToTransact(sumOfLastPeriod, _amount, defaultRestriction)) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',47,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',835);\n                emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',135);\nallowedDefault = false;\n            }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',47,1);}\n\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',45,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',838);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',136);\n(allowedDaily, dailyTime) = _dailyTxCheck(_from, _amount, bucketDetails.dailyLastTradedDayTime, defaultDailyRestriction);\n        \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',840);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',137);\nif (_isTransfer) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',48,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',841);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',138);\n_updateStorage(\n                _from,\n                _amount,\n                fromTimestamp,\n                sumOfLastPeriod,\n                daysCovered,\n                dailyTime,\n                defaultDailyRestriction.endTime,\n                true\n            );\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',48,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',852);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',139);\nreturn ((allowedDaily && allowedDefault) == true ? Result.NA : Result.INVALID);\n    }\n\n    /**\n     * @notice Internal function used to validate the transaction for a given address\n     * If it validates then it also update the storage corressponds to the individual restriction\n     */\n    function _individualRestrictionCheck(address _from, uint256 _amount, bool _isTransfer) internal returns (Result) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',29);\n   \n        // using the variable to avoid stack too deep error\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',861);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',140);\nBucketDetails memory bucketDetails = userToBucket[_from];\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',862);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',141);\nVolumeRestriction memory dailyRestriction = individualDailyRestriction[_from];\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',863);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',142);\nVolumeRestriction memory restriction = individualRestriction[_from];\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',864);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',143);\nuint256 daysCovered = individualRestriction[_from].rollingPeriodInDays;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',865);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',144);\nuint256 fromTimestamp = 0;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',866);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',145);\nuint256 sumOfLastPeriod = 0;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',867);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',146);\nuint256 dailyTime = 0;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',868);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',147);\nbool allowedIndividual = true;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',869);\n        bool allowedDaily;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',870);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',148);\nif (restriction.endTime >= now && restriction.startTime <= now) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',49,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',871);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',149);\nif (bucketDetails.lastTradedDayTime < restriction.startTime) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',50,0);\n                // It will execute when the txn is performed first time after the addition of individual restriction\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',873);\n                emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',150);\nfromTimestamp = restriction.startTime;\n            } else {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',50,1);\n                // Picking up the last timestamp\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',876);\n                emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',151);\nfromTimestamp = bucketDetails.lastTradedDayTime;\n            }\n        \n            // Check with the bucket and parse all the new timestamps to calculate the sumOfLastPeriod\n            // re-using the local variables to avoid the stack too deep error.\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',881);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',152);\n(sumOfLastPeriod, fromTimestamp, daysCovered) = _bucketCheck(\n                fromTimestamp,\n                BokkyPooBahsDateTimeLibrary.diffDays(fromTimestamp, now),\n                _from,\n                daysCovered,\n                bucketDetails\n            );\n            // validation of the transaction amount\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',889);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',153);\nif (!_checkValidAmountToTransact(sumOfLastPeriod, _amount, restriction)) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',51,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',890);\n                emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',154);\nallowedIndividual = false;\n            }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',51,1);}\n\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',49,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',893);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',155);\n(allowedDaily, dailyTime) = _dailyTxCheck(_from, _amount, bucketDetails.dailyLastTradedDayTime, dailyRestriction);\n        \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',895);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',156);\nif (_isTransfer) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',52,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',896);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',157);\n_updateStorage(\n                _from,\n                _amount,\n                fromTimestamp,\n                sumOfLastPeriod,\n                daysCovered,\n                dailyTime,\n                dailyRestriction.endTime,\n                false\n            );\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',52,1);}\n\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',908);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',158);\nreturn ((allowedDaily && allowedIndividual) ? Result.NA : Result.INVALID);\n    }\n\n    function _dailyTxCheck(\n        address from,\n        uint256 amount,\n        uint256 dailyLastTradedDayTime,\n        VolumeRestriction restriction\n    ) \n        internal\n        \n        returns(bool, uint256)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',30);\n\n        // Checking whether the daily restriction is added or not if yes then calculate\n        // the total amount get traded on a particular day (~ _fromTime)\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',923);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',159);\nif ( now <= restriction.endTime && now >= restriction.startTime) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',53,0);   \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',924);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',160);\nuint256 txSumOfDay = 0;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',925);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',161);\nif (dailyLastTradedDayTime == 0 || dailyLastTradedDayTime < restriction.startTime)\n                // This if condition will be executed when the individual daily restriction executed first time\n                {emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',162);\nemit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',54,0);emit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',927);\ndailyLastTradedDayTime = restriction.startTime.add(BokkyPooBahsDateTimeLibrary.diffDays(restriction.startTime, now).mul(1 days));}\n            else {emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',163);\nemit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',54,1);if (now.sub(dailyLastTradedDayTime) >= 1 days)\n                {emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',164);\nemit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',55,0);emit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',929);\ndailyLastTradedDayTime = dailyLastTradedDayTime.add(BokkyPooBahsDateTimeLibrary.diffDays(dailyLastTradedDayTime, now).mul(1 days));}else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',55,1);}\n}\n            // Assgining total sum traded on dailyLastTradedDayTime timestamp\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',931);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',165);\ntxSumOfDay = bucket[from][dailyLastTradedDayTime];\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',932);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',166);\nreturn (_checkValidAmountToTransact(txSumOfDay, amount, restriction), dailyLastTradedDayTime);\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',53,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',934);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',167);\nreturn (true, dailyLastTradedDayTime);\n    }\n\n    /// Internal function for the bucket check\n    function _bucketCheck(\n        uint256 _fromTime,\n        uint256 _diffDays,\n        address _from,\n        uint256 _rollingPeriodInDays,\n        BucketDetails memory _bucketDetails\n    )\n        internal\n        \n        returns (uint256, uint256, uint256)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',31);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',949);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',168);\nuint256 counter = _bucketDetails.daysCovered;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',950);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',169);\nuint256 sumOfLastPeriod = _bucketDetails.sumOfLastPeriod;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',951);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',170);\nuint256 i = 0;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',952);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',171);\nif (_diffDays >= _rollingPeriodInDays) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',56,0);\n            // If the difference of days is greater than the rollingPeriod then sumOfLastPeriod will always be zero\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',954);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',172);\nsumOfLastPeriod = 0;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',955);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',173);\ncounter = counter.add(_diffDays);\n        } else {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',56,1);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',957);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',174);\nfor (i = 0; i < _diffDays; i++) {\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',958);\n            counter++;\n            // This condition is to check whether the first rolling period is covered or not\n            // if not then it continues and adding 0 value into sumOfLastPeriod without subtracting\n            // the earlier value at that index\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',962);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',175);\nif (counter >= _rollingPeriodInDays) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',57,0);\n                // Subtracting the former value(Sum of all the txn amount of that day) from the sumOfLastPeriod\n                // The below line subtracts (the traded volume on days no longer covered by rolling period) from sumOfLastPeriod.\n                // Every loop execution subtracts one day's trade volume. \n                // Loop starts from the first day covered in sumOfLastPeriod upto the day that is covered by rolling period.\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',967);\n                emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',176);\nsumOfLastPeriod = \n                    sumOfLastPeriod.sub(\n                        bucket[_from][_bucketDetails.lastTradedDayTime.sub(\n                            (\n                                _bucketDetails.daysCovered.sub(\n                                    counter.sub(\n                                        _rollingPeriodInDays\n                                    )\n                                )\n                            ).mul(1 days)\n                        )]\n                    );\n            }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',57,1);}\n\n            // Adding the last amount that is transacted on the `_fromTime` not actually doing it but left written to understand\n            // the alogrithm\n            //_bucketDetails.sumOfLastPeriod = _bucketDetails.sumOfLastPeriod.add(uint256(0));\n            }\n        }\n        // calculating the timestamp that will used as an index of the next bucket\n        // i.e buckets period will be look like this T1 to T2-1, T2 to T3-1 .... \n        // where T1,T2,T3 are timestamps having 24 hrs difference\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',988);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',177);\n_fromTime = _fromTime.add(_diffDays.mul(1 days));\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',989);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',178);\nreturn (sumOfLastPeriod, _fromTime, counter);\n    }\n\n    function _checkValidAmountToTransact(\n        uint256 _sumOfLastPeriod,\n        uint256 _amountToTransact,\n        VolumeRestriction _restriction\n    ) \n        internal\n        \n        returns (bool)\n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',32);\n    \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1001);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',179);\nuint256 _allowedAmount = 0;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1002);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',180);\nif (_restriction.typeOfRestriction == RestrictionType.Percentage) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',58,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1003);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',181);\n_allowedAmount = (_restriction.allowedTokens.mul(ISecurityToken(securityToken).totalSupply())) / uint256(10) ** 18;\n        } else {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',58,1);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1005);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',182);\n_allowedAmount = _restriction.allowedTokens;\n        }\n        // Validation on the amount to transact\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1008);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',183);\nreturn (_allowedAmount >= _sumOfLastPeriod.add(_amountToTransact));\n    }\n\n    function _updateStorage(\n        address _from,\n        uint256 _amount,\n        uint256 _lastTradedDayTime,\n        uint256 _sumOfLastPeriod,\n        uint256 _daysCovered, \n        uint256 _dailyLastTradedDayTime,\n        uint256 _endTime,\n        bool isDefault\n    )\n        internal \n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',33);\n   \n        \nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1024);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',184);\nif (isDefault){emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',59,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1025);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',185);\nBucketDetails storage defaultUserToBucketDetails = defaultUserToBucket[_from];\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1026);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',186);\n_updateStorageActual(_from, _amount, _lastTradedDayTime, _sumOfLastPeriod, _daysCovered, _dailyLastTradedDayTime, _endTime, defaultUserToBucketDetails);\n        }\n        else {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',59,1);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1029);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',187);\nBucketDetails storage userToBucketDetails = userToBucket[_from];\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1030);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',188);\n_updateStorageActual(_from, _amount, _lastTradedDayTime, _sumOfLastPeriod, _daysCovered, _dailyLastTradedDayTime, _endTime, userToBucketDetails);\n        }\n    }\n\n    function _updateStorageActual(\n        address _from,\n        uint256 _amount,\n        uint256 _lastTradedDayTime,\n        uint256 _sumOfLastPeriod,\n        uint256 _daysCovered, \n        uint256 _dailyLastTradedDayTime,\n        uint256 _endTime,\n        BucketDetails storage details\n    )\n        internal \n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',34);\n   \n        // Cheap storage technique\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1047);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',189);\nif (details.lastTradedDayTime != _lastTradedDayTime) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',60,0);\n            // Assigning the latest transaction timestamp of the day\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1049);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',190);\ndetails.lastTradedDayTime = _lastTradedDayTime;\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',60,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1051);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',191);\nif (details.dailyLastTradedDayTime != _dailyLastTradedDayTime) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',61,0);\n            // Assigning the latest transaction timestamp of the day\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1053);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',192);\ndetails.dailyLastTradedDayTime = _dailyLastTradedDayTime;\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',61,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1055);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',193);\nif (details.daysCovered != _daysCovered) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',62,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1056);\n                emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',194);\ndetails.daysCovered = _daysCovered;\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',62,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1058);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',195);\nif (_amount != 0) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',63,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1059);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',196);\nif (_lastTradedDayTime !=0) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',64,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1060);\n                emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',197);\ndetails.sumOfLastPeriod = _sumOfLastPeriod.add(_amount);\n                // Increasing the total amount of the day by `_amount`\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1062);\n                emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',198);\nbucket[_from][_lastTradedDayTime] = bucket[_from][_lastTradedDayTime].add(_amount);\n            }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',64,1);}\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1064);\n            emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',199);\nif ((_dailyLastTradedDayTime != _lastTradedDayTime) && _dailyLastTradedDayTime != 0 && now <= _endTime) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',65,0);\n                // Increasing the total amount of the day by `_amount`\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1066);\n                emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',200);\nbucket[_from][_dailyLastTradedDayTime] = bucket[_from][_dailyLastTradedDayTime].add(_amount);\n            }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',65,1);}\n\n        }else { emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',63,1);}\n  \n    }\n\n    function _checkInputParams(\n        uint256 _allowedTokens,\n        uint256 _startTime, \n        uint256 _rollingPeriodDays, \n        uint256 _endTime,\n        uint256 _restrictionType \n    ) \n        internal\n        \n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',35);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1081);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',66);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',201);\nrequire(_restrictionType == 0 || _restrictionType == 1, \"Invalid type\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',66);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1082);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',202);\nif (_restrictionType == uint256(RestrictionType.Fixed)) {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',67,0);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1083);\n            emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',68);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',203);\nrequire(_allowedTokens > 0, \"Invalid value\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',68);\n\n        } else {emit __BranchCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',67,1);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1085);\n            emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',69);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',204);\nrequire(\n                _allowedTokens > 0 && _allowedTokens <= 100 * 10 ** 16,\n                \"Percentage is not within (0,100]\"\n            );emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',69);\n\n        }\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1090);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',70);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',205);\nrequire(_endTime > _startTime, \"Invalid times\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',70);\n\n        // Maximum limit for the rollingPeriod is 365 days\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1092);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',71);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',206);\nrequire(_rollingPeriodDays >= 1 && _rollingPeriodDays <= 365, \"Invalid rollingperiod\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',71);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1093);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',72);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',207);\nrequire(BokkyPooBahsDateTimeLibrary.diffDays(_startTime, _endTime) >= _rollingPeriodDays, \"Invalid start & end time\");emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',72);\n\n    }   \n\n    function _checkLengthOfArray(\n        uint256[] _allowedTokens,\n        uint256[] _startTimes,\n        uint256[] _rollingPeriodInDays,\n        uint256[] _endTimes,\n        uint256[] _restrictionTypes\n    )\n        internal\n         \n    {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',36);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1106);\n        emit __AssertPreCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',73);\nemit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',208);\nrequire(\n            _allowedTokens.length == _startTimes.length &&\n            _startTimes.length == _rollingPeriodInDays.length &&\n            _rollingPeriodInDays.length == _endTimes.length &&\n            _endTimes.length == _restrictionTypes.length,\n            \"Array length mismatch\"\n        );emit __AssertPostCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',73);\n\n    }\n\n    /**\n     * @notice Use to get the bucket details for a given address\n     * @param _user Address of the token holder for whom the bucket details has queried\n     * @return uint256 lastTradedDayTime\n     * @return uint256 sumOfLastPeriod\n     * @return uint256 days covered\n     * @return uint256 24h lastTradedDayTime\n     */\n    function getIndividualBucketDetailsToUser(address _user) external  returns(uint256, uint256, uint256, uint256) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',37);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1124);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',209);\nreturn(\n            userToBucket[_user].lastTradedDayTime,\n            userToBucket[_user].sumOfLastPeriod,\n            userToBucket[_user].daysCovered,\n            userToBucket[_user].dailyLastTradedDayTime\n        );\n    }\n\n    /**\n     * @notice Use to get the bucket details for a given address\n     * @param _user Address of the token holder for whom the bucket details has queried\n     * @return uint256 lastTradedDayTime\n     * @return uint256 sumOfLastPeriod\n     * @return uint256 days covered\n     * @return uint256 24h lastTradedDayTime\n     */\n    function getDefaultBucketDetailsToUser(address _user) external  returns(uint256, uint256, uint256, uint256) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',38);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1141);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',210);\nreturn(\n            defaultUserToBucket[_user].lastTradedDayTime,\n            defaultUserToBucket[_user].sumOfLastPeriod,\n            defaultUserToBucket[_user].daysCovered,\n            defaultUserToBucket[_user].dailyLastTradedDayTime\n        );\n    }\n\n    /**\n     * @notice Use to get the volume of token that being traded at a particular day (`_at` + 24 hours) for a given user\n     * @param _user Address of the token holder\n     * @param _at Timestamp \n     */\n    function getTotalTradedByUser(address _user, uint256 _at) external  returns(uint256) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',39);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1155);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',211);\nreturn bucket[_user][_at];\n    }\n\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() public  returns(bytes4) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',40);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1162);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',212);\nreturn bytes4(0);\n    }\n\n    /**\n     * @notice Returns the permissions flag that are associated with Percentage transfer Manager\n     */\n    function getPermissions() public  returns(bytes32[]) {emit __FunctionCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',41);\n\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1169);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',213);\nbytes32[] memory allPermissions = new bytes32[](1);\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1170);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',214);\nallPermissions[0] = ADMIN;\nemit __CoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',1171);\n        emit __StatementCoverageVolumeRestrictionTM('./contracts/modules/TransferManager/VolumeRestrictionTM.sol',215);\nreturn allPermissions;\n    }\n\n}"},"/home/max/Desktop/Ethereum/polymath-core/contracts/libraries/BokkyPooBahsDateTimeLibrary.sol":{"content":"pragma solidity ^0.4.24;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.00\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018.\n//\n// GNU Lesser General Public License 3.0\n// https://www.gnu.org/licenses/lgpl-3.0.en.html\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n\n        int __days = _day\n          - 32075\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n          - OFFSET19700101;\n\n        _days = uint(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        uint year;\n        uint month;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        uint year;\n        uint month;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        uint month;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        uint year;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        uint year;\n        uint month;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        uint year;\n        uint month;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        uint year;\n        uint month;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        uint year;\n        uint month;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        uint year;\n        uint month;\n        uint day;\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        uint fromYear;\n        uint fromMonth;\n        uint fromDay;\n        uint toYear;\n        uint toMonth;\n        uint toDay;\n        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        uint fromYear;\n        uint fromMonth;\n        uint fromDay;\n        uint toYear;\n        uint toMonth;\n        uint toDay;\n        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Experimental/Mixed/ScheduledCheckpoint.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./../../Checkpoint/ICheckpoint.sol\";\nimport \"../../TransferManager/ITransferManager.sol\";\nimport \"../../../interfaces/ISecurityToken.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title Burn module for burning tokens and keeping track of burnt amounts\n */\ncontract ScheduledCheckpoint is ICheckpoint, ITransferManager {\n    using SafeMath for uint256;\n\n    struct Schedule {\n        bytes32 name;\n        uint256 startTime;\n        uint256 nextTime;\n        uint256 interval;\n        uint256 index;\n        uint256[] checkpointIds;\n        uint256[] timestamps;\n        uint256[] periods;\n    }\n\n    bytes32[] public names;\n\n    mapping (bytes32 => Schedule) public schedules;\n\n    event AddSchedule(bytes32 _name, uint256 _startTime, uint256 _interval, uint256 _timestamp);\n    event RemoveSchedule(bytes32 _name, uint256 _timestamp);\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress) public\n    Module(_securityToken, _polyAddress)\n    {\n    }\n\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() public  returns (bytes4) {\n        return bytes4(0);\n    }\n\n    /**\n     * @notice adds a new schedule for checkpoints\n     * @param _name name of the new schedule (must be unused)\n     * @param _startTime start time of the schedule (first checkpoint)\n     * @param _interval interval at which checkpoints should be created\n     */\n    function addSchedule(bytes32 _name, uint256 _startTime, uint256 _interval) external onlyOwner {\n        require(_startTime > now, \"Start time must be in the future\");\n        require(schedules[_name].name == bytes32(0), \"Name already in use\");\n        schedules[_name].name = _name;\n        schedules[_name].startTime = _startTime;\n        schedules[_name].nextTime = _startTime;\n        schedules[_name].interval = _interval;\n        schedules[_name].index = names.length;\n        names.push(_name);\n        emit AddSchedule(_name, _startTime, _interval, now);\n    }\n\n    /**\n     * @notice removes a schedule for checkpoints\n     * @param _name name of the schedule to be removed\n     */\n    function removeSchedule(bytes32 _name) external onlyOwner {\n        require(schedules[_name].name == _name, \"Name does not exist\");\n        uint256 index = schedules[_name].index;\n        names[index] = names[names.length - 1];\n        names.length--;\n        if (index != names.length) {\n            schedules[names[index]].index = index;\n        }\n        delete schedules[_name];\n        emit RemoveSchedule(_name, now);\n    }\n\n\n    /**\n     * @notice Used to create checkpoints that correctly reflect balances\n     * @param _isTransfer whether or not an actual transfer is occuring\n     * @return always returns Result.NA\n     */\n    function verifyTransfer(address /* _from */, address /* _to */, uint256 /* _amount */, bytes /* _data */, bool _isTransfer) public returns(Result) {\n        require(_isTransfer == false || msg.sender == securityToken, \"Sender is not owner\");\n        if (paused || !_isTransfer) {\n            return Result.NA;\n        }\n        _updateAll();\n        return Result.NA;\n    }\n\n    /**\n     * @notice gets schedule details\n     * @param _name name of the schedule\n     */\n    function getSchedule(bytes32 _name)  external returns(bytes32, uint256, uint256, uint256, uint256[], uint256[], uint256[]) {\n        return (\n            schedules[_name].name,\n            schedules[_name].startTime,\n            schedules[_name].nextTime,\n            schedules[_name].interval,\n            schedules[_name].checkpointIds,\n            schedules[_name].timestamps,\n            schedules[_name].periods\n        );\n    }\n\n    /**\n     * @notice manually triggers update outside of transfer request for named schedule (can be used to reduce user gas costs)\n     * @param _name name of the schedule\n     */\n    function update(bytes32 _name) external onlyOwner {\n        _update(_name);\n    }\n\n    function _update(bytes32 _name) internal {\n        Schedule storage schedule = schedules[_name];\n        if (schedule.nextTime <= now) {\n            uint256 checkpointId = ISecurityToken(securityToken).createCheckpoint();\n            uint256 periods = now.sub(schedule.nextTime).div(schedule.interval).add(1);\n            schedule.timestamps.push(schedule.nextTime);\n            schedule.nextTime = periods.mul(schedule.interval).add(schedule.nextTime);\n            schedule.checkpointIds.push(checkpointId);\n            schedule.periods.push(periods);\n        }\n    }\n\n    /**\n     * @notice manually triggers update outside of transfer request for all schedules (can be used to reduce user gas costs)\n     */\n    function updateAll() onlyOwner external {\n        _updateAll();\n    }\n\n    function _updateAll() internal {\n        uint256 i;\n        for (i = 0; i < names.length; i++) {\n            _update(names[i]);\n        }\n    }\n\n    /**\n     * @notice Return the permissions flag that are associated with CountTransferManager\n     */\n    function getPermissions()  external returns(bytes32[]) {\n        bytes32[] memory allPermissions = new bytes32[](0);\n        return allPermissions;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Experimental/Mixed/ScheduledCheckpointFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ScheduledCheckpoint.sol\";\nimport \"../../ModuleFactory.sol\";\n\n/**\n * @title Factory for deploying EtherDividendCheckpoint module\n */\ncontract ScheduledCheckpointFactory is ModuleFactory {\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     * @param _setupCost Setup cost of the module\n     * @param _usageCost Usage cost of the module\n     * @param _subscriptionCost Subscription cost of the module\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {\n        version = \"1.0.0\";\n        name = \"ScheduledCheckpoint\";\n        title = \"Schedule Checkpoints\";\n        description = \"Allows you to schedule checkpoints in the future\";\n        compatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n        compatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n    }\n\n    /**\n     * @notice used to launch the Module with the help of factory\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes /* _data */) external returns(address) {\n        if(setupCost > 0)\n            {require(polyToken.transferFrom(msg.sender, owner, setupCost), \"Failed transferFrom because of sufficent Allowance is not provided\");}\n        address scheduledCheckpoint = new ScheduledCheckpoint(msg.sender, address(polyToken));\n        emit GenerateModuleFromFactory(scheduledCheckpoint, getName(), address(this), msg.sender, setupCost, now);\n        return scheduledCheckpoint;\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {\n        uint8[] memory res = new uint8[](2);\n        res[0] = 4;\n        res[1] = 2;\n        return res;\n    }\n\n    /**\n     * @notice Get the name of the Module\n     */\n    function getName() public  returns(bytes32) {\n        return name;\n    }\n\n    /**\n     * @notice Get the description of the Module\n     */\n    function getDescription() external  returns(string) {\n        return description;\n    }\n\n    /**\n     * @notice Get the title of the Module\n     */\n    function getTitle() external   returns(string) {\n        return title;\n    }\n\n    /**\n     * @notice Get the version of the Module\n     */\n    function getVersion() external  returns(string) {\n        return version;\n    }\n\n    /**\n     * @notice Get the setup cost of the module\n     */\n    function getSetupCost() external  returns (uint256) {\n        return setupCost;\n    }\n\n    /**\n     * @notice Get the Instructions that helped to used the module\n     */\n    function getInstructions() external  returns(string) {\n        return \"Schedule a series of future checkpoints by specifying a start time and interval of each checkpoint\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {\n        bytes32[] memory availableTags = new bytes32[](2);\n        availableTags[0] = \"Scheduled\";\n        availableTags[1] = \"Checkpoint\";\n        return availableTags;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Checkpoint/ICheckpoint.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Interface to be implemented by all checkpoint modules\r\n */\r\n/*solium-disable-next-line no-empty-blocks*/\r\ninterface ICheckpoint {event __CoverageICheckpoint(string fileName, uint256 lineNumber);\nevent __FunctionCoverageICheckpoint(string fileName, uint256 fnId);\nevent __StatementCoverageICheckpoint(string fileName, uint256 statementId);\nevent __BranchCoverageICheckpoint(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageICheckpoint(string fileName, uint256 branchId);\nevent __AssertPostCoverageICheckpoint(string fileName, uint256 branchId);\n\r\n\r\n}\r\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Experimental/TransferManager/LockupVolumeRestrictionTM.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./../../TransferManager/ITransferManager.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n\ncontract LockupVolumeRestrictionTM is ITransferManager {\n\n    using SafeMath for uint256;\n\n    // permission definition\n    bytes32 public constant ADMIN = \"ADMIN\";\n\n    // a per-user lockup\n    struct LockUp {\n        uint lockUpPeriodSeconds; // total period of lockup (seconds)\n        uint releaseFrequencySeconds; // how often to release a tranche of tokens (seconds)\n        uint startTime; // when this lockup starts (seconds)\n        uint totalAmount; // total amount of locked up tokens\n        uint alreadyWithdrawn; // amount already withdrawn for this lockup\n    }\n\n    // maps user addresses to an array of lockups for that user\n    mapping (address => LockUp[]) internal lockUps;\n\n    event AddNewLockUp(\n        address indexed userAddress,\n        uint lockUpPeriodSeconds,\n        uint releaseFrequencySeconds,\n        uint startTime,\n        uint totalAmount,\n        uint indexed addedIndex\n    );\n\n    event RemoveLockUp(\n        address indexed userAddress,\n        uint lockUpPeriodSeconds,\n        uint releaseFrequencySeconds,\n        uint startTime,\n        uint totalAmount,\n        uint indexed removedIndex\n    );\n\n    event ModifyLockUp(\n        address indexed userAddress,\n        uint lockUpPeriodSeconds,\n        uint releaseFrequencySeconds,\n        uint startTime,\n        uint totalAmount,\n        uint indexed modifiedIndex\n    );\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress)\n    public\n    Module(_securityToken, _polyAddress)\n    {\n    }\n\n\n    /** @notice Used to verify the transfer transaction and prevent locked up tokens from being transferred\n     * @param _from Address of the sender\n     * @param _amount The amount of tokens to transfer\n     * @param _isTransfer Whether or not this is an actual transfer or just a test to see if the tokens would be transferrable\n     */\n    function verifyTransfer(address  _from, address /* _to*/, uint256  _amount, bytes /* _data */, bool  _isTransfer) public returns(Result) {\n        // only attempt to verify the transfer if the token is unpaused, this isn't a mint txn, and there exists a lockup for this user\n        if (!paused && _from != address(0) && lockUps[_from].length != 0) {\n            // check if this transfer is valid\n            return _checkIfValidTransfer(_from, _amount, _isTransfer);\n        }\n        return Result.NA;\n    }\n\n    /**\n     * @notice Lets the admin create a volume restriction lockup for a given address.\n     * @param _userAddress Address of the user whose tokens should be locked up\n     * @param _lockUpPeriodSeconds Total period of lockup (seconds)\n     * @param _releaseFrequencySeconds How often to release a tranche of tokens (seconds)\n     * @param _startTime When this lockup starts (seconds)\n     * @param _totalAmount Total amount of locked up tokens\n     */\n    function addLockUp(\n        address _userAddress,\n        uint _lockUpPeriodSeconds,\n        uint _releaseFrequencySeconds,\n        uint _startTime,\n        uint _totalAmount\n        ) public withPerm(ADMIN) {\n        uint256 startTime = _startTime;\n        _checkLockUpParams(_lockUpPeriodSeconds, _releaseFrequencySeconds, _totalAmount);\n\n        // if a startTime of 0 is passed in, then start now.\n        if (startTime == 0) {\n            /*solium-disable-next-line security/no-block-members*/\n            startTime = now;\n        }\n\n        lockUps[_userAddress].push(LockUp(_lockUpPeriodSeconds, _releaseFrequencySeconds, startTime, _totalAmount, 0));\n\n        emit AddNewLockUp(\n            _userAddress,\n            _lockUpPeriodSeconds,\n            _releaseFrequencySeconds,\n            startTime,\n            _totalAmount,\n            lockUps[_userAddress].length - 1\n        );\n    }\n\n    /**\n     * @notice Lets the admin create multiple volume restriction lockups for multiple given addresses.\n     * @param _userAddresses Array of address of the user whose tokens should be locked up\n     * @param _lockUpPeriodsSeconds Array of total periods of lockup (seconds)\n     * @param _releaseFrequenciesSeconds Array of how often to release a tranche of tokens (seconds)\n     * @param _startTimes Array of When this lockup starts (seconds)\n     * @param _totalAmounts Array of total amount of locked up tokens\n     */\n    function addLockUpMulti(\n        address[] _userAddresses,\n        uint[] _lockUpPeriodsSeconds,\n        uint[] _releaseFrequenciesSeconds,\n        uint[] _startTimes,\n        uint[] _totalAmounts\n        ) external withPerm(ADMIN) {\n        require(\n            _userAddresses.length == _lockUpPeriodsSeconds.length && /*solium-disable-line operator-whitespace*/\n            _userAddresses.length == _releaseFrequenciesSeconds.length && /*solium-disable-line operator-whitespace*/\n            _userAddresses.length == _startTimes.length && \n            _userAddresses.length == _totalAmounts.length,\n            \"Input array length mismatch\"\n        );\n\n        for (uint i = 0; i < _userAddresses.length; i++) {\n            addLockUp(_userAddresses[i], _lockUpPeriodsSeconds[i], _releaseFrequenciesSeconds[i], _startTimes[i], _totalAmounts[i]);\n        }\n\n    }\n\n    /**\n     * @notice Lets the admin remove a user's lock up\n     * @param _userAddress Address of the user whose tokens are locked up\n     * @param _lockUpIndex The index of the LockUp to remove for the given userAddress\n     */\n    function removeLockUp(address _userAddress, uint _lockUpIndex) public withPerm(ADMIN) {\n        LockUp[] storage userLockUps = lockUps[_userAddress];\n        require(_lockUpIndex < userLockUps.length, \"Array out of bounds exception\");\n\n        LockUp memory toRemove = userLockUps[_lockUpIndex];\n\n        emit RemoveLockUp(\n            _userAddress,\n            toRemove.lockUpPeriodSeconds,\n            toRemove.releaseFrequencySeconds,\n            toRemove.startTime,\n            toRemove.totalAmount,\n            _lockUpIndex\n        );\n\n        if (_lockUpIndex < userLockUps.length - 1) {\n            // move the last element in the array into the index that is desired to be removed.\n            userLockUps[_lockUpIndex] = userLockUps[userLockUps.length - 1];\n        }\n        // delete the last element\n        userLockUps.length--;\n    }\n\n    /**\n     * @notice Lets the admin modify a volume restriction lockup for a given address.\n     * @param _userAddress Address of the user whose tokens should be locked up\n     * @param _lockUpIndex The index of the LockUp to edit for the given userAddress\n     * @param _lockUpPeriodSeconds Total period of lockup (seconds)\n     * @param _releaseFrequencySeconds How often to release a tranche of tokens (seconds)\n     * @param _startTime When this lockup starts (seconds)\n     * @param _totalAmount Total amount of locked up tokens\n     */\n    function modifyLockUp(\n        address _userAddress,\n        uint _lockUpIndex,\n        uint _lockUpPeriodSeconds,\n        uint _releaseFrequencySeconds,\n        uint _startTime,\n        uint _totalAmount\n        ) public withPerm(ADMIN) {\n        require(_lockUpIndex < lockUps[_userAddress].length, \"Array out of bounds exception\");\n\n        uint256 startTime = _startTime;\n        // if a startTime of 0 is passed in, then start now.\n        if (startTime == 0) {\n            /*solium-disable-next-line security/no-block-members*/\n            startTime = now;\n        }\n\n        _checkLockUpParams(_lockUpPeriodSeconds, _releaseFrequencySeconds, _totalAmount);\n\n        // Get the lockup from the master list and edit it\n        lockUps[_userAddress][_lockUpIndex] = LockUp(\n            _lockUpPeriodSeconds,\n            _releaseFrequencySeconds,\n            startTime,\n            _totalAmount,\n            lockUps[_userAddress][_lockUpIndex].alreadyWithdrawn\n        );\n\n        emit ModifyLockUp(\n            _userAddress,\n            _lockUpPeriodSeconds,\n            _releaseFrequencySeconds,\n            startTime,\n            _totalAmount,\n            _lockUpIndex\n        );\n    }\n\n    /**\n     * @notice Get the length of the lockups array for a specific user address\n     * @param _userAddress Address of the user whose tokens should be locked up\n     */\n    function getLockUpsLength(address _userAddress) public  returns (uint) {\n        return lockUps[_userAddress].length;\n    }\n\n    /**\n     * @notice Get a specific element in a user's lockups array given the user's address and the element index\n     * @param _userAddress Address of the user whose tokens should be locked up\n     * @param _lockUpIndex The index of the LockUp to edit for the given userAddress\n     */\n    function getLockUp(\n        address _userAddress,\n        uint _lockUpIndex)\n        public  returns (\n        uint lockUpPeriodSeconds,\n        uint releaseFrequencySeconds,\n        uint startTime,\n        uint totalAmount,\n        uint alreadyWithdrawn\n        ) {\n        require(_lockUpIndex < lockUps[_userAddress].length, \"Array out of bounds exception\");\n        LockUp storage userLockUp = lockUps[_userAddress][_lockUpIndex];\n        return (\n            userLockUp.lockUpPeriodSeconds,\n            userLockUp.releaseFrequencySeconds,\n            userLockUp.startTime,\n            userLockUp.totalAmount,\n            userLockUp.alreadyWithdrawn\n        );\n    }\n\n    /**\n     * @notice Takes a userAddress as input, and returns a uint that represents the number of tokens allowed to be withdrawn right now\n     * @param userAddress Address of the user whose lock ups should be checked\n     */\n    function _checkIfValidTransfer(address userAddress, uint amount, bool isTransfer) internal returns (Result) {\n        // get lock up array for this user\n        LockUp[] storage userLockUps = lockUps[userAddress];\n\n        // maps the index of userLockUps to the amount allowed in this transfer\n        uint[] memory allowedAmountPerLockup = new uint[](userLockUps.length);\n\n        uint[3] memory tokenSums = [\n            uint256(0), // allowed amount right now\n            uint256(0), // total locked up, ever\n            uint256(0) // already withdrawn, ever\n        ];\n\n        // loop over the user's lock ups\n        for (uint i = 0; i < userLockUps.length; i++) {\n            LockUp storage aLockUp = userLockUps[i];\n\n            uint allowedAmountForThisLockup = 0;\n\n            // check if lockup has entirely passed\n            /*solium-disable-next-line security/no-block-members*/\n            if (now >= aLockUp.startTime.add(aLockUp.lockUpPeriodSeconds)) {\n                // lockup has passed, or not started yet.  allow all.\n                allowedAmountForThisLockup = aLockUp.totalAmount.sub(aLockUp.alreadyWithdrawn);\n                /*solium-disable-next-line security/no-block-members*/\n            } else {if (now >= aLockUp.startTime) {\n                // lockup is active. calculate how many to allow to be withdrawn right now\n                // calculate how many periods have elapsed already\n                /*solium-disable-next-line security/no-block-members*/\n                uint elapsedPeriods = (now.sub(aLockUp.startTime)).div(aLockUp.releaseFrequencySeconds);\n                // calculate the total number of periods, overall\n                uint totalPeriods = aLockUp.lockUpPeriodSeconds.div(aLockUp.releaseFrequencySeconds);\n                // calculate how much should be released per period\n                uint amountPerPeriod = aLockUp.totalAmount.div(totalPeriods);\n                // calculate the number of tokens that should be released,\n                // multiplied by the number of periods that have elapsed already\n                // and add it to the total tokenSums[0]\n                allowedAmountForThisLockup = amountPerPeriod.mul(elapsedPeriods).sub(aLockUp.alreadyWithdrawn);\n\n            }}\n            // tokenSums[0] is allowed sum\n            tokenSums[0] = tokenSums[0].add(allowedAmountForThisLockup);\n            // tokenSums[1] is total locked up\n            tokenSums[1] = tokenSums[1].add(aLockUp.totalAmount);\n            // tokenSums[2] is total already withdrawn\n            tokenSums[2] = tokenSums[2].add(aLockUp.alreadyWithdrawn);\n\n            allowedAmountPerLockup[i] = allowedAmountForThisLockup;\n        }\n\n        // tokenSums[0] is allowed sum\n        if (amount <= tokenSums[0]) {\n            // transfer is valid and will succeed.\n            if (!isTransfer) {\n                // if this isn't a real transfer, don't subtract the withdrawn amounts from the lockups.  it's a \"read only\" txn\n                return Result.VALID;\n            }\n\n            // we are going to write the withdrawn balances back to the lockups, so make sure that the person calling this function is the securityToken itself, since its public\n            require(msg.sender == securityToken, \"Sender is not securityToken\");\n\n            // subtract amounts so they are now known to be withdrawen\n            for (i = 0; i < userLockUps.length; i++) {\n                aLockUp = userLockUps[i];\n\n                // tokenSums[0] is allowed sum\n                if (allowedAmountPerLockup[i] >= tokenSums[0]) {\n                    aLockUp.alreadyWithdrawn = aLockUp.alreadyWithdrawn.add(tokenSums[0]);\n                    // we withdrew the entire tokenSums[0] from the lockup.  We are done.\n                    break;\n                } else {\n                    // we have to split the tokenSums[0] across mutiple lockUps\n                    aLockUp.alreadyWithdrawn = aLockUp.alreadyWithdrawn.add(allowedAmountPerLockup[i]);\n                    // subtract the amount withdrawn from this lockup\n                    tokenSums[0] = tokenSums[0].sub(allowedAmountPerLockup[i]);\n                }\n\n            }\n            return Result.VALID;\n        }\n\n        return _checkIfUnlockedTokenTransferIsPossible(userAddress, amount, tokenSums[1], tokenSums[2]);\n    }\n\n    function _checkIfUnlockedTokenTransferIsPossible(\n        address userAddress,\n        uint amount,\n        uint totalSum,\n        uint alreadyWithdrawnSum\n        ) internal  returns (Result) {\n        // the amount the user wants to withdraw is greater than their allowed amounts according to the lockups.  however, if the user has like, 10 tokens, but only 4 are locked up, we should let the transfer go through for those 6 that aren't locked up\n        uint currentUserBalance = ISecurityToken(securityToken).balanceOf(userAddress);\n        uint stillLockedAmount = totalSum.sub(alreadyWithdrawnSum);\n        if (currentUserBalance >= stillLockedAmount && amount <= currentUserBalance.sub(stillLockedAmount)) {\n            // the user has more tokens in their balance than are actually locked up.  they should be allowed to withdraw the difference\n            return Result.VALID;\n        }\n        return Result.INVALID;\n    }\n\n\n    /**\n     * @notice Parameter checking function for creating or editing a lockup.  This function will cause an exception if any of the parameters are bad.\n     * @param lockUpPeriodSeconds Total period of lockup (seconds)\n     * @param releaseFrequencySeconds How often to release a tranche of tokens (seconds)\n     * @param totalAmount Total amount of locked up tokens\n     */\n    function _checkLockUpParams(uint lockUpPeriodSeconds, uint releaseFrequencySeconds, uint totalAmount) internal  {\n        require(lockUpPeriodSeconds != 0, \"lockUpPeriodSeconds cannot be zero\");\n        require(releaseFrequencySeconds != 0, \"releaseFrequencySeconds cannot be zero\");\n        require(totalAmount != 0, \"totalAmount cannot be zero\");\n\n        // check that the total amount to be released isn't too granular\n        require(\n            totalAmount % ISecurityToken(securityToken).granularity() == 0,\n            \"The total amount to be released is more granular than allowed by the token\"\n        );\n\n        // check that releaseFrequencySeconds evenly divides lockUpPeriodSeconds\n        require(\n            lockUpPeriodSeconds % releaseFrequencySeconds == 0,\n            \"lockUpPeriodSeconds must be evenly divisible by releaseFrequencySeconds\"\n        );\n\n        // check that totalPeriods evenly divides totalAmount\n        uint totalPeriods = lockUpPeriodSeconds.div(releaseFrequencySeconds);\n        require(\n            totalAmount % totalPeriods == 0,\n            \"The total amount being locked up must be evenly divisible by the number of total periods\"\n        );\n\n        // make sure the amount to be released per period is not too granular for the token\n        uint amountPerPeriod = totalAmount.div(totalPeriods);\n        require(\n            amountPerPeriod % ISecurityToken(securityToken).granularity() == 0,\n            \"The amount to be released per period is more granular than allowed by the token\"\n        );\n    }\n\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() public  returns (bytes4) {\n        return bytes4(0);\n    }\n\n    /**\n     * @notice Returns the permissions flag that are associated with Percentage transfer Manager\n     */\n    function getPermissions() public  returns(bytes32[]) {\n        bytes32[] memory allPermissions = new bytes32[](1);\n        allPermissions[0] = ADMIN;\n        return allPermissions;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Experimental/TransferManager/LockupVolumeRestrictionTMFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./../../ModuleFactory.sol\";\nimport \"./LockupVolumeRestrictionTM.sol\";\n\n/**\n * @title Factory for deploying ManualApprovalTransferManager module\n */\ncontract LockupVolumeRestrictionTMFactory is ModuleFactory {\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     * @param _setupCost Setup cost of the module\n     * @param _usageCost Usage cost of the module\n     * @param _subscriptionCost Subscription cost of the module\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n      ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {\n        version = \"1.0.0\";\n        name = \"LockupVolumeRestrictionTM\";\n        title = \"Lockup Volume Restriction Transfer Manager\";\n        description = \"Manage transfers using lock ups over time\";\n        compatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n        compatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n    }\n\n     /**\n     * @notice Used to launch the Module with the help of factory\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes /* _data */) external returns(address) {\n        if (setupCost > 0)\n            {require(polyToken.transferFrom(msg.sender, owner, setupCost), \"Failed transferFrom because of sufficent Allowance is not provided\");}\n        LockupVolumeRestrictionTM lockupVolumeRestrictionTransferManager = new LockupVolumeRestrictionTM(msg.sender, address(polyToken));\n        /*solium-disable-next-line security/no-block-members*/\n        emit GenerateModuleFromFactory(address(lockupVolumeRestrictionTransferManager), getName(), address(this), msg.sender, now);\n        return address(lockupVolumeRestrictionTransferManager);\n    }\n\n    /**\n     * @notice Type of the Module factory\n     * @return uint8\n     */\n    function getTypes() external  returns(uint8[]) {\n        uint8[] memory res = new uint8[](1);\n        res[0] = 2;\n        return res;\n    }\n   \n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {\n        return \"Allows an issuer to set lockup periods for user addresses, with funds distributed over time. Init function takes no parameters.\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {\n        bytes32[] memory availableTags = new bytes32[](2);\n        availableTags[0] = \"Volume\";\n        availableTags[1] = \"Transfer Restriction\";\n        return availableTags;\n    }\n\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/SecurityTokenRegistry.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IOwnable.sol\";\nimport \"./interfaces/ISTFactory.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/ISecurityTokenRegistry.sol\";\nimport \"./storage/EternalStorage.sol\";\nimport \"./libraries/Util.sol\";\nimport \"./libraries/Encoder.sol\";\nimport \"./libraries/VersionUtils.sol\";\n\n/**\n * @title Registry contract for issuers to register their tickers and security tokens\n */\ncontract SecurityTokenRegistry is ISecurityTokenRegistry, EternalStorage {event __CoverageSecurityTokenRegistry(string fileName, uint256 lineNumber);\nevent __FunctionCoverageSecurityTokenRegistry(string fileName, uint256 fnId);\nevent __StatementCoverageSecurityTokenRegistry(string fileName, uint256 statementId);\nevent __BranchCoverageSecurityTokenRegistry(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageSecurityTokenRegistry(string fileName, uint256 branchId);\nevent __AssertPostCoverageSecurityTokenRegistry(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice state variables\n\n       address public polyToken;\n       uint256 public stLaunchFee;\n       uint256 public tickerRegFee;\n       uint256 public expiryLimit;\n       uint256 public latestProtocolVersion;\n       bool public paused;\n       address public owner;\n       address public polymathRegistry;\n\n       address[] public activeUsers;\n       mapping(address => bool) public seenUsers;\n\n       mapping(address => bytes32[]) userToTickers;\n       mapping(string => address) tickerToSecurityToken;\n       mapping(string => uint) tickerIndex;\n       mapping(string => TickerDetails) registeredTickers;\n       mapping(address => SecurityTokenData) securityTokens;\n       mapping(bytes32 => address) protocolVersionST;\n       mapping(uint256 => ProtocolVersion) versionData;\n\n       struct ProtocolVersion {\n           uint8 major;\n           uint8 minor;\n           uint8 patch;\n       }\n\n       struct TickerDetails {\n           address owner;\n           uint256 registrationDate;\n           uint256 expiryDate;\n           string tokenName;\n           bool status;\n       }\n\n       struct SecurityTokenData {\n           string ticker;\n           string tokenDetails;\n           uint256 deployedAt;\n       }\n\n     */\n\n    using SafeMath for uint256;\n\n    bytes32 constant INITIALIZE = 0x9ef7257c3339b099aacf96e55122ee78fb65a36bd2a6c19249882be9c98633bf;\n    bytes32 constant POLYTOKEN = 0xacf8fbd51bb4b83ba426cdb12f63be74db97c412515797993d2a385542e311d7;\n    bytes32 constant STLAUNCHFEE = 0xd677304bb45536bb7fdfa6b9e47a3c58fe413f9e8f01474b0a4b9c6e0275baf2;\n    bytes32 constant TICKERREGFEE = 0x2fcc69711628630fb5a42566c68bd1092bc4aa26826736293969fddcd11cb2d2;\n    bytes32 constant EXPIRYLIMIT = 0x604268e9a73dfd777dcecb8a614493dd65c638bad2f5e7d709d378bd2fb0baee;\n    bytes32 constant PAUSED = 0xee35723ac350a69d2a92d3703f17439cbaadf2f093a21ba5bf5f1a53eb2a14d9;\n    bytes32 constant OWNER = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0;\n    bytes32 constant POLYMATHREGISTRY = 0x90eeab7c36075577c7cc5ff366e389fefa8a18289b949bab3529ab4471139d4d;\n\n    // Emit when network becomes paused\n    event Pause(uint256 _timestammp);\n     // Emit when network becomes unpaused\n    event Unpause(uint256 _timestamp);\n    // Emit when the ticker is removed from the registry\n    event TickerRemoved(string _ticker, uint256 _removedAt, address _removedBy);\n    // Emit when the token ticker expiry is changed\n    event ChangeExpiryLimit(uint256 _oldExpiry, uint256 _newExpiry);\n     // Emit when changeSecurityLaunchFee is called\n    event ChangeSecurityLaunchFee(uint256 _oldFee, uint256 _newFee);\n    // Emit when changeTickerRegistrationFee is called\n    event ChangeTickerRegistrationFee(uint256 _oldFee, uint256 _newFee);\n    // Emit when ownership gets transferred\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    // Emit when ownership of the ticker gets changed\n    event ChangeTickerOwnership(string _ticker, address indexed _oldOwner, address indexed _newOwner);\n    // Emit at the time of launching a new security token\n    event NewSecurityToken(\n        string _ticker,\n        string _name,\n        address indexed _securityTokenAddress,\n        address indexed _owner,\n        uint256 _addedAt,\n        address _registrant,\n        bool _fromAdmin,\n        uint256 _registrationFee\n    );\n    // Emit after ticker registration\n    event RegisterTicker(\n        address indexed _owner,\n        string _ticker,\n        string _name,\n        uint256 indexed _registrationDate,\n        uint256 indexed _expiryDate,\n        bool _fromAdmin,\n        uint256 _registrationFee\n    );\n\n    /////////////////////////////\n    // Modifiers\n    /////////////////////////////\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',1);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',120);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',1);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',1);\nrequire(msg.sender == owner(),\"sender must be owner\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',1);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',121);\n        _;\n    }\n\n    /**\n     * @notice Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPausedOrOwner() {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',2);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',128);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',2);\nif (msg.sender == owner())\n            {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',2,0);emit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',129);\n_;}\n        else {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',2,1);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',131);\n            emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',3);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',3);\nrequire(!isPaused(), \"Already paused\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',3);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',132);\n            _;\n        }\n    }\n\n    /**\n     * @notice Modifier to make a function callable only when the contract is not paused and ignore is msg.sender is owner.\n     */\n    modifier whenNotPaused() {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',3);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',140);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',4);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',4);\nrequire(!isPaused(), \"Already paused\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',4);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',141);\n        _;\n    }\n\n\n    /**\n     * @notice Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',4);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',149);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',5);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',5);\nrequire(isPaused(), \"Should not be paused\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',5);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',150);\n        _;\n    }\n\n\n    /////////////////////////////\n    // Initialization\n    /////////////////////////////\n\n    /**\n     * @notice Initializes instance of STR\n     * @param _polymathRegistry is the address of the Polymath Registry\n     * @param _STFactory is the address of the Proxy contract for Security Tokens\n     * @param _stLaunchFee is the fee in POLY required to launch a token\n     * @param _tickerRegFee is the fee in POLY required to register a ticker\n     * @param _polyToken is the address of the POLY ERC20 token\n     * @param _owner is the owner of the STR\n     */\n    function initialize(\n        address _polymathRegistry,\n        address _STFactory,\n        uint256 _stLaunchFee,\n        uint256 _tickerRegFee,\n        address _polyToken,\n        address _owner\n    )\n        external\n        payable\n    {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',5);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',178);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',6);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',6);\nrequire(!getBoolValue(INITIALIZE),\"already initialized\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',6);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',179);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',7);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',7);\nrequire(\n            _STFactory != address(0) && _polyToken != address(0) && _owner != address(0) && _polymathRegistry != address(0),\n            \"Invalid address\"\n        );emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',7);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',183);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',8);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',8);\nrequire(_stLaunchFee != 0 && _tickerRegFee != 0, \"Fees should not be 0\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',8);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',184);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',9);\nset(POLYTOKEN, _polyToken);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',185);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',10);\nset(STLAUNCHFEE, _stLaunchFee);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',186);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',11);\nset(TICKERREGFEE, _tickerRegFee);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',187);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',12);\nset(EXPIRYLIMIT, uint256(60 * 1 days));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',188);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',13);\nset(PAUSED, false);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',189);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',14);\nset(OWNER, _owner);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',190);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',15);\nset(POLYMATHREGISTRY, _polymathRegistry);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',191);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',16);\n_setProtocolVersion(_STFactory, uint8(2), uint8(0), uint8(0));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',192);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',17);\nset(INITIALIZE, true);\n    }\n\n    /////////////////////////////\n    // Token Ticker Management\n    /////////////////////////////\n\n    /**\n     * @notice Registers the token ticker to the selected owner\n     * @notice Once the token ticker is registered to its owner then no other issuer can claim\n     * @notice its ownership. If the ticker expires and its issuer hasn't used it, then someone else can take it.\n     * @param _owner is address of the owner of the token\n     * @param _ticker is unique token ticker\n     * @param _tokenName is the name of the token\n     */\n    function registerTicker(address _owner, string _ticker, string _tokenName) external whenNotPausedOrOwner {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',6);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',208);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',9);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',18);\nrequire(_owner != address(0), \"Owner should not be 0x\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',9);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',209);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',10);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',19);\nrequire(bytes(_ticker).length > 0 && bytes(_ticker).length <= 10, \"Ticker length range (0,10]\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',10);\n\n        // Attempt to charge the reg fee if it is > 0 POLY\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',211);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',20);\nuint256 tickerFee = getTickerRegistrationFee();\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',212);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',21);\nif (tickerFee > 0)\n            {emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',12);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',22);\nemit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',11,0);emit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',213);\nrequire(IERC20(getAddressValue(POLYTOKEN)).transferFrom(msg.sender, address(this), tickerFee), \"Insufficent allowance\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',12);\n}else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',11,1);}\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',214);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',23);\nstring memory ticker = Util.upper(_ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',215);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',13);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',24);\nrequire(_tickerAvailable(ticker), \"Ticker is reserved\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',13);\n\n        // Check whether ticker was previously registered (and expired)\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',217);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',25);\naddress previousOwner = _tickerOwner(ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',218);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',26);\nif (previousOwner != address(0)) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',14,0);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',219);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',27);\n_deleteTickerOwnership(previousOwner, ticker);\n        }else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',14,1);}\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',222);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',28);\n_addTicker(_owner, ticker, _tokenName, now, now.add(getExpiryLimit()), false, false, tickerFee);\n    }\n\n    /**\n     * @notice Internal - Sets the details of the ticker\n     */\n    function _addTicker(\n        address _owner, \n        string _ticker, \n        string _tokenName, \n        uint256 _registrationDate, \n        uint256 _expiryDate, \n        bool _status, \n        bool _fromAdmin, \n        uint256 _fee\n        ) internal {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',7);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',238);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',29);\n_setTickerOwnership(_owner, _ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',239);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',30);\n_storeTickerDetails(_ticker, _owner, _registrationDate, _expiryDate, _tokenName, _status);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',240);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',31);\nemit RegisterTicker(_owner, _ticker, _tokenName, _registrationDate, _expiryDate, _fromAdmin, _fee);\n    }\n\n    /**\n     * @notice Modifies the ticker details. Only Polymath has the ability to do so.\n     * @notice Only allowed to modify the tickers which are not yet deployed.\n     * @param _owner is the owner of the token\n     * @param _ticker is the token ticker\n     * @param _tokenName is the name of the token\n     * @param _registrationDate is the date at which ticker is registered\n     * @param _expiryDate is the expiry date for the ticker\n     * @param _status is the token deployment status\n     */\n    function modifyTicker(\n        address _owner,\n        string _ticker,\n        string _tokenName,\n        uint256 _registrationDate,\n        uint256 _expiryDate,\n        bool _status\n        ) external onlyOwner {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',8);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',261);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',15);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',32);\nrequire(bytes(_ticker).length > 0 && bytes(_ticker).length <= 10, \"Ticker length range (0,10]\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',15);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',262);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',16);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',33);\nrequire(_expiryDate != 0 && _registrationDate != 0, \"Dates should not be 0\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',16);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',263);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',17);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',34);\nrequire(_registrationDate <= _expiryDate, \"Registration date should < expiry date\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',17);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',264);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',18);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',35);\nrequire(_owner != address(0), \"Invalid address\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',18);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',265);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',36);\nstring memory ticker = Util.upper(_ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',266);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',37);\n_modifyTicker(_owner, ticker, _tokenName, _registrationDate, _expiryDate, _status);\n    }\n\n    /**\n     * @notice Internal -- Modifies the ticker details.\n     */\n    function _modifyTicker(\n        address _owner,\n        string _ticker,\n        string _tokenName,\n        uint256 _registrationDate,\n        uint256 _expiryDate,\n        bool _status\n        ) internal {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',9);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',280);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',38);\naddress currentOwner = _tickerOwner(_ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',281);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',39);\nif (currentOwner != address(0)) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',19,0);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',282);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',40);\n_deleteTickerOwnership(currentOwner, _ticker);\n        }else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',19,1);}\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',284);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',41);\nif (_tickerStatus(_ticker) && !_status) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',20,0);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',285);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',42);\nset(Encoder.getKey(\"tickerToSecurityToken\", _ticker), address(0));\n        }else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',20,1);}\n\n        // If status is true, there must be a security token linked to the ticker already\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',288);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',43);\nif (_status) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',21,0);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',289);\n            emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',22);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',44);\nrequire(getAddressValue(Encoder.getKey(\"tickerToSecurityToken\", _ticker)) != address(0), \"Token not registered\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',22);\n\n        }else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',21,1);}\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',291);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',45);\n_addTicker(_owner, _ticker, _tokenName, _registrationDate, _expiryDate, _status, true, uint256(0));\n    }\n\n    function _tickerOwner(string _ticker) internal  returns(address) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',10);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',295);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',46);\nreturn getAddressValue(Encoder.getKey(\"registeredTickers_owner\", _ticker));\n    }\n\n    /**\n     * @notice Removes the ticker details, associated ownership & security token mapping\n     * @param _ticker is the token ticker\n     */\n    function removeTicker(string _ticker) external onlyOwner {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',11);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',303);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',47);\nstring memory ticker = Util.upper(_ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',304);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',48);\naddress owner = _tickerOwner(ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',305);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',23);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',49);\nrequire(owner != address(0), \"Ticker doesn't exist\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',23);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',306);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',50);\n_deleteTickerOwnership(owner, ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',307);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',51);\nset(Encoder.getKey(\"tickerToSecurityToken\", ticker), address(0));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',308);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',52);\n_storeTickerDetails(ticker, address(0), 0, 0, \"\", false);\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',310);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',53);\nemit TickerRemoved(ticker, now, msg.sender);\n    }\n\n    /**\n     * @notice Internal - Checks if the entered ticker is registered and has not expired\n     * @param _ticker is the token ticker\n     * @return bool\n     */\n    function _tickerAvailable(string _ticker) internal  returns(bool) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',12);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',319);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',54);\nif (_tickerOwner(_ticker) != address(0)) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',24,0);\n            /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',321);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',55);\nif ((now > getUintValue(Encoder.getKey(\"registeredTickers_expiryDate\", _ticker))) && !_tickerStatus(_ticker)) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',25,0);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',322);\n                emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',56);\nreturn true;\n            } else\n                {emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',57);\nemit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',25,1);emit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',324);\nreturn false;}\n        }else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',24,1);}\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',326);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',58);\nreturn true;\n    }\n\n    function _tickerStatus(string _ticker) internal  returns(bool) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',13);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',330);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',59);\nreturn getBoolValue(Encoder.getKey(\"registeredTickers_status\", _ticker));\n    }\n\n    /**\n     * @notice Internal - Sets the ticker owner\n     * @param _owner is the address of the owner of the ticker\n     * @param _ticker is the ticker symbol\n     */\n    function _setTickerOwnership(address _owner, string _ticker) internal {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',14);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',339);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',60);\nbytes32 _ownerKey = Encoder.getKey(\"userToTickers\", _owner);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',340);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',61);\nuint256 length = uint256(getArrayBytes32(_ownerKey).length);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',341);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',62);\npushArray(_ownerKey, Util.stringToBytes32(_ticker));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',342);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',63);\nset(Encoder.getKey(\"tickerIndex\", _ticker), length);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',343);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',64);\nbytes32 seenKey = Encoder.getKey(\"seenUsers\", _owner);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',344);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',65);\nif (!getBoolValue(seenKey)) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',26,0);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',345);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',66);\npushArray(Encoder.getKey(\"activeUsers\"), _owner);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',346);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',67);\nset(seenKey, true);\n        }else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',26,1);}\n\n    }\n\n    /**\n     * @notice Internal - Stores the ticker details\n     */\n    function _storeTickerDetails(\n        string _ticker,\n        address _owner,\n        uint256 _registrationDate,\n        uint256 _expiryDate,\n        string _tokenName,\n        bool _status\n        ) internal {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',15);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',361);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',68);\nbytes32 key = Encoder.getKey(\"registeredTickers_owner\", _ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',362);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',69);\nif (getAddressValue(key) != _owner)\n            {emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',70);\nemit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',27,0);emit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',363);\nset(key, _owner);}else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',27,1);}\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',364);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',71);\nkey = Encoder.getKey(\"registeredTickers_registrationDate\", _ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',365);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',72);\nif (getUintValue(key) != _registrationDate)\n            {emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',73);\nemit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',28,0);emit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',366);\nset(key, _registrationDate);}else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',28,1);}\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',367);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',74);\nkey = Encoder.getKey(\"registeredTickers_expiryDate\", _ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',368);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',75);\nif (getUintValue(key) != _expiryDate)\n            {emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',76);\nemit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',29,0);emit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',369);\nset(key, _expiryDate);}else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',29,1);}\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',370);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',77);\nkey = Encoder.getKey(\"registeredTickers_tokenName\", _ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',371);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',78);\nif (Encoder.getKey(getStringValue(key)) != Encoder.getKey(_tokenName))\n            {emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',79);\nemit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',30,0);emit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',372);\nset(key, _tokenName);}else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',30,1);}\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',373);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',80);\nkey = Encoder.getKey(\"registeredTickers_status\", _ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',374);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',81);\nif (getBoolValue(key) != _status)\n            {emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',82);\nemit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',31,0);emit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',375);\nset(key, _status);}else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',31,1);}\n\n    }\n\n    /**\n     * @notice Transfers the ownership of the ticker\n     * @param _newOwner is the address of the new owner of the ticker\n     * @param _ticker is the ticker symbol\n     */\n    function transferTickerOwnership(address _newOwner, string _ticker) external whenNotPausedOrOwner {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',16);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',384);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',83);\nstring memory ticker = Util.upper(_ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',385);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',32);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',84);\nrequire(_newOwner != address(0), \"Invalid address\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',32);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',386);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',85);\nbytes32 ownerKey = Encoder.getKey(\"registeredTickers_owner\", ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',387);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',33);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',86);\nrequire(getAddressValue(ownerKey) == msg.sender, \"Not authorised\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',33);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',388);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',87);\nif (_tickerStatus(ticker))\n            {emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',35);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',88);\nemit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',34,0);emit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',389);\nrequire(IOwnable(getAddressValue(Encoder.getKey(\"tickerToSecurityToken\", ticker))).owner() == _newOwner, \"New owner does not match token owner\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',35);\n}else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',34,1);}\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',390);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',89);\n_deleteTickerOwnership(msg.sender, ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',391);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',90);\n_setTickerOwnership(_newOwner, ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',392);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',91);\nset(ownerKey, _newOwner);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',393);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',92);\nemit ChangeTickerOwnership(ticker, msg.sender, _newOwner);\n    }\n\n    /**\n     * @notice Internal - Removes the owner of a ticker\n     */\n    function _deleteTickerOwnership(address _owner, string _ticker) internal {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',17);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',400);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',93);\nuint256 index = uint256(getUintValue(Encoder.getKey(\"tickerIndex\", _ticker)));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',401);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',94);\nbytes32 ownerKey = Encoder.getKey(\"userToTickers\", _owner);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',402);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',95);\nbytes32[] memory tickers = getArrayBytes32(ownerKey);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',403);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',36);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',96);\nassert(index < tickers.length);emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',36);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',404);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',37);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',97);\nassert(_tickerOwner(_ticker) == _owner);emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',37);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',405);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',98);\ndeleteArrayBytes32(ownerKey, index);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',406);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',99);\nif (getArrayBytes32(ownerKey).length > index) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',38,0);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',407);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',100);\nbytes32 switchedTicker = getArrayBytes32(ownerKey)[index];\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',408);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',101);\nset(Encoder.getKey(\"tickerIndex\", Util.bytes32ToString(switchedTicker)), index);\n        }else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',38,1);}\n\n    }\n\n    /**\n     * @notice Changes the expiry time for the token ticker. Only available to Polymath.\n     * @param _newExpiry is the new expiry for newly generated tickers\n     */\n    function changeExpiryLimit(uint256 _newExpiry) external onlyOwner {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',18);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',417);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',39);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',102);\nrequire(_newExpiry >= 1 days, \"Expiry should >= 1 day\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',39);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',418);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',103);\nemit ChangeExpiryLimit(getUintValue(EXPIRYLIMIT), _newExpiry);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',419);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',104);\nset(EXPIRYLIMIT, _newExpiry);\n    }\n\n    /**\n     * @notice Returns the list of tickers owned by the selected address\n     * @param _owner is the address which owns the list of tickers\n     */\n    function getTickersByOwner(address _owner) external  returns(bytes32[]) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',19);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',427);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',105);\nuint counter = 0;\n        // accessing the data structure userTotickers[_owner].length\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',429);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',106);\nbytes32[] memory tickers = getArrayBytes32(Encoder.getKey(\"userToTickers\", _owner));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',430);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',107);\nfor (uint i = 0; i < tickers.length; i++) {\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',431);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',108);\nstring memory ticker = Util.bytes32ToString(tickers[i]);\n            /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',433);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',109);\nif (getUintValue(Encoder.getKey(\"registeredTickers_expiryDate\", ticker)) >= now || _tickerStatus(ticker)) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',40,0);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',434);\n                counter ++;\n            }else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',40,1);}\n\n        }\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',437);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',110);\nbytes32[] memory tempList = new bytes32[](counter);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',438);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',111);\ncounter = 0;\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',439);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',112);\nfor (i = 0; i < tickers.length; i++) {\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',440);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',113);\nticker = Util.bytes32ToString(tickers[i]);\n            /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',442);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',114);\nif (getUintValue(Encoder.getKey(\"registeredTickers_expiryDate\", ticker)) >= now || _tickerStatus(ticker)) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',41,0);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',443);\n                emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',115);\ntempList[counter] = tickers[i];\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',444);\n                counter ++;\n            }else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',41,1);}\n\n        }\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',447);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',116);\nreturn tempList;\n    }\n\n    /**\n     * @notice Returns the list of tokens owned by the selected address\n     * @param _owner is the address which owns the list of tickers\n     * @dev Intention is that this is called off-chain so block gas limit is not relevant\n     */\n    function getTokensByOwner(address _owner) external  returns(address[]) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',20);\n\n        // Loop over all active users, then all associated tickers of those users\n        // This ensures we find tokens, even if their owner has been modified\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',458);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',117);\naddress[] memory activeUsers = getArrayAddress(Encoder.getKey(\"activeUsers\"));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',459);\n        bytes32[] memory tickers;\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',460);\n        address token;\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',461);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',118);\nuint256 count = 0;\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',462);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',119);\nuint256 i = 0;\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',463);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',120);\nuint256 j = 0;\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',464);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',121);\nfor (i = 0; i < activeUsers.length; i++) {\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',465);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',122);\ntickers = getArrayBytes32(Encoder.getKey(\"userToTickers\", activeUsers[i]));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',466);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',123);\nfor (j = 0; j < tickers.length; j++) {\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',467);\n                emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',124);\ntoken = getAddressValue(Encoder.getKey(\"tickerToSecurityToken\", Util.bytes32ToString(tickers[j])));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',468);\n                emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',125);\nif (token != address(0)) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',42,0);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',469);\n                    emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',126);\nif (IOwnable(token).owner() == _owner) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',43,0);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',470);\n                        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',127);\ncount = count + 1;\n                    }else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',43,1);}\n\n                }else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',42,1);}\n\n            }\n        }\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',475);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',128);\nuint256 index = 0;\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',476);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',129);\naddress[] memory result = new address[](count);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',477);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',130);\nfor (i = 0; i < activeUsers.length; i++) {\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',478);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',131);\ntickers = getArrayBytes32(Encoder.getKey(\"userToTickers\", activeUsers[i]));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',479);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',132);\nfor (j = 0; j < tickers.length; j++) {\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',480);\n                emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',133);\ntoken = getAddressValue(Encoder.getKey(\"tickerToSecurityToken\", Util.bytes32ToString(tickers[j])));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',481);\n                emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',134);\nif (token != address(0)) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',44,0);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',482);\n                    emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',135);\nif (IOwnable(token).owner() == _owner) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',45,0);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',483);\n                        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',136);\nresult[index] = token;\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',484);\n                        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',137);\nindex = index + 1;\n                    }else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',45,1);}\n\n                }else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',44,1);}\n\n            }\n        }\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',489);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',138);\nreturn result;\n    }\n\n    /**\n     * @notice Returns the owner and timestamp for a given ticker\n     * @param _ticker is the ticker symbol\n     * @return address\n     * @return uint256\n     * @return uint256\n     * @return string\n     * @return bool\n     */\n    function getTickerDetails(string _ticker) external  returns (address, uint256, uint256, string, bool) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',21);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',502);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',139);\nstring memory ticker = Util.upper(_ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',503);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',140);\nbool tickerStatus = _tickerStatus(ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',504);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',141);\nuint256 expiryDate = getUintValue(Encoder.getKey(\"registeredTickers_expiryDate\", ticker));\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',506);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',142);\nif ((tickerStatus == true) || (expiryDate > now)) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',46,0);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',507);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',143);\nreturn\n            (\n                _tickerOwner(ticker),\n                getUintValue(Encoder.getKey(\"registeredTickers_registrationDate\", ticker)),\n                expiryDate,\n                getStringValue(Encoder.getKey(\"registeredTickers_tokenName\", ticker)),\n                tickerStatus\n            );\n        } else\n            {emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',144);\nemit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',46,1);emit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',516);\nreturn (address(0), uint256(0), uint256(0), \"\", false);}\n    }\n\n    /////////////////////////////\n    // Security Token Management\n    /////////////////////////////\n\n    /**\n     * @notice Deploys an instance of a new Security Token and records it to the registry\n     * @param _name is the name of the token\n     * @param _ticker is the ticker symbol of the security token\n     * @param _tokenDetails is the off-chain details of the token\n     * @param _divisible is whether or not the token is divisible\n     */\n    function generateSecurityToken(string _name, string _ticker, string _tokenDetails, bool _divisible) external whenNotPausedOrOwner {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',22);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',531);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',47);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',145);\nrequire(bytes(_name).length > 0 && bytes(_ticker).length > 0, \"Ticker length > 0\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',47);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',532);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',146);\nstring memory ticker = Util.upper(_ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',533);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',147);\nbytes32 statusKey = Encoder.getKey(\"registeredTickers_status\", ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',534);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',48);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',148);\nrequire(!getBoolValue(statusKey), \"Already deployed\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',48);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',535);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',149);\nset(statusKey, true);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',536);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',49);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',150);\nrequire(_tickerOwner(ticker) == msg.sender, \"Not authorised\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',49);\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',538);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',50);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',151);\nrequire(getUintValue(Encoder.getKey(\"registeredTickers_expiryDate\", ticker)) >= now, \"Ticker gets expired\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',50);\n\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',540);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',152);\nuint256 launchFee = getSecurityTokenLaunchFee();\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',541);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',153);\nif (launchFee > 0)\n            {emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',52);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',154);\nemit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',51,0);emit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',542);\nrequire(IERC20(getAddressValue(POLYTOKEN)).transferFrom(msg.sender, address(this), launchFee), \"Insufficient allowance\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',52);\n}else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',51,1);}\n\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',544);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',155);\naddress newSecurityTokenAddress = ISTFactory(getSTFactoryAddress()).deployToken(\n            _name,\n            ticker,\n            18,\n            _tokenDetails,\n            msg.sender,\n            _divisible,\n            getAddressValue(POLYMATHREGISTRY)\n        );\n\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',555);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',156);\n_storeSecurityTokenData(newSecurityTokenAddress, ticker, _tokenDetails, now);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',556);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',157);\nset(Encoder.getKey(\"tickerToSecurityToken\", ticker), newSecurityTokenAddress);\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',558);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',158);\nemit NewSecurityToken(ticker, _name, newSecurityTokenAddress, msg.sender, now, msg.sender, false, launchFee);\n    }\n\n    /**\n     * @notice Adds a new custom Security Token and saves it to the registry. (Token should follow the ISecurityToken interface)\n     * @param _name is the name of the token\n     * @param _ticker is the ticker symbol of the security token\n     * @param _owner is the owner of the token\n     * @param _securityToken is the address of the securityToken\n     * @param _tokenDetails is the off-chain details of the token\n     * @param _deployedAt is the timestamp at which the security token is deployed\n     */\n    function modifySecurityToken(\n        string _name,\n        string _ticker,\n        address _owner,\n        address _securityToken,\n        string _tokenDetails,\n        uint256 _deployedAt\n    )\n        external\n        onlyOwner\n    {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',23);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',581);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',53);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',159);\nrequire(bytes(_name).length > 0 && bytes(_ticker).length > 0, \"String length > 0\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',53);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',582);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',54);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',160);\nrequire(bytes(_ticker).length <= 10, \"Ticker length range (0,10]\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',54);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',583);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',55);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',161);\nrequire(_deployedAt != 0 && _owner != address(0), \"0 value params not allowed\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',55);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',584);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',162);\nstring memory ticker = Util.upper(_ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',585);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',56);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',163);\nrequire(_securityToken != address(0), \"ST address is 0x\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',56);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',586);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',164);\nuint256 registrationTime = getUintValue(Encoder.getKey(\"registeredTickers_registrationDate\", ticker));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',587);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',165);\nuint256 expiryTime = getUintValue(Encoder.getKey(\"registeredTickers_expiryDate\", ticker));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',588);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',166);\nif (registrationTime == 0) {emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',57,0);\n            /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',590);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',167);\nregistrationTime = now;\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',591);\n            emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',168);\nexpiryTime = registrationTime.add(getExpiryLimit());\n        }else { emit __BranchCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',57,1);}\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',593);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',169);\nset(Encoder.getKey(\"tickerToSecurityToken\", ticker), _securityToken);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',594);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',170);\n_modifyTicker(_owner, ticker, _name, registrationTime, expiryTime, true);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',595);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',171);\n_storeSecurityTokenData(_securityToken, ticker, _tokenDetails, _deployedAt);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',596);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',172);\nemit NewSecurityToken(ticker, _name, _securityToken, _owner, _deployedAt, msg.sender, true, getSecurityTokenLaunchFee());\n    }\n\n    /**\n     * @notice Internal - Stores the security token details\n     */\n    function _storeSecurityTokenData(address _securityToken, string _ticker, string _tokenDetails, uint256 _deployedAt) internal {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',24);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',603);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',173);\nset(Encoder.getKey(\"securityTokens_ticker\", _securityToken), _ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',604);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',174);\nset(Encoder.getKey(\"securityTokens_tokenDetails\", _securityToken), _tokenDetails);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',605);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',175);\nset(Encoder.getKey(\"securityTokens_deployedAt\", _securityToken), _deployedAt);\n    }\n\n    /**\n    * @notice Checks that Security Token is registered\n    * @param _securityToken is the address of the security token\n    * @return bool\n    */\n    function isSecurityToken(address _securityToken) external  returns (bool) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',25);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',614);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',176);\nreturn (keccak256(bytes(getStringValue(Encoder.getKey(\"securityTokens_ticker\", _securityToken)))) != keccak256(\"\"));\n    }\n\n    /**\n     * @notice Returns the security token address by ticker symbol\n     * @param _ticker is the ticker of the security token\n     * @return address\n     */\n    function getSecurityTokenAddress(string _ticker) external  returns (address) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',26);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',623);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',177);\nstring memory ticker = Util.upper(_ticker);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',624);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',178);\nreturn getAddressValue(Encoder.getKey(\"tickerToSecurityToken\", ticker));\n    }\n\n     /**\n     * @notice Returns the security token data by address\n     * @param _securityToken is the address of the security token.\n     * @return string is the ticker of the security Token.\n     * @return address is the issuer of the security Token.\n     * @return string is the details of the security token.\n     * @return uint256 is the timestamp at which security Token was deployed.\n     */\n    function getSecurityTokenData(address _securityToken) external  returns (string, address, string, uint256) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',27);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',636);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',179);\nreturn (\n            getStringValue(Encoder.getKey(\"securityTokens_ticker\", _securityToken)),\n            IOwnable(_securityToken).owner(),\n            getStringValue(Encoder.getKey(\"securityTokens_tokenDetails\", _securityToken)),\n            getUintValue(Encoder.getKey(\"securityTokens_deployedAt\", _securityToken))\n        );\n    }\n\n    /////////////////////////////\n    // Ownership, lifecycle & Utility\n    /////////////////////////////\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address _newOwner) external onlyOwner {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',28);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',653);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',58);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',180);\nrequire(_newOwner != address(0), \"Invalid address\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',58);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',654);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',181);\nemit OwnershipTransferred(getAddressValue(OWNER), _newOwner);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',655);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',182);\nset(OWNER, _newOwner);\n    }\n\n    /**\n    * @notice Called by the owner to pause, triggers stopped state\n    */\n    function pause() external whenNotPaused onlyOwner {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',29);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',662);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',183);\nset(PAUSED, true);\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',664);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',184);\nemit Pause(now);\n    }\n\n    /**\n    * @notice Called by the owner to unpause, returns to normal state\n    */\n    function unpause() external whenPaused onlyOwner {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',30);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',671);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',185);\nset(PAUSED, false);\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',673);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',186);\nemit Unpause(now);\n    }\n\n    /**\n    * @notice Sets the ticker registration fee in POLY tokens. Only Polymath.\n    * @param _tickerRegFee is the registration fee in POLY tokens (base 18 decimals)\n    */\n    function changeTickerRegistrationFee(uint256 _tickerRegFee) external onlyOwner {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',31);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',681);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',187);\nuint256 fee = getUintValue(TICKERREGFEE);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',682);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',59);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',188);\nrequire(fee != _tickerRegFee, \"Fee not changed\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',59);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',683);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',189);\nemit ChangeTickerRegistrationFee(fee, _tickerRegFee);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',684);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',190);\nset(TICKERREGFEE, _tickerRegFee);\n    }\n\n   /**\n    * @notice Sets the ticker registration fee in POLY tokens. Only Polymath.\n    * @param _stLaunchFee is the registration fee in POLY tokens (base 18 decimals)\n    */\n    function changeSecurityLaunchFee(uint256 _stLaunchFee) external onlyOwner {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',32);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',692);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',191);\nuint256 fee = getUintValue(STLAUNCHFEE);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',693);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',60);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',192);\nrequire(fee != _stLaunchFee, \"Fee not changed\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',60);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',694);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',193);\nemit ChangeSecurityLaunchFee(fee, _stLaunchFee);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',695);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',194);\nset(STLAUNCHFEE, _stLaunchFee);\n    }\n\n    /**\n    * @notice Reclaims all ERC20Basic compatible tokens\n    * @param _tokenContract is the address of the token contract\n    */\n    function reclaimERC20(address _tokenContract) external onlyOwner {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',33);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',703);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',61);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',195);\nrequire(_tokenContract != address(0), \"Invalid address\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',61);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',704);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',196);\nIERC20 token = IERC20(_tokenContract);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',705);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',197);\nuint256 balance = token.balanceOf(address(this));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',706);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',62);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',198);\nrequire(token.transfer(owner(), balance), \"Transfer failed\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',62);\n\n    }\n\n    /**\n    * @notice Changes the protocol version and the SecurityToken contract\n    * @notice Used only by Polymath to upgrade the SecurityToken contract and add more functionalities to future versions\n    * @notice Changing versions does not affect existing tokens.\n    * @param _STFactoryAddress is the address of the proxy.\n    * @param _major Major version of the proxy.\n    * @param _minor Minor version of the proxy.\n    * @param _patch Patch version of the proxy\n    */\n    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) external onlyOwner {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',34);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',719);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',63);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',199);\nrequire(_STFactoryAddress != address(0), \"0x address is not allowed\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',63);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',720);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',200);\n_setProtocolVersion(_STFactoryAddress, _major, _minor, _patch);\n    }\n\n    /**\n    * @notice Internal - Changes the protocol version and the SecurityToken contract\n    */\n    function _setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) internal {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',35);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',727);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',201);\nuint8[] memory _version = new uint8[](3);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',728);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',202);\n_version[0] = _major;\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',729);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',203);\n_version[1] = _minor;\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',730);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',204);\n_version[2] = _patch;\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',731);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',205);\nuint24 _packedVersion = VersionUtils.pack(_major, _minor, _patch);\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',732);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',64);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',206);\nrequire(VersionUtils.isValidVersion(getProtocolVersion(), _version),\"In-valid version\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',64);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',733);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',207);\nset(Encoder.getKey(\"latestVersion\"), uint256(_packedVersion));\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',734);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',208);\nset(Encoder.getKey(\"protocolVersionST\", getUintValue(Encoder.getKey(\"latestVersion\"))), _STFactoryAddress);\n    }\n\n    /**\n     * @notice Returns the current STFactory Address\n     */\n    function getSTFactoryAddress() public  returns(address) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',36);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',741);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',209);\nreturn getAddressValue(Encoder.getKey(\"protocolVersionST\", getUintValue(Encoder.getKey(\"latestVersion\"))));\n    }\n\n    /**\n     * @notice Gets Protocol version\n     */\n    function getProtocolVersion() public  returns(uint8[]) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',37);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',748);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',210);\nreturn VersionUtils.unpack(uint24(getUintValue(Encoder.getKey(\"latestVersion\"))));\n    }\n\n    /**\n     * @notice Changes the PolyToken address. Only Polymath.\n     * @param _newAddress is the address of the polytoken.\n     */\n    function updatePolyTokenAddress(address _newAddress) external onlyOwner {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',38);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',756);\n        emit __AssertPreCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',65);\nemit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',211);\nrequire(_newAddress != address(0), \"Invalid address\");emit __AssertPostCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',65);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',757);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',212);\nset(POLYTOKEN, _newAddress);\n    }\n\n    /**\n     * @notice Gets the security token launch fee\n     * @return Fee amount\n     */\n    function getSecurityTokenLaunchFee() public  returns(uint256) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',39);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',765);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',213);\nreturn getUintValue(STLAUNCHFEE);\n    }\n\n    /**\n     * @notice Gets the ticker registration fee\n     * @return Fee amount\n     */\n    function getTickerRegistrationFee() public  returns(uint256) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',40);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',773);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',214);\nreturn getUintValue(TICKERREGFEE);\n    }\n\n    /**\n     * @notice Gets the expiry limit\n     * @return Expiry limit\n     */\n    function getExpiryLimit() public  returns(uint256) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',41);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',781);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',215);\nreturn getUintValue(EXPIRYLIMIT);\n    }\n\n    /**\n     * @notice Check whether the registry is paused or not\n     * @return bool\n     */\n    function isPaused() public  returns(bool) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',42);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',789);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',216);\nreturn getBoolValue(PAUSED);\n    }\n\n    /**\n     * @notice Gets the owner of the contract\n     * @return address owner\n     */\n    function owner() public  returns(address) {emit __FunctionCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',43);\n\nemit __CoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',797);\n        emit __StatementCoverageSecurityTokenRegistry('./contracts/SecurityTokenRegistry.sol',217);\nreturn getAddressValue(OWNER);\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/mocks/SecurityTokenRegistryMock.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../SecurityTokenRegistry.sol\";\n\n/**\n * @title Registry contract for issuers to register their security tokens\n */\ncontract SecurityTokenRegistryMock is SecurityTokenRegistry {\n    \n    /// @notice It is a dummy function\n    /// Alert! Alert! Do not use it for the mainnet release\n    function changeTheDeployedAddress(string _ticker, address _newSecurityTokenAddress) public {\n        set(Encoder.getKey(\"tickerToSecurityToken\", _ticker), _newSecurityTokenAddress);\n    } \n    \n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/external/IMedianizer.sol":{"content":"/* solium-disable */\npragma solidity ^0.4.24;\n\n/**\n * @title Interface to MakerDAO Medianizer contract\n */\n\ninterface IMedianizer {\n\n    function peek() constant external returns (bytes32, bool);\n\n    function read() constant external returns (bytes32);\n\n    function set(address wat) external;\n\n    function set(bytes12 pos, address wat) external;\n\n    function setMin(uint96 min_) external;\n\n    function setNext(bytes12 next_) external;\n\n    function unset(bytes12 pos) external;\n\n    function unset(address wat) external;\n\n    function poke() external;\n\n    function poke(bytes32) external;\n\n    function compute() constant external returns (bytes32, bool);\n\n    function void() external;\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/oracles/MakerDAOOracle.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../interfaces/IOracle.sol\";\nimport \"../external/IMedianizer.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\ncontract MakerDAOOracle is IOracle, Ownable {\n\n    address public medianizer;\n    address public currencyAddress;\n    bytes32 public currencySymbol;\n\n    bool public manualOverride;\n    uint256 public manualPrice;\n\n    /*solium-disable-next-line security/no-block-members*/\n    event ChangeMedianizer(address _newMedianizer, address _oldMedianizer, uint256 _now);\n    event SetManualPrice(uint256 _oldPrice, uint256 _newPrice, uint256 _time);\n    event SetManualOverride(bool _override, uint256 _time);\n\n    /**\n      * @notice Creates a new Maker based oracle\n      * @param _medianizer Address of Maker medianizer\n      * @param _currencyAddress Address of currency (0x0 for ETH)\n      * @param _currencySymbol Symbol of currency\n      */\n    constructor (address _medianizer, address _currencyAddress, bytes32 _currencySymbol) public {\n        medianizer = _medianizer;\n        currencyAddress = _currencyAddress;\n        currencySymbol = _currencySymbol;\n    }\n\n    /**\n      * @notice Updates medianizer address\n      * @param _medianizer Address of Maker medianizer\n      */\n    function changeMedianier(address _medianizer) public onlyOwner {\n        require(_medianizer != address(0), \"0x not allowed\");\n        /*solium-disable-next-line security/no-block-members*/\n        emit ChangeMedianizer(_medianizer, medianizer, now);\n        medianizer = _medianizer;\n    }\n\n    /**\n    * @notice Returns address of oracle currency (0x0 for ETH)\n    */\n    function getCurrencyAddress() external  returns(address) {\n        return currencyAddress;\n    }\n\n    /**\n    * @notice Returns symbol of oracle currency (0x0 for ETH)\n    */\n    function getCurrencySymbol() external  returns(bytes32) {\n        return currencySymbol;\n    }\n\n    /**\n    * @notice Returns denomination of price\n    */\n    function getCurrencyDenominated() external  returns(bytes32) {\n        // All MakerDAO oracles are denominated in USD\n        return bytes32(\"USD\");\n    }\n\n    /**\n    * @notice Returns price - should throw if not valid\n    */\n    function getPrice() external  returns(uint256) {\n        if (manualOverride) {\n            return manualPrice;\n        }\n        (bytes32 price, bool valid) = IMedianizer(medianizer).peek();\n        require(valid, \"MakerDAO Oracle returning invalid value\");\n        return uint256(price);\n    }\n\n    /**\n      * @notice Set a manual price. NA - this will only be used if manualOverride == true\n      * @param _price Price to set\n      */\n    function setManualPrice(uint256 _price) public onlyOwner {\n        /*solium-disable-next-line security/no-block-members*/\n        emit SetManualPrice(manualPrice, _price, now);\n        manualPrice = _price;\n    }\n\n    /**\n      * @notice Determine whether manual price is used or not\n      * @param _override Whether to use the manual override price or not\n      */\n    function setManualOverride(bool _override) public onlyOwner {\n        manualOverride = _override;\n        /*solium-disable-next-line security/no-block-members*/\n        emit SetManualOverride(_override, now);\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/external/oraclizeAPI.sol":{"content":"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize SRL\nCopyright (c) 2016 Oraclize LTD\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// This api is currently targeted at 0.4.18, please import oraclizeAPI_pre0.4.sol or oraclizeAPI_0.4 where necessary\n/* solium-disable */\npragma solidity >=0.4.18;// Incompatible compiler version... please select one stated within pragma solidity or use different oraclizeAPI version\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n    function getPrice(string _datasource) public returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n    function setProofType(byte _proofType) external;\n    function setCustomGasPrice(uint _gasPrice) external;\n    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n}\n\ncontract OraclizeAddrResolverI {\n    function getAddress() public returns (address _addr);\n}\n\n/*\nBegin solidity-cborutils\nhttps://github.com/smartcontractkit/solidity-cborutils\nMIT License\nCopyright (c) 2018 SmartContract ChainLink, Ltd.\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\nlibrary Buffer {\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    function init(buffer memory buf, uint _capacity) internal pure {\n        uint capacity = _capacity;\n        if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(ptr, capacity))\n        }\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint a, uint b) private pure returns(uint) {\n        if(a > b) {\n            return a;\n        }\n        return b;\n    }\n\n    /**\n     * @dev Appends a byte array to the end of the buffer. Resizes if doing so\n     *      would exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer.\n     */\n    function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n        if(data.length + buf.buf.length > buf.capacity) {\n            resize(buf, max(buf.capacity, data.length) * 2);\n        }\n\n        uint dest;\n        uint src;\n        uint len = data.length;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + buffer length + sizeof(buffer length)\n            dest := add(add(bufptr, buflen), 32)\n            // Update buffer length\n            mstore(bufptr, add(buflen, mload(data)))\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for(; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     * exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer.\n     */\n    function append(buffer memory buf, uint8 data) internal pure {\n        if(buf.buf.length + 1 > buf.capacity) {\n            resize(buf, buf.capacity * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Address = buffer address + buffer length + sizeof(buffer length)\n            let dest := add(add(bufptr, buflen), 32)\n            mstore8(dest, data)\n            // Update buffer length\n            mstore(bufptr, add(buflen, 1))\n        }\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     * exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        if(len + buf.buf.length > buf.capacity) {\n            resize(buf, max(buf.capacity, len) * 2);\n        }\n\n        uint mask = 256 ** len - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Address = buffer address + buffer length + sizeof(buffer length) + len\n            let dest := add(add(bufptr, buflen), len)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length\n            mstore(bufptr, add(buflen, len))\n        }\n        return buf;\n    }\n}\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\n        if(value <= 23) {\n            buf.append(uint8((major << 5) | value));\n        } else if(value <= 0xFF) {\n            buf.append(uint8((major << 5) | 24));\n            buf.appendInt(value, 1);\n        } else if(value <= 0xFFFF) {\n            buf.append(uint8((major << 5) | 25));\n            buf.appendInt(value, 2);\n        } else if(value <= 0xFFFFFFFF) {\n            buf.append(uint8((major << 5) | 26));\n            buf.appendInt(value, 4);\n        } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n            buf.append(uint8((major << 5) | 27));\n            buf.appendInt(value, 8);\n        }\n    }\n\n    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\n        buf.append(uint8((major << 5) | 31));\n    }\n\n    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\n        encodeType(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function encodeInt(Buffer.buffer memory buf, int value) internal pure {\n        if(value >= 0) {\n            encodeType(buf, MAJOR_TYPE_INT, uint(value));\n        } else {\n            encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\n        }\n    }\n\n    function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\n        encodeType(buf, MAJOR_TYPE_BYTES, value.length);\n        buf.append(value);\n    }\n\n    function encodeString(Buffer.buffer memory buf, string value) internal pure {\n        encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\n        buf.append(bytes(value));\n    }\n\n    function startArray(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n    }\n\n    function startMap(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n    }\n\n    function endSequence(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n    }\n}\n\n/*\nEnd solidity-cborutils\n */\n\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofType_Ledger = 0x30;\n    byte constant proofType_Android = 0x40;\n    byte constant proofType_Native = 0xF0;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n\n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n            oraclize_setNetwork(networkID_auto);\n\n        if(address(oraclize) != OAR.getAddress())\n            oraclize = OraclizeI(OAR.getAddress());\n\n        _;\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        _;\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n      return oraclize_setNetwork();\n      networkID; // silence the warning and remain backwards compatible\n    }\n    function oraclize_setNetwork() internal returns(bool){\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n            oraclize_setNetworkName(\"eth_mainnet\");\n            return true;\n        }\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n            oraclize_setNetworkName(\"eth_ropsten3\");\n            return true;\n        }\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n            oraclize_setNetworkName(\"eth_kovan\");\n            return true;\n        }\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n            oraclize_setNetworkName(\"eth_rinkeby\");\n            return true;\n        }\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n            return true;\n        }\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n            return true;\n        }\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n            return true;\n        }\n        return false;\n    }\n\n    function __callback(bytes32 myid, string result) public {\n        __callback(myid, result, new bytes(0));\n    }\n    function __callback(bytes32 myid, string result, bytes proof) public {\n      return;\n      myid; result; proof; // Silence compiler warnings\n    }\n\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n        return oraclize.getPrice(datasource);\n    }\n\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n        return oraclize.getPrice(datasource, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN.value(price)(0, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = stra2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        string[] memory dynargs = new string[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN.value(price)(0, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        bytes memory args = ba2cbor(argN);\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](1);\n        dynargs[0] = args[0];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](2);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](3);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](4);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs);\n    }\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n    }\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n        bytes[] memory dynargs = new bytes[](5);\n        dynargs[0] = args[0];\n        dynargs[1] = args[1];\n        dynargs[2] = args[2];\n        dynargs[3] = args[3];\n        dynargs[4] = args[4];\n        return oraclize_query(datasource, dynargs, gaslimit);\n    }\n\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n        return oraclize.setCustomGasPrice(gasPrice);\n    }\n\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n        return oraclize.randomDS_getSessionPubKeyHash();\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n    function parseAddr(string _a) internal pure returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n    function strCompare(string _a, string _b) internal pure returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n    }\n\n    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string _a, string _b) internal pure returns (string) {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal pure returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n\n    function uint2str(uint i) internal pure returns (string){\n        if (i == 0) return \"0\";\n        uint j = i;\n        uint len;\n        while (j != 0){\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (i != 0){\n            bstr[k--] = byte(48 + i % 10);\n            i /= 10;\n        }\n        return string(bstr);\n    }\n\n    using CBOR for Buffer.buffer;\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\n        safeMemoryCleaner();\n        Buffer.buffer memory buf;\n        Buffer.init(buf, 1024);\n        buf.startArray();\n        for (uint i = 0; i < arr.length; i++) {\n            buf.encodeString(arr[i]);\n        }\n        buf.endSequence();\n        return buf.buf;\n    }\n\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n        safeMemoryCleaner();\n        Buffer.buffer memory buf;\n        Buffer.init(buf, 1024);\n        buf.startArray();\n        for (uint i = 0; i < arr.length; i++) {\n            buf.encodeBytes(arr[i]);\n        }\n        buf.endSequence();\n        return buf.buf;\n    }\n\n    string oraclize_network_name;\n    function oraclize_setNetworkName(string _network_name) internal {\n        oraclize_network_name = _network_name;\n    }\n\n    function oraclize_getNetworkName() internal view returns (string) {\n        return oraclize_network_name;\n    }\n\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n        require((_nbytes > 0) && (_nbytes <= 32));\n        // Convert from seconds to ledger timer ticks\n        _delay *= 10;\n        bytes memory nbytes = new bytes(1);\n        nbytes[0] = byte(_nbytes);\n        bytes memory unonce = new bytes(32);\n        bytes memory sessionKeyHash = new bytes(32);\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n        assembly {\n            mstore(unonce, 0x20)\n            // the following variables can be relaxed\n            // check relaxed random contract under ethereum-examples repo\n            // for an idea on how to override and replace comit hash vars\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n            mstore(sessionKeyHash, 0x20)\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n        }\n        bytes memory delay = new bytes(32);\n        assembly {\n            mstore(add(delay, 0x20), _delay)\n        }\n\n        bytes memory delay_bytes8 = new bytes(8);\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n        assembly {\n            let x := mload(add(delay_bytes8, 0x20))\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n        }\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n        return queryId;\n    }\n\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n        oraclize_randomDS_args[queryId] = commitment;\n    }\n\n    mapping(bytes32=>bytes32) oraclize_randomDS_args;\n    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n        bool sigok;\n        address signer;\n\n        bytes32 sigr;\n        bytes32 sigs;\n\n        bytes memory sigr_ = new bytes(32);\n        uint offset = 4+(uint(dersig[3]) - 0x20);\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n        bytes memory sigs_ = new bytes(32);\n        offset += 32 + 2;\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n\n        assembly {\n            sigr := mload(add(sigr_, 32))\n            sigs := mload(add(sigs_, 32))\n        }\n\n\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n        if (address(keccak256(pubkey)) == signer) return true;\n        else {\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n            return (address(keccak256(pubkey)) == signer);\n        }\n    }\n\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n        bool sigok;\n\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n\n        bytes memory appkey1_pubkey = new bytes(64);\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n\n        bytes memory tosign2 = new bytes(1+65+32);\n        tosign2[0] = byte(1); //role\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n\n        if (sigok == false) return false;\n\n\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n\n        bytes memory tosign3 = new bytes(1+65);\n        tosign3[0] = 0xFE;\n        copyBytes(proof, 3, 65, tosign3, 1);\n\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\n\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n\n        return sigok;\n    }\n\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n        require(proofVerified);\n\n        _;\n    }\n\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n        if (proofVerified == false) return 2;\n\n        return 0;\n    }\n\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n        bool match_ = true;\n\n        require(prefix.length == n_random_bytes);\n\n        for (uint256 i=0; i< n_random_bytes; i++) {\n            if (content[i] != prefix[i]) match_ = false;\n        }\n\n        return match_;\n    }\n\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n        bytes memory keyhash = new bytes(32);\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n        if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\n\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\n        // This is to verify that the computed args match with the ones specified in the query.\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n\n        bytes memory sessionPubkey = new bytes(64);\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match\n            delete oraclize_randomDS_args[queryId];\n        } else return false;\n\n\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\n        bytes memory tosign1 = new bytes(32+8+1+32);\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n        }\n\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n        uint minLength = length + toOffset;\n\n        // Buffer too small\n        require(to.length >= minLength); // Should be a better way?\n\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n        uint i = 32 + fromOffset;\n        uint j = 32 + toOffset;\n\n        while (i < (32 + fromOffset + length)) {\n            assembly {\n                let tmp := mload(add(from, i))\n                mstore(add(to, j), tmp)\n            }\n            i += 32;\n            j += 32;\n        }\n\n        return to;\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n        // We do our own memory management here. Solidity uses memory offset\n        // 0x40 to store the current end of memory. We write past it (as\n        // writes are memory extensions), but don't update the offset so\n        // Solidity will reuse it. The memory used here is only needed for\n        // this context.\n\n        // FIXME: inline assembly can't access return values\n        bool ret;\n        address addr;\n\n        assembly {\n            let size := mload(0x40)\n            mstore(size, hash)\n            mstore(add(size, 32), v)\n            mstore(add(size, 64), r)\n            mstore(add(size, 96), s)\n\n            // NOTE: we can reuse the request memory because we deal with\n            //       the return code\n            ret := call(3000, 1, 0, size, 128, size, 32)\n            addr := mload(size)\n        }\n\n        return (ret, addr);\n    }\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        if (sig.length != 65)\n          return (false, 0);\n\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n\n            // Here we are loading the last 32 bytes. We exploit the fact that\n            // 'mload' will pad with zeroes if we overread.\n            // There is no 'mload8' to do this, but that would be nicer.\n            v := byte(0, mload(add(sig, 96)))\n\n            // Alternative solution:\n            // 'byte' is not working due to the Solidity parser, so lets\n            // use the second best option, 'and'\n            // v := and(mload(add(sig, 65)), 255)\n        }\n\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\n        // to match the YP range of [27, 28]\n        //\n        // geth uses [0, 1] and some clients have followed. This might change, see:\n        //  https://github.com/ethereum/go-ethereum/issues/2053\n        if (v < 27)\n          v += 27;\n\n        if (v != 27 && v != 28)\n            return (false, 0);\n\n        return safer_ecrecover(hash, v, r, s);\n    }\n\n    function safeMemoryCleaner() internal pure {\n        assembly {\n            let fmem := mload(0x40)\n            codecopy(fmem, codesize, sub(msize, fmem))\n        }\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/oracles/PolyOracle.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../external/oraclizeAPI.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IOracle.sol\";\n\ncontract PolyOracle is usingOraclize, IOracle, Ownable {\n    using SafeMath for uint256;\n\n    /*solium-disable-next-line max-len*/\n    string public oracleURL = \"[URL] json(https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest?id=2496&convert=USD&CMC_PRO_API_KEY=${[decrypt] BCA0Bqxmn3jkSENepaHxQv09Z/vGdEO9apO+B9RplHyV3qOL/dw5Indlei3hoXrGk9G14My8MFpHJycB7UoVnl+4mlzEsjTlS2UBAYVrl0fAepfiSyM30/GMZAoJmDagY+0YyNZvpkgXn86Q/59Bi48PWEet}).data.\\\"2496\\\".quote.USD.price\";\n    string public oracleQueryType = \"nested\";\n    uint256 public sanityBounds = 20*10**16;\n    uint256 public gasLimit = 100000;\n    uint256 public oraclizeTimeTolerance = 5 minutes;\n    uint256 public staleTime = 6 hours;\n\n    uint256 private POLYUSD;\n    uint256 public latestUpdate;\n    uint256 public latestScheduledUpdate;\n\n    mapping (bytes32 => uint256) public requestIds;\n    mapping (bytes32 => bool) public ignoreRequestIds;\n\n    mapping (address => bool) public admin;\n\n    bool public freezeOracle;\n\n    event PriceUpdated(uint256 _price, uint256 _oldPrice, bytes32 _queryId, uint256 _time);\n    event NewOraclizeQuery(uint256 _time, bytes32 _queryId, string _query);\n    event AdminSet(address _admin, bool _valid, uint256 _time);\n    event StalePriceUpdate(bytes32 _queryId, uint256 _time, string _result);\n\n    modifier isAdminOrOwner {\n        require(admin[msg.sender] || msg.sender == owner, \"Address is not admin or owner\");\n        _;\n    }\n\n    /**\n    * @notice Constructor - accepts ETH to initialise a balance for subsequent Oraclize queries\n    */\n    constructor() payable public {\n        // Use 50 gwei for now\n        oraclize_setCustomGasPrice(50*10**9);\n    }\n\n    /**\n    * @notice Oraclize callback (triggered by Oraclize)\n    * @param _requestId requestId corresponding to Oraclize query\n    * @param _result data returned by Oraclize URL query\n    */\n    function __callback(bytes32 _requestId, string _result) public {\n        require(msg.sender == oraclize_cbAddress(), \"Only Oraclize can access this method\");\n        require(!freezeOracle, \"Oracle is frozen\");\n        require(!ignoreRequestIds[_requestId], \"Ignoring requestId\");\n        if (requestIds[_requestId] < latestUpdate) {\n            // Result is stale, probably because it was received out of order\n            emit StalePriceUpdate(_requestId, requestIds[_requestId], _result);\n            return;\n        }\n        require(requestIds[_requestId] >= latestUpdate, \"Result is stale\");\n        /*solium-disable-next-line security/no-block-members*/\n        require(requestIds[_requestId] <= now + oraclizeTimeTolerance, \"Result is early\");\n        uint256 newPOLYUSD = parseInt(_result, 18);\n        uint256 bound = POLYUSD.mul(sanityBounds).div(10**18);\n        if (latestUpdate != 0) {\n            require(newPOLYUSD <= POLYUSD.add(bound), \"Result is too large\");\n            require(newPOLYUSD >= POLYUSD.sub(bound), \"Result is too small\");\n        }\n        latestUpdate = requestIds[_requestId];\n        emit PriceUpdated(newPOLYUSD, POLYUSD, _requestId, latestUpdate);\n        POLYUSD = newPOLYUSD;\n    }\n\n    /**\n    * @notice Allows owner to schedule future Oraclize calls\n    * @param _times UNIX timestamps to schedule Oraclize calls as of. Empty list means trigger an immediate query.\n    */\n    function schedulePriceUpdatesFixed(uint256[] _times) public payable isAdminOrOwner {\n        bytes32 requestId;\n        uint256 maximumScheduledUpdated;\n        if (_times.length == 0) {\n            require(oraclize_getPrice(oracleQueryType, gasLimit) <= address(this).balance, \"Insufficient Funds\");\n            requestId = oraclize_query(oracleQueryType, oracleURL, gasLimit);\n            /*solium-disable-next-line security/no-block-members*/\n            requestIds[requestId] = now;\n            /*solium-disable-next-line security/no-block-members*/\n            maximumScheduledUpdated = now;\n            /*solium-disable-next-line security/no-block-members*/\n            emit NewOraclizeQuery(now, requestId, oracleURL);\n        } else {\n            require(oraclize_getPrice(oracleQueryType, gasLimit) * _times.length <= address(this).balance, \"Insufficient Funds\");\n            for (uint256 i = 0; i < _times.length; i++) {\n                /*solium-disable-next-line security/no-block-members*/\n                require(_times[i] >= now, \"Past scheduling is not allowed and scheduled time should be absolute timestamp\");\n                requestId = oraclize_query(_times[i], oracleQueryType, oracleURL, gasLimit);\n                requestIds[requestId] = _times[i];\n                if (maximumScheduledUpdated < requestIds[requestId]) {\n                    maximumScheduledUpdated = requestIds[requestId];\n                }\n                emit NewOraclizeQuery(_times[i], requestId, oracleURL);\n            }\n        }\n        if (latestScheduledUpdate < maximumScheduledUpdated) {\n            latestScheduledUpdate = maximumScheduledUpdated;\n        }\n    }\n\n    /**\n    * @notice Allows owner to schedule future Oraclize calls on a rolling schedule\n    * @param _startTime UNIX timestamp for the first scheduled Oraclize query\n    * @param _interval how long (in seconds) between each subsequent Oraclize query\n    * @param _iters the number of Oraclize queries to schedule.\n    */\n    function schedulePriceUpdatesRolling(uint256 _startTime, uint256 _interval, uint256 _iters) public payable isAdminOrOwner {\n        bytes32 requestId;\n        require(_interval > 0, \"Interval between scheduled time should be greater than zero\");\n        require(_iters > 0, \"No iterations specified\");\n        /*solium-disable-next-line security/no-block-members*/\n        require(_startTime >= now, \"Past scheduling is not allowed and scheduled time should be absolute timestamp\");\n        require(oraclize_getPrice(oracleQueryType, gasLimit) * _iters <= address(this).balance, \"Insufficient Funds\");\n        for (uint256 i = 0; i < _iters; i++) {\n            uint256 scheduledTime = _startTime + (i * _interval);\n            requestId = oraclize_query(scheduledTime, oracleQueryType, oracleURL, gasLimit);\n            requestIds[requestId] = scheduledTime;\n            emit NewOraclizeQuery(scheduledTime, requestId, oracleURL);\n        }\n        if (latestScheduledUpdate < requestIds[requestId]) {\n            latestScheduledUpdate = requestIds[requestId];\n        }\n    }\n\n    /**\n    * @notice Allows owner to manually set POLYUSD price\n    * @param _price POLYUSD price\n    */\n    function setPOLYUSD(uint256 _price) public onlyOwner {\n        /*solium-disable-next-line security/no-block-members*/\n        emit PriceUpdated(_price, POLYUSD, 0, now);\n        POLYUSD = _price;\n        /*solium-disable-next-line security/no-block-members*/\n        latestUpdate = now;\n    }\n\n    /**\n    * @notice Allows owner to set oracle to ignore all Oraclize pricce updates\n    * @param _frozen true to freeze updates, false to reenable updates\n    */\n    function setFreezeOracle(bool _frozen) public onlyOwner {\n        freezeOracle = _frozen;\n    }\n\n    /**\n    * @notice Allows owner to set URL used in Oraclize queries\n    * @param _oracleURL URL to use\n    */\n    function setOracleURL(string _oracleURL) public onlyOwner {\n        oracleURL = _oracleURL;\n    }\n\n    /**\n    * @notice Allows owner to set type used in Oraclize queries\n    * @param _oracleQueryType to use\n    */\n    function setOracleQueryType(string _oracleQueryType) public onlyOwner {\n        oracleQueryType = _oracleQueryType;\n    }\n\n    /**\n    * @notice Allows owner to set new sanity bounds for price updates\n    * @param _sanityBounds sanity bounds as a percentage * 10**16\n    */\n    function setSanityBounds(uint256 _sanityBounds) public onlyOwner {\n        sanityBounds = _sanityBounds;\n    }\n\n    /**\n    * @notice Allows owner to set new gas price for future Oraclize queries\n    * @notice NB - this will only impact newly scheduled Oraclize queries, not future queries which have already been scheduled\n    * @param _gasPrice gas price to use for Oraclize callbacks\n    */\n    function setGasPrice(uint256 _gasPrice) public onlyOwner {\n        oraclize_setCustomGasPrice(_gasPrice);\n    }\n\n    /**\n    * @notice Returns price and corresponding update time\n    * @return latest POLYUSD price\n    * @return timestamp of latest price update\n    */\n    function getPriceAndTime() public  returns(uint256, uint256) {\n        return (POLYUSD, latestUpdate);\n    }\n\n    /**\n    * @notice Allows owner to set new gas limit on Oraclize queries\n    * @notice NB - this will only impact newly scheduled Oraclize queries, not future queries which have already been scheduled\n    * @param _gasLimit gas limit to use for Oraclize callbacks\n    */\n    function setGasLimit(uint256 _gasLimit) public isAdminOrOwner {\n        gasLimit = _gasLimit;\n    }\n\n    /**\n    * @notice Allows owner to set time after which price is considered stale\n    * @param _staleTime elapsed time after which price is considered stale\n    */\n    function setStaleTime(uint256 _staleTime) public onlyOwner {\n        staleTime = _staleTime;\n    }\n\n    /**\n    * @notice Allows owner to ignore specific requestId results from Oraclize\n    * @param _requestIds Oraclize queryIds (as logged out when Oraclize query is scheduled)\n    * @param _ignore whether or not they should be ignored\n    */\n    function setIgnoreRequestIds(bytes32[] _requestIds, bool[] _ignore) public onlyOwner {\n        require(_requestIds.length == _ignore.length, \"Incorrect parameter lengths\");\n        for (uint256 i = 0; i < _requestIds.length; i++) {\n            ignoreRequestIds[_requestIds[i]] = _ignore[i];\n        }\n    }\n\n    /**\n    * @notice Allows owner to set up admin addresses that can schedule updates\n    * @param _admin Admin address\n    * @param _valid Whether address should be added or removed from admin list\n    */\n    function setAdmin(address _admin, bool _valid) public onlyOwner {\n        admin[_admin] = _valid;\n        /*solium-disable-next-line security/no-block-members*/\n        emit AdminSet(_admin, _valid, now);\n    }\n\n    /**\n    * @notice Allows owner to set new time tolerance on Oraclize queries\n    * @param _oraclizeTimeTolerance amount of time in seconds that an Oraclize query can be early\n    */\n    function setOraclizeTimeTolerance(uint256 _oraclizeTimeTolerance) public onlyOwner {\n        oraclizeTimeTolerance = _oraclizeTimeTolerance;\n    }\n\n    /**\n    * @notice Returns address of oracle currency (0x0 for ETH)\n    */\n    function getCurrencyAddress() external  returns(address) {\n        return 0x9992eC3cF6A55b00978cdDF2b27BC6882d88D1eC;\n    }\n\n    /**\n    * @notice Returns symbol of oracle currency (0x0 for ETH)\n    */\n    function getCurrencySymbol() external  returns(bytes32) {\n        return bytes32(\"POLY\");\n    }\n\n    /**\n    * @notice Returns denomination of price\n    */\n    function getCurrencyDenominated() external  returns(bytes32) {\n        return bytes32(\"USD\");\n    }\n\n    /**\n    * @notice Returns price - should throw if not valid\n    */\n    function getPrice() external  returns(uint256) {\n        /*solium-disable-next-line security/no-block-members*/\n        require(latestUpdate >= now - staleTime, \"Invalid price\");\n        return POLYUSD;\n    }\n\n    /**\n    * @notice Returns balance to owner\n    */\n    function drainContract() external onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/mocks/MockPolyOracle.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../oracles/PolyOracle.sol\";\n\ncontract MockPolyOracle is PolyOracle {\n\n    constructor() payable public {\n        OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n    }\n\n}"},"/home/max/Desktop/Ethereum/polymath-core/contracts/libraries/KindMath.sol":{"content":"pragma solidity ^0.4.24;\n\n// Copied from OpenZeppelin and modified to be friendlier\n\n/**\n * @title KindMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary KindMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than requireing 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        require(c / a == b, \"mul overflow\");\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // require(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // require(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"sub overflow\");\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        require(c >= a, \"add overflow\");\n        return c;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/mocks/MockBurnFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./MockRedemptionManager.sol\";\nimport \"../modules/Experimental/Burn/TrackedRedemptionFactory.sol\";\n\n/**\n * @title Mock Contract Not fit for production environment\n */\n\ncontract MockBurnFactory is TrackedRedemptionFactory {\n\n     /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n      TrackedRedemptionFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {\n    }\n\n    /**\n     * @notice Used to launch the Module with the help of factory\n     * @return Address Contract address of the Module\n     */\n    function deploy(bytes /*_data*/) external returns(address) {\n        if(setupCost > 0)\n            {require(polyToken.transferFrom(msg.sender, owner, setupCost), \"Unable to pay setup cost\");}\n        //Check valid bytes - can only call module init function\n        MockRedemptionManager mockRedemptionManager = new MockRedemptionManager(msg.sender, address(polyToken));\n        /*solium-disable-next-line security/no-block-members*/\n        emit GenerateModuleFromFactory(address(mockRedemptionManager), getName(), address(this), msg.sender, setupCost, now);\n        return address(mockRedemptionManager);\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/mocks/MockWrongTypeFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./MockBurnFactory.sol\";\nimport \"../modules/ModuleFactory.sol\";\nimport \"../libraries/Util.sol\";\n\n/**\n * @title Mock Contract Not fit for production environment\n */\n\ncontract MockWrongTypeFactory is MockBurnFactory {\n\n     /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n      MockBurnFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {\n        uint8[] memory types = new uint8[](1);\n        types[0] = 4;\n        return types;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/mocks/MockRedemptionManager.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../modules/Experimental/Burn/TrackedRedemption.sol\";\n\n/**\n * @title Burn module for burning tokens and keeping track of burnt amounts\n */\ncontract MockRedemptionManager is TrackedRedemption {\n\n    mapping (address => uint256) tokenToRedeem;\n\n    event RedeemedTokenByOwner(address _investor, address _byWhoom, uint256 _value, uint256 _timestamp);\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress) public\n    TrackedRedemption(_securityToken, _polyAddress)\n    {\n    }\n\n    /**\n     * @notice Transfers tokens to Module to burn\n     * @param _value The number of tokens to redeem\n     */\n    function transferToRedeem(uint256 _value) public {\n        require(ISecurityToken(securityToken).transferFrom(msg.sender, address(this), _value), \"Insufficient funds\");\n        tokenToRedeem[msg.sender] = _value;\n    }\n\n    /**\n     * @notice Used to redeem tokens by the module\n     * @param _value The number of tokens to redeem\n     */\n    function redeemTokenByOwner(uint256 _value) public {\n        require(tokenToRedeem[msg.sender] >= _value, \"Insufficient tokens redeemable\");\n        tokenToRedeem[msg.sender] = tokenToRedeem[msg.sender].sub(_value);\n        redeemedTokens[msg.sender] = redeemedTokens[msg.sender].add(_value);\n        ISecurityToken(securityToken).burnWithData(_value, \"\");\n        /*solium-disable-next-line security/no-block-members*/\n        emit RedeemedTokenByOwner(msg.sender, address(this), _value, now);\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Experimental/Burn/TrackedRedemption.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../../Burn/IBurn.sol\";\nimport \"../../Module.sol\";\nimport \"../../../interfaces/ISecurityToken.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title Burn module for burning tokens and keeping track of burnt amounts\n */\ncontract TrackedRedemption is IBurn, Module {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) redeemedTokens;\n\n    event Redeemed(address _investor, uint256 _value, uint256 _timestamp);\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress) public\n    Module(_securityToken, _polyAddress)\n    {\n    }\n\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() public  returns (bytes4) {\n        return bytes4(0);\n    }\n\n    /**\n     * @notice To redeem tokens and track redemptions\n     * @param _value The number of tokens to redeem\n     */\n    function redeemTokens(uint256 _value) public {\n        ISecurityToken(securityToken).burnFromWithData(msg.sender, _value, \"\");\n        redeemedTokens[msg.sender] = redeemedTokens[msg.sender].add(_value);\n        /*solium-disable-next-line security/no-block-members*/\n        emit Redeemed(msg.sender, _value, now);\n    }\n\n    /**\n     * @notice Returns the permissions flag that are associated with CountTransferManager\n     */\n    function getPermissions() public  returns(bytes32[]) {\n        bytes32[] memory allPermissions = new bytes32[](0);\n        return allPermissions;\n    }\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Burn/IBurn.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Interface to be implemented by all checkpoint modules\n */\n/*solium-disable-next-line no-empty-blocks*/\ninterface IBurn {event __CoverageIBurn(string fileName, uint256 lineNumber);\nevent __FunctionCoverageIBurn(string fileName, uint256 fnId);\nevent __StatementCoverageIBurn(string fileName, uint256 statementId);\nevent __BranchCoverageIBurn(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageIBurn(string fileName, uint256 branchId);\nevent __AssertPostCoverageIBurn(string fileName, uint256 branchId);\n\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Experimental/Burn/TrackedRedemptionFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./TrackedRedemption.sol\";\nimport \"../../ModuleFactory.sol\";\n\n/**\n * @title Factory for deploying GeneralTransferManager module\n */\ncontract TrackedRedemptionFactory is ModuleFactory {\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     * @param _setupCost Setup cost of module\n     * @param _usageCost Usage cost of module\n     * @param _subscriptionCost Monthly cost of module\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {\n        version = \"1.0.0\";\n        name = \"TrackedRedemption\";\n        title = \"Tracked Redemption\";\n        description = \"Track token redemptions\";\n        compatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n        compatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n    }\n\n    /**\n     * @notice Used to launch the Module with the help of factory\n     * @return Address Contract address of the Module\n     */\n    function deploy(bytes /* _data */) external returns(address) {\n        if (setupCost > 0)\n            {require(polyToken.transferFrom(msg.sender, owner, setupCost), \"Insufficent allowance or balance\");}\n        address trackedRedemption = new TrackedRedemption(msg.sender, address(polyToken));\n        /*solium-disable-next-line security/no-block-members*/\n        emit GenerateModuleFromFactory(address(trackedRedemption), getName(), address(this), msg.sender, setupCost, now);\n        return address(trackedRedemption);\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {\n        uint8[] memory res = new uint8[](1);\n        res[0] = 5;\n        return res;\n    }\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {\n        return \"Allows an investor to redeem security tokens which are tracked by this module\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {\n        bytes32[] memory availableTags = new bytes32[](2);\n        availableTags[0] = \"Redemption\";\n        availableTags[1] = \"Tracked\";\n        return availableTags;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/mocks/MockOracle.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../interfaces/IOracle.sol\";\n\ncontract MockOracle is IOracle {\n\n    address public currency;\n    bytes32 public currencySymbol;\n    bytes32 public denominatedCurrency;\n    uint256 public price;\n\n    constructor(address _currency, bytes32 _currencySymbol, bytes32 _denominatedCurrency, uint256 _price) public {\n        currency = _currency;\n        currencySymbol = _currencySymbol;\n        denominatedCurrency = _denominatedCurrency;\n        price = _price;\n    }\n\n    function changePrice(uint256 _price) external {\n        price = _price;\n    }\n\n    /**\n    * @notice Returns address of oracle currency (0x0 for ETH)\n    */\n    function getCurrencyAddress() external  returns(address) {\n        return currency;\n    }\n\n    /**\n    * @notice Returns symbol of oracle currency (0x0 for ETH)\n    */\n    function getCurrencySymbol() external  returns(bytes32) {\n        return currencySymbol;\n    }\n\n    /**\n    * @notice Returns denomination of price\n    */\n    function getCurrencyDenominated() external  returns(bytes32) {\n        return denominatedCurrency;\n    }\n\n    /**\n    * @notice Returns price - should throw if not valid\n    */\n    function getPrice() external  returns(uint256) {\n        return price;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/mocks/PolyTokenFaucet.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/*\n POLY token faucet is only used on testnet for testing purposes\n !!!! NOT INTENDED TO BE USED ON MAINNET !!!\n*/\n\ncontract PolyTokenFaucet {\n\n    using SafeMath for uint256;\n    uint256 totalSupply_;\n    string public name = \"Polymath Network\";\n    uint8 public decimals;\n    string public symbol = \"POLY\";\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() public {\n        decimals = 18;\n        totalSupply_ = 1000000 * uint256(10)**decimals;\n        balances[msg.sender] = totalSupply_;\n        emit Transfer(address(0), msg.sender, totalSupply_);\n    }\n\n    /* Token faucet - Not part of the ERC20 standard */\n    function getTokens(uint256 _amount, address _recipient) public returns (bool) {\n        require(_amount <= 1000000 * uint256(10)**decimals, \"Amount should not exceed 1 million\");\n        require(_recipient != address(0), \"Recipient address can not be empty\");\n        balances[_recipient] = balances[_recipient].add(_amount);\n        totalSupply_ = totalSupply_.add(_amount);\n        emit Transfer(address(0), _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Sends `_value` tokens to `_to` from `msg.sender`\n     * @param _to The address of the recipient\n     * @param _value The amount of token to be transferred\n     * @return Whether the transfer was successful or not\n     */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * @notice sends `_value` tokens to `_to` from `_from` with the condition it is approved by `_from`\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value The amount of token to be transferred\n     * @return Whether the transfer was successful or not\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0), \"Invalid address\");\n        require(_value <= balances[_from], \"Insufficient tokens transferable\");\n        require(_value <= allowed[_from][msg.sender], \"Insufficient tokens allowable\");\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * @notice Returns the balance of a token holder\n     * @param _owner The address from which the balance will be retrieved\n     * @return The balance\n     */\n    function balanceOf(address _owner) public  returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    /**\n     * @notice Used by `msg.sender` to approve `_spender` to spend `_value` tokens\n     * @param _spender The address of the account able to transfer the tokens\n     * @param _value The amount of tokens to be approved for transfer\n     * @return Whether the approval was successful or not\n     */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @param _owner The address of the account owning tokens\n     * @param _spender The address of the account able to transfer the tokens\n     * @return Amount of remaining tokens allowed to be spent\n     */\n    function allowance(address _owner, address _spender) public  returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function totalSupply() public  returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n     * @dev Increases the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value, it is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseApproval(\n        address _spender,\n        uint _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n        allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    *\n    * approve should be called when allowed[_spender] == 0. To decrement\n    * allowed value, it is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n    */\n    function decreaseApproval(\n        address _spender,\n        uint _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/proxy/ModuleRegistryProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../storage/EternalStorage.sol\";\nimport \"./OwnedUpgradeabilityProxy.sol\";\n\n\n/**\n * @title ModuleRegistryProxy\n * @dev This proxy holds the storage of the ModuleRegistry contract and delegates every call to the current implementation set.\n * Besides, it allows upgrading the contract's behaviour towards further implementations, and provides basic\n * authorization control functionalities\n */\n/*solium-disable-next-line no-empty-blocks*/\ncontract ModuleRegistryProxy is EternalStorage, OwnedUpgradeabilityProxy {event __CoverageModuleRegistryProxy(string fileName, uint256 lineNumber);\nevent __FunctionCoverageModuleRegistryProxy(string fileName, uint256 fnId);\nevent __StatementCoverageModuleRegistryProxy(string fileName, uint256 statementId);\nevent __BranchCoverageModuleRegistryProxy(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageModuleRegistryProxy(string fileName, uint256 branchId);\nevent __AssertPostCoverageModuleRegistryProxy(string fileName, uint256 branchId);\n\n\n}"},"/home/max/Desktop/Ethereum/polymath-core/contracts/proxy/OwnedUpgradeabilityProxy.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./UpgradeabilityProxy.sol\";\n\n/**\n * @title OwnedUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n */\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {event __CoverageOwnedUpgradeabilityProxy(string fileName, uint256 lineNumber);\nevent __FunctionCoverageOwnedUpgradeabilityProxy(string fileName, uint256 fnId);\nevent __StatementCoverageOwnedUpgradeabilityProxy(string fileName, uint256 statementId);\nevent __BranchCoverageOwnedUpgradeabilityProxy(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageOwnedUpgradeabilityProxy(string fileName, uint256 branchId);\nevent __AssertPostCoverageOwnedUpgradeabilityProxy(string fileName, uint256 branchId);\n\n\n    // Owner of the contract\n    address private __upgradeabilityOwner;\n\n    /**\n    * @dev Event to show ownership has been transferred\n    * @param _previousOwner representing the address of the previous owner\n    * @param _newOwner representing the address of the new owner\n    */\n    event ProxyOwnershipTransferred(address _previousOwner, address _newOwner);\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier ifOwner() {emit __FunctionCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',1);\n\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',25);\n        emit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',1);\nif (msg.sender == _upgradeabilityOwner()) {emit __BranchCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',1,0);\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',26);\n            _;\n        } else {emit __BranchCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',1,1);\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',28);\n            emit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',2);\n_fallback();\n        }\n    }\n\n    /**\n    * @dev the constructor sets the original owner of the contract to the sender account.\n    */\n    constructor() public {emit __FunctionCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',2);\n\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',36);\n        emit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',3);\n_setUpgradeabilityOwner(msg.sender);\n    }\n\n    /**\n    * @dev Tells the address of the owner\n    * @return the address of the owner\n    */\n    function _upgradeabilityOwner() internal  returns (address) {emit __FunctionCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',3);\n\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',44);\n        emit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',4);\nreturn __upgradeabilityOwner;\n    }\n\n    /**\n    * @dev Sets the address of the owner\n    */\n    function _setUpgradeabilityOwner(address _newUpgradeabilityOwner) internal {emit __FunctionCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',4);\n\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',51);\n        emit __AssertPreCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',2);\nemit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',5);\nrequire(_newUpgradeabilityOwner != address(0), \"Address should not be 0x\");emit __AssertPostCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',2);\n\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',52);\n        emit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',6);\n__upgradeabilityOwner = _newUpgradeabilityOwner;\n    }\n\n    /**\n    * @notice Internal function to provide the address of the implementation contract\n    */\n    function _implementation() internal  returns (address) {emit __FunctionCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',5);\n\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',59);\n        emit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',7);\nreturn __implementation;\n    }\n\n    /**\n    * @dev Tells the address of the proxy owner\n    * @return the address of the proxy owner\n    */\n    function proxyOwner() external ifOwner returns (address) {emit __FunctionCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',6);\n\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',67);\n        emit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',8);\nreturn _upgradeabilityOwner();\n    }\n\n    /**\n    * @dev Tells the version name of the current implementation\n    * @return string representing the name of the current version\n    */\n    function version() external ifOwner returns (string) {emit __FunctionCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',7);\n\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',75);\n        emit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',9);\nreturn __version;\n    }\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() external ifOwner returns (address) {emit __FunctionCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',8);\n\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',83);\n        emit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',10);\nreturn _implementation();\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferProxyOwnership(address _newOwner) external ifOwner {emit __FunctionCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',9);\n\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',91);\n        emit __AssertPreCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',3);\nemit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',11);\nrequire(_newOwner != address(0), \"Address should not be 0x\");emit __AssertPostCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',3);\n\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',92);\n        emit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',12);\nemit ProxyOwnershipTransferred(_upgradeabilityOwner(), _newOwner);\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',93);\n        emit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',13);\n_setUpgradeabilityOwner(_newOwner);\n    }\n\n    /**\n    * @dev Allows the upgradeability owner to upgrade the current version of the proxy.\n    * @param _newVersion representing the version name of the new implementation to be set.\n    * @param _newImplementation representing the address of the new implementation to be set.\n    */\n    function upgradeTo(string _newVersion, address _newImplementation) external ifOwner {emit __FunctionCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',10);\n\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',102);\n        emit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',14);\n_upgradeTo(_newVersion, _newImplementation);\n    }\n\n    /**\n    * @dev Allows the upgradeability owner to upgrade the current version of the proxy and call the new implementation\n    * to initialize whatever is needed through a low level call.\n    * @param _newVersion representing the version name of the new implementation to be set.\n    * @param _newImplementation representing the address of the new implementation to be set.\n    * @param _data represents the msg.data to bet sent in the low level call. This parameter may include the function\n    * signature of the implementation to be called with the needed payload\n    */\n    function upgradeToAndCall(string _newVersion, address _newImplementation, bytes _data) external payable ifOwner {emit __FunctionCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',11);\n\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',114);\n        emit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',15);\n_upgradeTo(_newVersion, _newImplementation);\n        /*solium-disable-next-line security/no-call-value*/\nemit __CoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',116);\n        emit __AssertPreCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',4);\nemit __StatementCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',16);\nrequire(address(this).call.value(msg.value)(_data), \"Fail in executing the function of implementation contract\");emit __AssertPostCoverageOwnedUpgradeabilityProxy('./contracts/proxy/OwnedUpgradeabilityProxy.sol',4);\n\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/proxy/UpgradeabilityProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./Proxy.sol\";\nimport \"openzeppelin-solidity/contracts/AddressUtils.sol\";\n\n/**\n * @title UpgradeabilityProxy\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n */\ncontract UpgradeabilityProxy is Proxy {event __CoverageUpgradeabilityProxy(string fileName, uint256 lineNumber);\nevent __FunctionCoverageUpgradeabilityProxy(string fileName, uint256 fnId);\nevent __StatementCoverageUpgradeabilityProxy(string fileName, uint256 statementId);\nevent __BranchCoverageUpgradeabilityProxy(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageUpgradeabilityProxy(string fileName, uint256 branchId);\nevent __AssertPostCoverageUpgradeabilityProxy(string fileName, uint256 branchId);\n\n\n    // Version name of the current implementation\n    string internal __version;\n\n    // Address of the current implementation\n    address internal __implementation;\n\n    /**\n    * @dev This event will be emitted every time the implementation gets upgraded\n    * @param _newVersion representing the version name of the upgraded implementation\n    * @param _newImplementation representing the address of the upgraded implementation\n    */\n    event Upgraded(string _newVersion, address indexed _newImplementation);\n\n    /**\n    * @dev Upgrades the implementation address\n    * @param _newVersion representing the version name of the new implementation to be set\n    * @param _newImplementation representing the address of the new implementation to be set\n    */\n    function _upgradeTo(string _newVersion, address _newImplementation) internal {emit __FunctionCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',1);\n\nemit __CoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',31);\n        emit __AssertPreCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',1);\nemit __StatementCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',1);\nrequire(\n            __implementation != _newImplementation && _newImplementation != address(0),\n            \"Old address is not allowed and implementation address should not be 0x\"\n        );emit __AssertPostCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',1);\n\nemit __CoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',35);\n        emit __AssertPreCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',2);\nemit __StatementCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',2);\nrequire(AddressUtils.isContract(_newImplementation), \"Cannot set a proxy implementation to a non-contract address\");emit __AssertPostCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',2);\n\nemit __CoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',36);\n        emit __AssertPreCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',3);\nemit __StatementCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',3);\nrequire(bytes(_newVersion).length > 0, \"Version should not be empty string\");emit __AssertPostCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',3);\n\nemit __CoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',37);\n        emit __AssertPreCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',4);\nemit __StatementCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',4);\nrequire(keccak256(abi.encodePacked(__version)) != keccak256(abi.encodePacked(_newVersion)), \"New version equals to current\");emit __AssertPostCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',4);\n\nemit __CoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',38);\n        emit __StatementCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',5);\n__version = _newVersion;\nemit __CoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',39);\n        emit __StatementCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',6);\n__implementation = _newImplementation;\nemit __CoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',40);\n        emit __StatementCoverageUpgradeabilityProxy('./contracts/proxy/UpgradeabilityProxy.sol',7);\nemit Upgraded(_newVersion, _newImplementation);\n    }\n\n}"},"openzeppelin-solidity/contracts/AddressUtils.sol":{"content":"pragma solidity ^0.4.23;\n\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary AddressUtils {\n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   *  as the code is not actually created until after the constructor finishes.\n   * @param addr address to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address addr) internal view returns (bool) {\n    uint256 size;\n    // XXX Currently there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address.\n    // See https://ethereum.stackexchange.com/a/14016/36603\n    // for more details about how this works.\n    // TODO Check this again before the Serenity release, because all addresses will be\n    // contracts then.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly { size := extcodesize(addr) }\n    return size > 0;\n  }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/proxy/SecurityTokenRegistryProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../storage/EternalStorage.sol\";\nimport \"./OwnedUpgradeabilityProxy.sol\";\n\n\n/**\n * @title SecurityTokenRegistryProxy\n * @dev This proxy holds the storage of the SecurityTokenRegistry contract and delegates every call to the current implementation set.\n * Besides, it allows to upgrade the SecurityTokenRegistry's behaviour towards further implementations, and provides basic\n * authorization control functionalities\n */\n/*solium-disable-next-line no-empty-blocks*/\ncontract SecurityTokenRegistryProxy is EternalStorage, OwnedUpgradeabilityProxy {event __CoverageSecurityTokenRegistryProxy(string fileName, uint256 lineNumber);\nevent __FunctionCoverageSecurityTokenRegistryProxy(string fileName, uint256 fnId);\nevent __StatementCoverageSecurityTokenRegistryProxy(string fileName, uint256 statementId);\nevent __BranchCoverageSecurityTokenRegistryProxy(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageSecurityTokenRegistryProxy(string fileName, uint256 branchId);\nevent __AssertPostCoverageSecurityTokenRegistryProxy(string fileName, uint256 branchId);\n\n\n}"},"/home/max/Desktop/Ethereum/polymath-core/contracts/helpers/PolyToken.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"../interfaces/IERC20.sol\";\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal  returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal  returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal  returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal  returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract PolyToken is IERC20 {\n    using SafeMath for uint256;\n\n    // Poly Token parameters\n    string public name = \"Polymath\";\n    string public symbol = \"POLY\";\n    uint8 public constant decimals = 18;\n    uint256 public constant decimalFactor = 10 ** uint256(decimals);\n    uint256 public constant totalSupply = 1000000000 * decimalFactor;\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n    * @dev Constructor for Poly creation\n    * @dev Assigns the totalSupply to the PolyDistribution contract\n    */\n    constructor (address _polyDistributionContractAddress) public {\n        require(_polyDistributionContractAddress != address(0), \"Invalid address\");\n        balances[_polyDistributionContractAddress] = totalSupply;\n        emit Transfer(address(0), _polyDistributionContractAddress, totalSupply);\n    }\n\n    /**\n    * @dev Returns the balance of the specified address\n    * @param _owner The address to query the the balance of\n    * @return An uint256 representing the amount owned by the passed address\n    */\n    function balanceOf(address _owner) public  returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    /**\n    * @dev Function to check the amount of tokens a spender is allowed to spend\n    * @param _owner address The address which owns the tokens\n    * @param _spender address The address which will spend the tokens\n    * @return A uint256 specifying the amount of tokens left available for the spender\n    */\n    function allowance(address _owner, address _spender) public  returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Transfer token to a specified address\n    * @param _to The address to transfer tokens to\n    * @param _value The amount to be transferred\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0), \"Invalid address\");\n        require(_value <= balances[msg.sender], \"Insufficient tokens transferable\");\n\n        // SafeMath.sub will throw if the balance is not enough\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Transfers tokens from one address to another\n    * @param _from address The address to transfer tokens from\n    * @param _to address The address to transfer tokens to\n    * @param _value uint256 The amount of tokens to be transferred\n    */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0), \"Invalid address\");\n        require(_value <= balances[_from], \"Insufficient tokens transferable\");\n        require(_value <= allowed[_from][msg.sender], \"Insufficient tokens allowable\");\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Approves the passed address to spend the specified amount of tokens on behalf of msg.sender\n    *\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to reduce the spender's allowance to 0 first and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds\n    * @param _value The amount of tokens to be spent\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev Increases the amount of tokens that an owner has allowed a spender to spend\n    *\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value, it is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Decreases the amount of tokens that an owner has allowed a spender to spend\n    *\n    * approve should be called when allowed[_spender] == 0. To decrement\n    * allowed value, it is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds\n    * @param _subtractedValue The amount of tokens to decrease the allowance by\n    */\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/interfaces/IUSDTieredSTOProxy.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title Interface for security token proxy deployment\n */\ninterface IUSDTieredSTOProxy {event __CoverageIUSDTieredSTOProxy(string fileName, uint256 lineNumber);\nevent __FunctionCoverageIUSDTieredSTOProxy(string fileName, uint256 fnId);\nevent __StatementCoverageIUSDTieredSTOProxy(string fileName, uint256 statementId);\nevent __BranchCoverageIUSDTieredSTOProxy(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageIUSDTieredSTOProxy(string fileName, uint256 branchId);\nevent __AssertPostCoverageIUSDTieredSTOProxy(string fileName, uint256 branchId);\n\n\n   /**\n     * @notice Deploys the STO.\n     * @param _securityToken Contract address of the securityToken\n     * @param _polyAddress Contract address of the PolyToken\n     * @param _factoryAddress Contract address of the factory \n     * @return address Address of the deployed STO\n     */\n    function deploySTO(address _securityToken, address _polyAddress, address _factoryAddress) external returns (address);\n    \n     /**\n     * @notice Used to get the init function signature\n     * @param _contractAddress Address of the STO contract\n     * @return bytes4\n     */\n    function getInitFunction(address _contractAddress) external returns (bytes4);\n\n}"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Checkpoint/DividendCheckpoint.sol":{"content":"/**\r\n * DISCLAIMER: Under certain conditions, the function pushDividendPayment\r\n * may fail due to block gas limits.\r\n * If the total number of investors that ever held tokens is greater than ~15,000 then\r\n * the function may fail. If this happens investors can pull their dividends, or the Issuer\r\n * can use pushDividendPaymentToAddresses to provide an explict address list in batches\r\n */\r\npragma solidity ^0.4.24;\r\n\r\nimport \"./ICheckpoint.sol\";\r\nimport \"./DividendCheckpointStorage.sol\";\r\nimport \"../Module.sol\";\r\nimport \"../../interfaces/ISecurityToken.sol\";\r\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\r\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\r\n\r\n/**\r\n * @title Checkpoint module for issuing ether dividends\r\n * @dev abstract contract\r\n */\r\ncontract DividendCheckpoint is DividendCheckpointStorage, ICheckpoint, Module {event __CoverageDividendCheckpoint(string fileName, uint256 lineNumber);\nevent __FunctionCoverageDividendCheckpoint(string fileName, uint256 fnId);\nevent __StatementCoverageDividendCheckpoint(string fileName, uint256 statementId);\nevent __BranchCoverageDividendCheckpoint(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageDividendCheckpoint(string fileName, uint256 branchId);\nevent __AssertPostCoverageDividendCheckpoint(string fileName, uint256 branchId);\n\r\n    using SafeMath for uint256;\r\n\r\n    event SetDefaultExcludedAddresses(address[] _excluded, uint256 _timestamp);\r\n    event SetWithholding(address[] _investors, uint256[] _withholding, uint256 _timestamp);\r\n    event SetWithholdingFixed(address[] _investors, uint256 _withholding, uint256 _timestamp);\r\n\r\n    modifier validDividendIndex(uint256 _dividendIndex) {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',1);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',29);\n        emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',1);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',1);\nrequire(_dividendIndex < dividends.length, \"Invalid dividend\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',1);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',30);\n        emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',2);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',2);\nrequire(!dividends[_dividendIndex].reclaimed, \"Dividend reclaimed\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',2);\n\r\n        /*solium-disable-next-line security/no-block-members*/\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',32);\n        emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',3);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',3);\nrequire(now >= dividends[_dividendIndex].maturity, \"Dividend maturity in future\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',3);\n\r\n        /*solium-disable-next-line security/no-block-members*/\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',34);\n        emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',4);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',4);\nrequire(now < dividends[_dividendIndex].expiry, \"Dividend expiry in past\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',4);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',35);\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Init function i.e generalise function to maintain the structure of the module contract\r\n    * @return bytes4\r\n    */\r\n    function getInitFunction() public  returns (bytes4) {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',2);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',43);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',5);\nreturn bytes4(0);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the default excluded addresses\r\n     * @return List of excluded addresses\r\n     */\r\n    function getDefaultExcluded() external  returns (address[]) {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',3);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',51);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',6);\nreturn excluded;\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a checkpoint on the security token\r\n     * @return Checkpoint ID\r\n     */\r\n    function createCheckpoint() public withPerm(CHECKPOINT) returns (uint256) {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',4);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',59);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',7);\nreturn ISecurityToken(securityToken).createCheckpoint();\r\n    }\r\n\r\n    /**\r\n     * @notice Function to clear and set list of excluded addresses used for future dividends\r\n     * @param _excluded Addresses of investors\r\n     */\r\n    function setDefaultExcluded(address[] _excluded) public withPerm(MANAGE) {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',5);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',67);\n        emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',5);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',8);\nrequire(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, \"Too many excluded addresses\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',5);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',68);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',9);\nfor (uint256 j = 0; j < _excluded.length; j++) {\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',69);\n            emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',6);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',10);\nrequire (_excluded[j] != address(0), \"Invalid address\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',6);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',70);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',11);\nfor (uint256 i = j + 1; i < _excluded.length; i++) {\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',71);\n                emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',7);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',12);\nrequire (_excluded[j] != _excluded[i], \"Duplicate exclude address\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',7);\n\r\n            }\r\n        }\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',74);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',13);\nexcluded = _excluded;\r\n        /*solium-disable-next-line security/no-block-members*/\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',76);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',14);\nemit SetDefaultExcludedAddresses(excluded, now);\r\n    }\r\n\r\n    /**\r\n     * @notice Function to set withholding tax rates for investors\r\n     * @param _investors Addresses of investors\r\n     * @param _withholding Withholding tax for individual investors (multiplied by 10**16)\r\n     */\r\n    function setWithholding(address[] _investors, uint256[] _withholding) public withPerm(MANAGE) {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',6);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',85);\n        emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',8);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',15);\nrequire(_investors.length == _withholding.length, \"Mismatched input lengths\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',8);\n\r\n        /*solium-disable-next-line security/no-block-members*/\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',87);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',16);\nemit SetWithholding(_investors, _withholding, now);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',88);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',17);\nfor (uint256 i = 0; i < _investors.length; i++) {\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',89);\n            emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',9);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',18);\nrequire(_withholding[i] <= 10**18, \"Incorrect withholding tax\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',9);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',90);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',19);\nwithholdingTax[_investors[i]] = _withholding[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Function to set withholding tax rates for investors\r\n     * @param _investors Addresses of investor\r\n     * @param _withholding Withholding tax for all investors (multiplied by 10**16)\r\n     */\r\n    function setWithholdingFixed(address[] _investors, uint256 _withholding) public withPerm(MANAGE) {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',7);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',100);\n        emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',10);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',20);\nrequire(_withholding <= 10**18, \"Incorrect withholding tax\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',10);\n\r\n        /*solium-disable-next-line security/no-block-members*/\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',102);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',21);\nemit SetWithholdingFixed(_investors, _withholding, now);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',103);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',22);\nfor (uint256 i = 0; i < _investors.length; i++) {\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',104);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',23);\nwithholdingTax[_investors[i]] = _withholding;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Issuer can push dividends to provided addresses\r\n     * @param _dividendIndex Dividend to push\r\n     * @param _payees Addresses to which to push the dividend\r\n     */\r\n    function pushDividendPaymentToAddresses(\r\n        uint256 _dividendIndex,\r\n        address[] _payees\r\n    )\r\n        public\r\n        withPerm(DISTRIBUTE)\r\n        validDividendIndex(_dividendIndex)\r\n    {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',8);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',121);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',24);\nDividend storage dividend = dividends[_dividendIndex];\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',122);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',25);\nfor (uint256 i = 0; i < _payees.length; i++) {\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',123);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',26);\nif ((!dividend.claimed[_payees[i]]) && (!dividend.dividendExcluded[_payees[i]])) {emit __BranchCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',11,0);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',124);\n                emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',27);\n_payDividend(_payees[i], dividend, _dividendIndex);\r\n            }else { emit __BranchCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',11,1);}\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Issuer can push dividends using the investor list from the security token\r\n     * @param _dividendIndex Dividend to push\r\n     * @param _start Index in investor list at which to start pushing dividends\r\n     * @param _iterations Number of addresses to push dividends for\r\n     */\r\n    function pushDividendPayment(\r\n        uint256 _dividendIndex,\r\n        uint256 _start,\r\n        uint256 _iterations\r\n    )\r\n        public\r\n        withPerm(DISTRIBUTE)\r\n        validDividendIndex(_dividendIndex)\r\n    {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',9);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',144);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',28);\nDividend storage dividend = dividends[_dividendIndex];\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',145);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',29);\nuint256 checkpointId = dividend.checkpointId;\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',146);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',30);\naddress[] memory investors = ISecurityToken(securityToken).getInvestorsAt(checkpointId);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',147);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',31);\nuint256 numberInvestors = Math.min256(investors.length, _start.add(_iterations));\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',148);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',32);\nfor (uint256 i = _start; i < numberInvestors; i++) {\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',149);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',33);\naddress payee = investors[i];\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',150);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',34);\nif ((!dividend.claimed[payee]) && (!dividend.dividendExcluded[payee])) {emit __BranchCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',12,0);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',151);\n                emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',35);\n_payDividend(payee, dividend, _dividendIndex);\r\n            }else { emit __BranchCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',12,1);}\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Investors can pull their own dividends\r\n     * @param _dividendIndex Dividend to pull\r\n     */\r\n    function pullDividendPayment(uint256 _dividendIndex) public validDividendIndex(_dividendIndex)\r\n    {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',10);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',162);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',36);\nDividend storage dividend = dividends[_dividendIndex];\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',163);\n        emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',13);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',37);\nrequire(!dividend.claimed[msg.sender], \"Dividend already claimed\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',13);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',164);\n        emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',14);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',38);\nrequire(!dividend.dividendExcluded[msg.sender], \"msg.sender excluded from Dividend\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',14);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',165);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',39);\n_payDividend(msg.sender, dividend, _dividendIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function for paying dividends\r\n     * @param _payee Address of investor\r\n     * @param _dividend Storage with previously issued dividends\r\n     * @param _dividendIndex Dividend to pay\r\n     */\r\n    function _payDividend(address _payee, Dividend storage _dividend, uint256 _dividendIndex) internal;\r\n\r\n    /**\r\n     * @notice Issuer can reclaim remaining unclaimed dividend amounts, for expired dividends\r\n     * @param _dividendIndex Dividend to reclaim\r\n     */\r\n    function reclaimDividend(uint256 _dividendIndex) external;\r\n\r\n    /**\r\n     * @notice Calculate amount of dividends claimable\r\n     * @param _dividendIndex Dividend to calculate\r\n     * @param _payee Affected investor address\r\n     * @return claim, withheld amounts\r\n     */\r\n    function calculateDividend(uint256 _dividendIndex, address _payee) public  returns(uint256, uint256) {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',11);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',189);\n        emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',15);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',40);\nrequire(_dividendIndex < dividends.length, \"Invalid dividend\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',15);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',190);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',41);\nDividend storage dividend = dividends[_dividendIndex];\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',191);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',42);\nif (dividend.claimed[_payee] || dividend.dividendExcluded[_payee]) {emit __BranchCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',16,0);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',192);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',43);\nreturn (0, 0);\r\n        }else { emit __BranchCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',16,1);}\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',194);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',44);\nuint256 balance = ISecurityToken(securityToken).balanceOfAt(_payee, dividend.checkpointId);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',195);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',45);\nuint256 claim = balance.mul(dividend.amount).div(dividend.totalSupply);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',196);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',46);\nuint256 withheld = claim.mul(withholdingTax[_payee]).div(uint256(10**18));\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',197);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',47);\nreturn (claim, withheld);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the index according to the checkpoint id\r\n     * @param _checkpointId Checkpoint id to query\r\n     * @return uint256[]\r\n     */\r\n    function getDividendIndex(uint256 _checkpointId) public  returns(uint256[]) {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',12);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',206);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',48);\nuint256 counter = 0;\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',207);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',49);\nfor(uint256 i = 0; i < dividends.length; i++) {\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',208);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',50);\nif (dividends[i].checkpointId == _checkpointId) {emit __BranchCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',17,0);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',209);\n                counter++;\r\n            }else { emit __BranchCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',17,1);}\n\r\n        }\r\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',213);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',51);\nuint256[] memory index = new uint256[](counter);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',214);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',52);\ncounter = 0;\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',215);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',53);\nfor(uint256 j = 0; j < dividends.length; j++) {\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',216);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',54);\nif (dividends[j].checkpointId == _checkpointId) {emit __BranchCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',18,0);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',217);\n                emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',55);\nindex[counter] = j;\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',218);\n                counter++;\r\n            }else { emit __BranchCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',18,1);}\n\r\n        }\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',221);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',56);\nreturn index;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows issuer to withdraw withheld tax\r\n     * @param _dividendIndex Dividend to withdraw from\r\n     */\r\n    function withdrawWithholding(uint256 _dividendIndex) external;\r\n\r\n    /**\r\n     * @notice Get static dividend data\r\n     * @return uint256[] timestamp of dividends creation\r\n     * @return uint256[] timestamp of dividends maturity\r\n     * @return uint256[] timestamp of dividends expiry\r\n     * @return uint256[] amount of dividends\r\n     * @return uint256[] claimed amount of dividends\r\n     * @return bytes32[] name of dividends\r\n     */\r\n    function getDividendsData() external  returns (\r\n        uint256[] memory createds,\r\n        uint256[] memory maturitys,\r\n        uint256[] memory expirys,\r\n        uint256[] memory amounts,\r\n        uint256[] memory claimedAmounts,\r\n        bytes32[] memory names)\r\n    {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',13);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',247);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',57);\ncreateds = new uint256[](dividends.length);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',248);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',58);\nmaturitys = new uint256[](dividends.length);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',249);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',59);\nexpirys = new uint256[](dividends.length);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',250);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',60);\namounts = new uint256[](dividends.length);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',251);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',61);\nclaimedAmounts = new uint256[](dividends.length);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',252);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',62);\nnames = new bytes32[](dividends.length);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',253);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',63);\nfor (uint256 i = 0; i < dividends.length; i++) {\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',254);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',64);\n(createds[i], maturitys[i], expirys[i], amounts[i], claimedAmounts[i], names[i]) = getDividendData(i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get static dividend data\r\n     * @return uint256 timestamp of dividend creation\r\n     * @return uint256 timestamp of dividend maturity\r\n     * @return uint256 timestamp of dividend expiry\r\n     * @return uint256 amount of dividend\r\n     * @return uint256 claimed amount of dividend\r\n     * @return bytes32 name of dividend\r\n     */\r\n    function getDividendData(uint256 _dividendIndex) public  returns (\r\n        uint256 created,\r\n        uint256 maturity,\r\n        uint256 expiry,\r\n        uint256 amount,\r\n        uint256 claimedAmount,\r\n        bytes32 name)\r\n    {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',14);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',275);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',65);\ncreated = dividends[_dividendIndex].created;\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',276);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',66);\nmaturity = dividends[_dividendIndex].maturity;\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',277);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',67);\nexpiry = dividends[_dividendIndex].expiry;\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',278);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',68);\namount = dividends[_dividendIndex].amount;\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',279);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',69);\nclaimedAmount = dividends[_dividendIndex].claimedAmount;\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',280);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',70);\nname = dividends[_dividendIndex].name;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves list of investors, their claim status and whether they are excluded\r\n     * @param _dividendIndex Dividend to withdraw from\r\n     * @return address[] list of investors\r\n     * @return bool[] whether investor has claimed\r\n     * @return bool[] whether investor is excluded\r\n     * @return uint256[] amount of withheld tax\r\n     * @return uint256[] investor balance\r\n     * @return uint256[] amount to be claimed including withheld tax\r\n     */\r\n    function getDividendProgress(uint256 _dividendIndex) external  returns (\r\n        address[] memory investors,\r\n        bool[] memory resultClaimed,\r\n        bool[] memory resultExcluded,\r\n        uint256[] memory resultWithheld,\r\n        uint256[] memory resultBalance,\r\n        uint256[] memory resultAmount)\r\n    {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',15);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',301);\n        emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',19);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',71);\nrequire(_dividendIndex < dividends.length, \"Invalid dividend\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',19);\n\r\n        //Get list of Investors\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',303);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',72);\nDividend storage dividend = dividends[_dividendIndex];\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',304);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',73);\nuint256 checkpointId = dividend.checkpointId;\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',305);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',74);\ninvestors = ISecurityToken(securityToken).getInvestorsAt(checkpointId);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',306);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',75);\nresultClaimed = new bool[](investors.length);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',307);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',76);\nresultExcluded = new bool[](investors.length);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',308);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',77);\nresultWithheld = new uint256[](investors.length);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',309);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',78);\nresultBalance = new uint256[](investors.length);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',310);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',79);\nresultAmount = new uint256[](investors.length);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',311);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',80);\nfor (uint256 i; i < investors.length; i++) {\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',312);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',81);\nresultClaimed[i] = dividend.claimed[investors[i]];\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',313);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',82);\nresultExcluded[i] = dividend.dividendExcluded[investors[i]];\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',314);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',83);\nresultBalance[i] = ISecurityToken(securityToken).balanceOfAt(investors[i], dividend.checkpointId);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',315);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',84);\nif (!resultExcluded[i]) {emit __BranchCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',20,0);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',316);\n                emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',85);\nresultWithheld[i] = dividend.withheld[investors[i]];\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',317);\n                emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',86);\nresultAmount[i] = resultBalance[i].mul(dividend.amount).div(dividend.totalSupply);\r\n            }else { emit __BranchCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',20,1);}\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves list of investors, their balances, and their current withholding tax percentage\r\n     * @param _checkpointId Checkpoint Id to query for\r\n     * @return address[] list of investors\r\n     * @return uint256[] investor balances\r\n     * @return uint256[] investor withheld percentages\r\n     */\r\n    function getCheckpointData(uint256 _checkpointId) external  returns (address[] memory investors, uint256[] memory balances, uint256[] memory withholdings) {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',16);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',330);\n        emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',21);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',87);\nrequire(_checkpointId <= ISecurityToken(securityToken).currentCheckpointId(), \"Invalid checkpoint\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',21);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',331);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',88);\ninvestors = ISecurityToken(securityToken).getInvestorsAt(_checkpointId);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',332);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',89);\nbalances = new uint256[](investors.length);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',333);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',90);\nwithholdings = new uint256[](investors.length);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',334);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',91);\nfor (uint256 i; i < investors.length; i++) {\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',335);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',92);\nbalances[i] = ISecurityToken(securityToken).balanceOfAt(investors[i], _checkpointId);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',336);\n            emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',93);\nwithholdings[i] = withholdingTax[investors[i]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks whether an address is excluded from claiming a dividend\r\n     * @param _dividendIndex Dividend to withdraw from\r\n     * @return bool whether the address is excluded\r\n     */\r\n    function isExcluded(address _investor, uint256 _dividendIndex) external  returns (bool) {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',17);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',346);\n        emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',22);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',94);\nrequire(_dividendIndex < dividends.length, \"Invalid dividend\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',22);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',347);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',95);\nreturn dividends[_dividendIndex].dividendExcluded[_investor];\r\n    }\r\n\r\n    /**\r\n     * @notice Checks whether an address has claimed a dividend\r\n     * @param _dividendIndex Dividend to withdraw from\r\n     * @return bool whether the address has claimed\r\n     */\r\n    function isClaimed(address _investor, uint256 _dividendIndex) external  returns (bool) {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',18);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',356);\n        emit __AssertPreCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',23);\nemit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',96);\nrequire(_dividendIndex < dividends.length, \"Invalid dividend\");emit __AssertPostCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',23);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',357);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',97);\nreturn dividends[_dividendIndex].claimed[_investor];\r\n    }\r\n\r\n    /**\r\n     * @notice Return the permissions flag that are associated with this module\r\n     * @return bytes32 array\r\n     */\r\n    function getPermissions() public  returns(bytes32[]) {emit __FunctionCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',19);\n\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',365);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',98);\nbytes32[] memory allPermissions = new bytes32[](2);\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',366);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',99);\nallPermissions[0] = DISTRIBUTE;\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',367);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',100);\nallPermissions[1] = MANAGE;\r\nemit __CoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',368);\n        emit __StatementCoverageDividendCheckpoint('./contracts/modules/Checkpoint/DividendCheckpoint.sol',101);\nreturn allPermissions;\r\n    }\r\n\r\n}\r\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\nimport \"./DividendCheckpoint.sol\";\r\nimport \"./ERC20DividendCheckpointStorage.sol\";\r\nimport \"../../interfaces/IOwnable.sol\";\r\nimport \"../../interfaces/IERC20.sol\";\r\n\r\n/**\r\n * @title Checkpoint module for issuing ERC20 dividends\r\n */\r\ncontract ERC20DividendCheckpoint is ERC20DividendCheckpointStorage, DividendCheckpoint {event __CoverageERC20DividendCheckpoint(string fileName, uint256 lineNumber);\nevent __FunctionCoverageERC20DividendCheckpoint(string fileName, uint256 fnId);\nevent __StatementCoverageERC20DividendCheckpoint(string fileName, uint256 statementId);\nevent __BranchCoverageERC20DividendCheckpoint(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageERC20DividendCheckpoint(string fileName, uint256 branchId);\nevent __AssertPostCoverageERC20DividendCheckpoint(string fileName, uint256 branchId);\n\r\n    using SafeMath for uint256;\r\n\r\n    event ERC20DividendDeposited(\r\n        address indexed _depositor,\r\n        uint256 _checkpointId,\r\n        uint256 _created,\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        address indexed _token,\r\n        uint256 _amount,\r\n        uint256 _totalSupply,\r\n        uint256 _dividendIndex,\r\n        bytes32 indexed _name\r\n    );\r\n    event ERC20DividendClaimed(\r\n        address indexed _payee,\r\n        uint256 indexed _dividendIndex,\r\n        address indexed _token,\r\n        uint256 _amount,\r\n        uint256 _withheld\r\n    );\r\n    event ERC20DividendReclaimed(\r\n        address indexed _claimer,\r\n        uint256 indexed _dividendIndex,\r\n        address indexed _token,\r\n        uint256 _claimedAmount\r\n    );\r\n    event ERC20DividendWithholdingWithdrawn(\r\n        address indexed _claimer,\r\n        uint256 indexed _dividendIndex,\r\n        address indexed _token,\r\n        uint256 _withheldAmount\r\n    );\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _securityToken Address of the security token\r\n     * @param _polyAddress Address of the polytoken\r\n     */\r\n    constructor (address _securityToken, address _polyAddress) public\r\n    Module(_securityToken, _polyAddress)\r\n    {emit __FunctionCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',1);\n\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend and checkpoint for the dividend\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _token Address of ERC20 token in which dividend is to be denominated\r\n     * @param _amount Amount of specified token for dividend\r\n     * @param _name Name/Title for identification\r\n     */\r\n    function createDividend(\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        address _token,\r\n        uint256 _amount,\r\n        bytes32 _name\r\n    )\r\n        external\r\n        withPerm(MANAGE)\r\n    {emit __FunctionCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',2);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',74);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',1);\ncreateDividendWithExclusions(_maturity, _expiry, _token, _amount, excluded, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend with a provided checkpoint\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _token Address of ERC20 token in which dividend is to be denominated\r\n     * @param _amount Amount of specified token for dividend\r\n     * @param _checkpointId Checkpoint id from which to create dividends\r\n     * @param _name Name/Title for identification\r\n     */\r\n    function createDividendWithCheckpoint(\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        address _token,\r\n        uint256 _amount,\r\n        uint256 _checkpointId,\r\n        bytes32 _name\r\n    )\r\n        external\r\n        withPerm(MANAGE)\r\n    {emit __FunctionCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',3);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',97);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',2);\n_createDividendWithCheckpointAndExclusions(_maturity, _expiry, _token, _amount, _checkpointId, excluded, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend and checkpoint for the dividend\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _token Address of ERC20 token in which dividend is to be denominated\r\n     * @param _amount Amount of specified token for dividend\r\n     * @param _excluded List of addresses to exclude\r\n     * @param _name Name/Title for identification\r\n     */\r\n    function createDividendWithExclusions(\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        address _token,\r\n        uint256 _amount,\r\n        address[] _excluded,\r\n        bytes32 _name\r\n    )\r\n        public\r\n        withPerm(MANAGE)\r\n    {emit __FunctionCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',4);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',120);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',3);\nuint256 checkpointId = ISecurityToken(securityToken).createCheckpoint();\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',121);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',4);\n_createDividendWithCheckpointAndExclusions(_maturity, _expiry, _token, _amount, checkpointId, _excluded, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend with a provided checkpoint\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _token Address of ERC20 token in which dividend is to be denominated\r\n     * @param _amount Amount of specified token for dividend\r\n     * @param _checkpointId Checkpoint id from which to create dividends\r\n     * @param _excluded List of addresses to exclude\r\n     * @param _name Name/Title for identification\r\n     */\r\n    function createDividendWithCheckpointAndExclusions(\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        address _token,\r\n        uint256 _amount,\r\n        uint256 _checkpointId,\r\n        address[] _excluded,\r\n        bytes32 _name\r\n    )\r\n        public\r\n        withPerm(MANAGE)\r\n    {emit __FunctionCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',5);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',146);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',5);\n_createDividendWithCheckpointAndExclusions(_maturity, _expiry, _token, _amount, _checkpointId, _excluded, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend with a provided checkpoint\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _token Address of ERC20 token in which dividend is to be denominated\r\n     * @param _amount Amount of specified token for dividend\r\n     * @param _checkpointId Checkpoint id from which to create dividends\r\n     * @param _excluded List of addresses to exclude\r\n     * @param _name Name/Title for identification\r\n     */\r\n    function _createDividendWithCheckpointAndExclusions(\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        address _token,\r\n        uint256 _amount,\r\n        uint256 _checkpointId,\r\n        address[] _excluded,\r\n        bytes32 _name\r\n    )\r\n        internal\r\n    {emit __FunctionCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',6);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',170);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',6);\nISecurityToken securityTokenInstance = ISecurityToken(securityToken);\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',171);\n        emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',1);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',7);\nrequire(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, \"Too many addresses excluded\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',1);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',172);\n        emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',2);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',8);\nrequire(_expiry > _maturity, \"Expiry before maturity\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',2);\n\r\n        /*solium-disable-next-line security/no-block-members*/\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',174);\n        emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',3);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',9);\nrequire(_expiry > now, \"Expiry in past\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',3);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',175);\n        emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',4);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',10);\nrequire(_amount > 0, \"No dividend sent\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',4);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',176);\n        emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',5);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',11);\nrequire(_token != address(0), \"Invalid token\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',5);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',177);\n        emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',6);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',12);\nrequire(_checkpointId <= securityTokenInstance.currentCheckpointId(), \"Invalid checkpoint\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',6);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',178);\n        emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',7);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',13);\nrequire(IERC20(_token).transferFrom(msg.sender, address(this), _amount), \"insufficent allowance\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',7);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',179);\n        emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',8);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',14);\nrequire(_name[0] != 0);emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',8);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',180);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',15);\nuint256 dividendIndex = dividends.length;\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',181);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',16);\nuint256 currentSupply = securityTokenInstance.totalSupplyAt(_checkpointId);\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',182);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',17);\nuint256 excludedSupply = 0;\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',183);\n        dividends.push(\r\n          Dividend(\r\n            _checkpointId,\r\n            now, /*solium-disable-line security/no-block-members*/\r\n            _maturity,\r\n            _expiry,\r\n            _amount,\r\n            0,\r\n            0,\r\n            false,\r\n            0,\r\n            0,\r\n            _name\r\n          )\r\n        );\r\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',199);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',18);\nfor (uint256 j = 0; j < _excluded.length; j++) {\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',200);\n            emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',9);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',19);\nrequire (_excluded[j] != address(0), \"Invalid address\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',9);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',201);\n            emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',10);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',20);\nrequire(!dividends[dividendIndex].dividendExcluded[_excluded[j]], \"duped exclude address\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',10);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',202);\n            emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',21);\nexcludedSupply = excludedSupply.add(securityTokenInstance.balanceOfAt(_excluded[j], _checkpointId));\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',203);\n            emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',22);\ndividends[dividendIndex].dividendExcluded[_excluded[j]] = true;\r\n        }\r\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',206);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',23);\ndividends[dividendIndex].totalSupply = currentSupply.sub(excludedSupply);\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',207);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',24);\ndividendTokens[dividendIndex] = _token;\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',208);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',25);\n_emitERC20DividendDepositedEvent(_checkpointId, _maturity, _expiry, _token, _amount, currentSupply, dividendIndex, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Emits the ERC20DividendDeposited event.\r\n     * Seperated into a different function as a workaround for stack too deep error\r\n     */\r\n    function _emitERC20DividendDepositedEvent(\r\n        uint256 _checkpointId,\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        address _token,\r\n        uint256 _amount,\r\n        uint256 currentSupply,\r\n        uint256 dividendIndex,\r\n        bytes32 _name\r\n    )\r\n        internal\r\n    {emit __FunctionCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',7);\n\r\n        /*solium-disable-next-line security/no-block-members*/\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',228);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',26);\nemit ERC20DividendDeposited(msg.sender, _checkpointId, now, _maturity, _expiry, _token, _amount, currentSupply, dividendIndex, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function for paying dividends\r\n     * @param _payee Address of investor\r\n     * @param _dividend Storage with previously issued dividends\r\n     * @param _dividendIndex Dividend to pay\r\n     */\r\n    function _payDividend(address _payee, Dividend storage _dividend, uint256 _dividendIndex) internal {emit __FunctionCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',8);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',238);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',27);\n(uint256 claim, uint256 withheld) = calculateDividend(_dividendIndex, _payee);\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',239);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',28);\n_dividend.claimed[_payee] = true;\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',240);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',29);\n_dividend.claimedAmount = claim.add(_dividend.claimedAmount);\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',241);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',30);\nuint256 claimAfterWithheld = claim.sub(withheld);\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',242);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',31);\nif (claimAfterWithheld > 0) {emit __BranchCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',11,0);\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',243);\n            emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',12);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',32);\nrequire(IERC20(dividendTokens[_dividendIndex]).transfer(_payee, claimAfterWithheld), \"transfer failed\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',12);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',244);\n            emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',33);\nif (withheld > 0) {emit __BranchCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',13,0);\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',245);\n                emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',34);\n_dividend.totalWithheld = _dividend.totalWithheld.add(withheld);\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',246);\n                emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',35);\n_dividend.withheld[_payee] = withheld;\r\n            }else { emit __BranchCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',13,1);}\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',248);\n            emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',36);\nemit ERC20DividendClaimed(_payee, _dividendIndex, dividendTokens[_dividendIndex], claim, withheld);\r\n        }else { emit __BranchCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',11,1);}\n\r\n    }\r\n\r\n    /**\r\n     * @notice Issuer can reclaim remaining unclaimed dividend amounts, for expired dividends\r\n     * @param _dividendIndex Dividend to reclaim\r\n     */\r\n    function reclaimDividend(uint256 _dividendIndex) external withPerm(MANAGE) {emit __FunctionCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',9);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',257);\n        emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',14);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',37);\nrequire(_dividendIndex < dividends.length, \"Invalid dividend\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',14);\n\r\n        /*solium-disable-next-line security/no-block-members*/\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',259);\n        emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',15);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',38);\nrequire(now >= dividends[_dividendIndex].expiry, \"Dividend expiry in future\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',15);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',260);\n        emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',16);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',39);\nrequire(!dividends[_dividendIndex].reclaimed, \"already claimed\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',16);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',261);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',40);\ndividends[_dividendIndex].reclaimed = true;\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',262);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',41);\nDividend storage dividend = dividends[_dividendIndex];\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',263);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',42);\nuint256 remainingAmount = dividend.amount.sub(dividend.claimedAmount);\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',264);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',43);\naddress owner = IOwnable(securityToken).owner();\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',265);\n        emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',17);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',44);\nrequire(IERC20(dividendTokens[_dividendIndex]).transfer(owner, remainingAmount), \"transfer failed\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',17);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',266);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',45);\nemit ERC20DividendReclaimed(owner, _dividendIndex, dividendTokens[_dividendIndex], remainingAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows issuer to withdraw withheld tax\r\n     * @param _dividendIndex Dividend to withdraw from\r\n     */\r\n    function withdrawWithholding(uint256 _dividendIndex) external withPerm(MANAGE) {emit __FunctionCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',10);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',274);\n        emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',18);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',46);\nrequire(_dividendIndex < dividends.length, \"Invalid dividend\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',18);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',275);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',47);\nDividend storage dividend = dividends[_dividendIndex];\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',276);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',48);\nuint256 remainingWithheld = dividend.totalWithheld.sub(dividend.totalWithheldWithdrawn);\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',277);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',49);\ndividend.totalWithheldWithdrawn = dividend.totalWithheld;\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',278);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',50);\naddress owner = IOwnable(securityToken).owner();\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',279);\n        emit __AssertPreCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',19);\nemit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',51);\nrequire(IERC20(dividendTokens[_dividendIndex]).transfer(owner, remainingWithheld), \"transfer failed\");emit __AssertPostCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',19);\n\r\nemit __CoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',280);\n        emit __StatementCoverageERC20DividendCheckpoint('./contracts/modules/Checkpoint/ERC20DividendCheckpoint.sol',52);\nemit ERC20DividendWithholdingWithdrawn(owner, _dividendIndex, dividendTokens[_dividendIndex], remainingWithheld);\r\n    }\r\n\r\n}\r\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/Checkpoint/EtherDividendCheckpoint.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\nimport \"./DividendCheckpoint.sol\";\r\nimport \"../../interfaces/IOwnable.sol\";\r\n\r\n/**\r\n * @title Checkpoint module for issuing ether dividends\r\n */\r\ncontract EtherDividendCheckpoint is DividendCheckpoint {event __CoverageEtherDividendCheckpoint(string fileName, uint256 lineNumber);\nevent __FunctionCoverageEtherDividendCheckpoint(string fileName, uint256 fnId);\nevent __StatementCoverageEtherDividendCheckpoint(string fileName, uint256 statementId);\nevent __BranchCoverageEtherDividendCheckpoint(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageEtherDividendCheckpoint(string fileName, uint256 branchId);\nevent __AssertPostCoverageEtherDividendCheckpoint(string fileName, uint256 branchId);\n\r\n    using SafeMath for uint256;\r\n\r\n    event EtherDividendDeposited(\r\n        address indexed _depositor,\r\n        uint256 _checkpointId,\r\n        uint256 _created,\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        uint256 _amount,\r\n        uint256 _totalSupply,\r\n        uint256 indexed _dividendIndex,\r\n        bytes32 indexed _name\r\n    );\r\n    event EtherDividendClaimed(address indexed _payee, uint256 indexed _dividendIndex, uint256 _amount, uint256 _withheld);\r\n    event EtherDividendReclaimed(address indexed _claimer, uint256 indexed _dividendIndex, uint256 _claimedAmount);\r\n    event EtherDividendClaimFailed(address indexed _payee, uint256 indexed _dividendIndex, uint256 _amount, uint256 _withheld);\r\n    event EtherDividendWithholdingWithdrawn(address indexed _claimer, uint256 indexed _dividendIndex, uint256 _withheldAmount);\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _securityToken Address of the security token\r\n     * @param _polyAddress Address of the polytoken\r\n     */\r\n    constructor (address _securityToken, address _polyAddress) public\r\n    Module(_securityToken, _polyAddress)\r\n    {emit __FunctionCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',1);\n\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend and checkpoint for the dividend, using global list of excluded addresses\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _name Name/title for identification\r\n     */\r\n    function createDividend(uint256 _maturity, uint256 _expiry, bytes32 _name) external payable withPerm(MANAGE) {emit __FunctionCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',2);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',45);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',1);\ncreateDividendWithExclusions(_maturity, _expiry, excluded, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend with a provided checkpoint, using global list of excluded addresses\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _checkpointId Id of the checkpoint from which to issue dividend\r\n     * @param _name Name/title for identification\r\n     */\r\n    function createDividendWithCheckpoint(\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        uint256 _checkpointId,\r\n        bytes32 _name\r\n    )\r\n        external\r\n        payable\r\n        withPerm(MANAGE)\r\n    {emit __FunctionCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',3);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',65);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',2);\n_createDividendWithCheckpointAndExclusions(_maturity, _expiry, _checkpointId, excluded, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend and checkpoint for the dividend, specifying explicit excluded addresses\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _excluded List of addresses to exclude\r\n     * @param _name Name/title for identification\r\n     */\r\n    function createDividendWithExclusions(\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        address[] _excluded,\r\n        bytes32 _name\r\n    )\r\n        public\r\n        payable\r\n        withPerm(MANAGE)\r\n    {emit __FunctionCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',4);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',85);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',3);\nuint256 checkpointId = ISecurityToken(securityToken).createCheckpoint();\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',86);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',4);\n_createDividendWithCheckpointAndExclusions(_maturity, _expiry, checkpointId, _excluded, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend with a provided checkpoint, specifying explicit excluded addresses\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _checkpointId Id of the checkpoint from which to issue dividend\r\n     * @param _excluded List of addresses to exclude\r\n     * @param _name Name/title for identification\r\n     */\r\n    function createDividendWithCheckpointAndExclusions(\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        uint256 _checkpointId,\r\n        address[] _excluded,\r\n        bytes32 _name\r\n    )\r\n        public\r\n        payable\r\n        withPerm(MANAGE)\r\n    {emit __FunctionCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',5);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',108);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',5);\n_createDividendWithCheckpointAndExclusions(_maturity, _expiry, _checkpointId, _excluded, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend with a provided checkpoint, specifying explicit excluded addresses\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _checkpointId Id of the checkpoint from which to issue dividend\r\n     * @param _excluded List of addresses to exclude\r\n     * @param _name Name/title for identification\r\n     */\r\n    function _createDividendWithCheckpointAndExclusions(\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        uint256 _checkpointId,\r\n        address[] _excluded,\r\n        bytes32 _name\r\n    )\r\n        internal\r\n    {emit __FunctionCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',6);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',128);\n        emit __AssertPreCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',1);\nemit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',6);\nrequire(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, \"Too many addresses excluded\");emit __AssertPostCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',1);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',129);\n        emit __AssertPreCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',2);\nemit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',7);\nrequire(_expiry > _maturity, \"Expiry is before maturity\");emit __AssertPostCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',2);\n\r\n        /*solium-disable-next-line security/no-block-members*/\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',131);\n        emit __AssertPreCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',3);\nemit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',8);\nrequire(_expiry > now, \"Expiry is in the past\");emit __AssertPostCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',3);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',132);\n        emit __AssertPreCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',4);\nemit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',9);\nrequire(msg.value > 0, \"No dividend sent\");emit __AssertPostCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',4);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',133);\n        emit __AssertPreCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',5);\nemit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',10);\nrequire(_checkpointId <= ISecurityToken(securityToken).currentCheckpointId());emit __AssertPostCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',5);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',134);\n        emit __AssertPreCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',6);\nemit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',11);\nrequire(_name[0] != 0);emit __AssertPostCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',6);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',135);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',12);\nuint256 dividendIndex = dividends.length;\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',136);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',13);\nuint256 currentSupply = ISecurityToken(securityToken).totalSupplyAt(_checkpointId);\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',137);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',14);\nuint256 excludedSupply = 0;\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',138);\n        dividends.push(\r\n          Dividend(\r\n            _checkpointId,\r\n            now, /*solium-disable-line security/no-block-members*/\r\n            _maturity,\r\n            _expiry,\r\n            msg.value,\r\n            0,\r\n            0,\r\n            false,\r\n            0,\r\n            0,\r\n            _name\r\n          )\r\n        );\r\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',154);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',15);\nfor (uint256 j = 0; j < _excluded.length; j++) {\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',155);\n            emit __AssertPreCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',7);\nemit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',16);\nrequire (_excluded[j] != address(0), \"Invalid address\");emit __AssertPostCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',7);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',156);\n            emit __AssertPreCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',8);\nemit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',17);\nrequire(!dividends[dividendIndex].dividendExcluded[_excluded[j]], \"duped exclude address\");emit __AssertPostCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',8);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',157);\n            emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',18);\nexcludedSupply = excludedSupply.add(ISecurityToken(securityToken).balanceOfAt(_excluded[j], _checkpointId));\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',158);\n            emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',19);\ndividends[dividendIndex].dividendExcluded[_excluded[j]] = true;\r\n        }\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',160);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',20);\ndividends[dividendIndex].totalSupply = currentSupply.sub(excludedSupply);\r\n        /*solium-disable-next-line security/no-block-members*/\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',162);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',21);\nemit EtherDividendDeposited(msg.sender, _checkpointId, now, _maturity, _expiry, msg.value, currentSupply, dividendIndex, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function for paying dividends\r\n     * @param _payee address of investor\r\n     * @param _dividend storage with previously issued dividends\r\n     * @param _dividendIndex Dividend to pay\r\n     */\r\n    function _payDividend(address _payee, Dividend storage _dividend, uint256 _dividendIndex) internal {emit __FunctionCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',7);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',172);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',22);\n(uint256 claim, uint256 withheld) = calculateDividend(_dividendIndex, _payee);\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',173);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',23);\n_dividend.claimed[_payee] = true;\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',174);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',24);\nuint256 claimAfterWithheld = claim.sub(withheld);\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',175);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',25);\nif (claimAfterWithheld > 0) {emit __BranchCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',9,0);\r\n            /*solium-disable-next-line security/no-send*/\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',177);\n            emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',26);\nif (_payee.send(claimAfterWithheld)) {emit __BranchCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',10,0);\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',178);\n                emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',27);\n_dividend.claimedAmount = _dividend.claimedAmount.add(claim);\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',179);\n                emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',28);\nif (withheld > 0) {emit __BranchCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',11,0);\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',180);\n                    emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',29);\n_dividend.totalWithheld = _dividend.totalWithheld.add(withheld);\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',181);\n                    emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',30);\n_dividend.withheld[_payee] = withheld;\r\n                }else { emit __BranchCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',11,1);}\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',183);\n                emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',31);\nemit EtherDividendClaimed(_payee, _dividendIndex, claim, withheld);\r\n            } else {emit __BranchCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',10,1);\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',185);\n                emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',32);\n_dividend.claimed[_payee] = false;\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',186);\n                emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',33);\nemit EtherDividendClaimFailed(_payee, _dividendIndex, claim, withheld);\r\n            }\r\n        }else { emit __BranchCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',9,1);}\n\r\n    }\r\n\r\n    /**\r\n     * @notice Issuer can reclaim remaining unclaimed dividend amounts, for expired dividends\r\n     * @param _dividendIndex Dividend to reclaim\r\n     */\r\n    function reclaimDividend(uint256 _dividendIndex) external withPerm(MANAGE) {emit __FunctionCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',8);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',196);\n        emit __AssertPreCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',12);\nemit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',34);\nrequire(_dividendIndex < dividends.length, \"Incorrect dividend index\");emit __AssertPostCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',12);\n\r\n        /*solium-disable-next-line security/no-block-members*/\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',198);\n        emit __AssertPreCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',13);\nemit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',35);\nrequire(now >= dividends[_dividendIndex].expiry, \"Dividend expiry is in the future\");emit __AssertPostCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',13);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',199);\n        emit __AssertPreCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',14);\nemit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',36);\nrequire(!dividends[_dividendIndex].reclaimed, \"Dividend is already claimed\");emit __AssertPostCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',14);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',200);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',37);\nDividend storage dividend = dividends[_dividendIndex];\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',201);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',38);\ndividend.reclaimed = true;\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',202);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',39);\nuint256 remainingAmount = dividend.amount.sub(dividend.claimedAmount);\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',203);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',40);\naddress owner = IOwnable(securityToken).owner();\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',204);\n        owner.transfer(remainingAmount);\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',205);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',41);\nemit EtherDividendReclaimed(owner, _dividendIndex, remainingAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows issuer to withdraw withheld tax\r\n     * @param _dividendIndex Dividend to withdraw from\r\n     */\r\n    function withdrawWithholding(uint256 _dividendIndex) external withPerm(MANAGE) {emit __FunctionCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',9);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',213);\n        emit __AssertPreCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',15);\nemit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',42);\nrequire(_dividendIndex < dividends.length, \"Incorrect dividend index\");emit __AssertPostCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',15);\n\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',214);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',43);\nDividend storage dividend = dividends[_dividendIndex];\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',215);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',44);\nuint256 remainingWithheld = dividend.totalWithheld.sub(dividend.totalWithheldWithdrawn);\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',216);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',45);\ndividend.totalWithheldWithdrawn = dividend.totalWithheld;\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',217);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',46);\naddress owner = IOwnable(securityToken).owner();\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',218);\n        owner.transfer(remainingWithheld);\r\nemit __CoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',219);\n        emit __StatementCoverageEtherDividendCheckpoint('./contracts/modules/Checkpoint/EtherDividendCheckpoint.sol',47);\nemit EtherDividendWithholdingWithdrawn(owner, _dividendIndex, remainingWithheld);\r\n    }\r\n\r\n}\r\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/PermissionManager/GeneralPermissionManager.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./IPermissionManager.sol\";\nimport \"../Module.sol\";\n\n/**\n * @title Permission Manager module for core permissioning functionality\n */\ncontract GeneralPermissionManager is IPermissionManager, Module {event __CoverageGeneralPermissionManager(string fileName, uint256 lineNumber);\nevent __FunctionCoverageGeneralPermissionManager(string fileName, uint256 fnId);\nevent __StatementCoverageGeneralPermissionManager(string fileName, uint256 statementId);\nevent __BranchCoverageGeneralPermissionManager(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageGeneralPermissionManager(string fileName, uint256 branchId);\nevent __AssertPostCoverageGeneralPermissionManager(string fileName, uint256 branchId);\n\n\n    // Mapping used to hold the permissions on the modules provided to delegate, module add => delegate add => permission bytes32 => bool \n    mapping (address => mapping (address => mapping (bytes32 => bool))) public perms;\n    // Mapping hold the delagate details\n    mapping (address => bytes32) public delegateDetails;\n    // Array to track all delegates\n    address[] public allDelegates;\n\n\n    // Permission flag\n    bytes32 public constant CHANGE_PERMISSION = \"CHANGE_PERMISSION\";\n\n    /// Event emitted after any permission get changed for the delegate\n    event ChangePermission(address indexed _delegate, address _module, bytes32 _perm, bool _valid, uint256 _timestamp);\n    /// Used to notify when delegate is added in permission manager contract\n    event AddDelegate(address indexed _delegate, bytes32 _details, uint256 _timestamp);\n\n\n    /// @notice constructor\n    constructor (address _securityToken, address _polyAddress) public\n    Module(_securityToken, _polyAddress)\n    {emit __FunctionCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',1);\n\n    }\n\n    /**\n     * @notice Init function i.e generalise function to maintain the structure of the module contract\n     * @return bytes4\n     */\n    function getInitFunction() public  returns (bytes4) {emit __FunctionCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',2);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',39);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',1);\nreturn bytes4(0);\n    }\n\n    /**\n     * @notice Used to check the permission on delegate corresponds to module contract address\n     * @param _delegate Ethereum address of the delegate\n     * @param _module Ethereum contract address of the module\n     * @param _perm Permission flag\n     * @return bool\n     */\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external  returns(bool) {emit __FunctionCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',3);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',50);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',2);\nif (delegateDetails[_delegate] != bytes32(0)) {emit __BranchCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',1,0);\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',51);\n            emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',3);\nreturn perms[_module][_delegate][_perm];\n        } else\n            {emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',4);\nemit __BranchCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',1,1);emit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',53);\nreturn false;}\n    }\n\n    /**\n     * @notice Used to add a delegate\n     * @param _delegate Ethereum address of the delegate\n     * @param _details Details about the delegate i.e `Belongs to financial firm`\n     */\n    function addDelegate(address _delegate, bytes32 _details) external withPerm(CHANGE_PERMISSION) {emit __FunctionCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',4);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',62);\n        emit __AssertPreCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',2);\nemit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',5);\nrequire(_delegate != address(0), \"Invalid address\");emit __AssertPostCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',2);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',63);\n        emit __AssertPreCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',3);\nemit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',6);\nrequire(_details != bytes32(0), \"0 value not allowed\");emit __AssertPostCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',3);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',64);\n        emit __AssertPreCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',4);\nemit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',7);\nrequire(delegateDetails[_delegate] == bytes32(0), \"Already present\");emit __AssertPostCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',4);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',65);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',8);\ndelegateDetails[_delegate] = _details;\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',66);\n        allDelegates.push(_delegate);\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',68);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',9);\nemit AddDelegate(_delegate, _details, now);\n    }\n\n    /**\n     * @notice Used to delete a delegate\n     * @param _delegate Ethereum address of the delegate\n     */\n    function deleteDelegate(address _delegate) external withPerm(CHANGE_PERMISSION) {emit __FunctionCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',5);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',76);\n        emit __AssertPreCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',5);\nemit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',10);\nrequire(delegateDetails[_delegate] != bytes32(0), \"delegate does not exist\");emit __AssertPostCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',5);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',77);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',11);\nfor (uint256 i = 0; i < allDelegates.length; i++) {\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',78);\n            emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',12);\nif (allDelegates[i] == _delegate) {emit __BranchCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',6,0);\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',79);\n                emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',13);\nallDelegates[i] = allDelegates[allDelegates.length - 1];\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',80);\n                emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',14);\nallDelegates.length = allDelegates.length - 1;\n            }else { emit __BranchCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',6,1);}\n\n        }\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',83);\n        delete delegateDetails[_delegate];\n    }\n\n    /**\n     * @notice Used to check if an address is a delegate or not\n     * @param _potentialDelegate the address of potential delegate\n     * @return bool\n     */\n    function checkDelegate(address _potentialDelegate) external  returns(bool) {emit __FunctionCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',6);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',92);\n        emit __AssertPreCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',7);\nemit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',15);\nrequire(_potentialDelegate != address(0), \"Invalid address\");emit __AssertPostCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',7);\n\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',94);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',16);\nif (delegateDetails[_potentialDelegate] != bytes32(0)) {emit __BranchCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',8,0);\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',95);\n            emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',17);\nreturn true;\n        } else\n            {emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',18);\nemit __BranchCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',8,1);emit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',97);\nreturn false;}\n    }\n\n    /**\n     * @notice Used to provide/change the permission to the delegate corresponds to the module contract\n     * @param _delegate Ethereum address of the delegate\n     * @param _module Ethereum contract address of the module\n     * @param _perm Permission flag\n     * @param _valid Bool flag use to switch on/off the permission\n     * @return bool\n     */\n    function changePermission(\n        address _delegate,\n        address _module,\n        bytes32 _perm,\n        bool _valid\n    )\n    public\n    withPerm(CHANGE_PERMISSION)\n    {emit __FunctionCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',7);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',117);\n        emit __AssertPreCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',9);\nemit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',19);\nrequire(_delegate != address(0), \"invalid address\");emit __AssertPostCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',9);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',118);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',20);\n_changePermission(_delegate, _module, _perm, _valid);\n    }\n\n    /**\n     * @notice Used to change one or more permissions for a single delegate at once\n     * @param _delegate Ethereum address of the delegate\n     * @param _modules Multiple module matching the multiperms, needs to be same length\n     * @param _perms Multiple permission flag needs to be changed\n     * @param _valids Bool array consist the flag to switch on/off the permission\n     * @return nothing\n     */\n    function changePermissionMulti(\n        address _delegate,\n        address[] _modules,\n        bytes32[] _perms,\n        bool[] _valids\n    )\n    external\n    withPerm(CHANGE_PERMISSION)\n    {emit __FunctionCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',8);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',138);\n        emit __AssertPreCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',10);\nemit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',21);\nrequire(_delegate != address(0), \"invalid address\");emit __AssertPostCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',10);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',139);\n        emit __AssertPreCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',11);\nemit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',22);\nrequire(_modules.length > 0, \"0 length is not allowed\");emit __AssertPostCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',11);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',140);\n        emit __AssertPreCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',12);\nemit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',23);\nrequire(_modules.length == _perms.length, \"Array length mismatch\");emit __AssertPostCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',12);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',141);\n        emit __AssertPreCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',13);\nemit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',24);\nrequire(_valids.length == _perms.length, \"Array length mismatch\");emit __AssertPostCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',13);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',142);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',25);\nfor(uint256 i = 0; i < _perms.length; i++) {\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',143);\n            emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',26);\n_changePermission(_delegate, _modules[i], _perms[i], _valids[i]);\n        }\n    }\n\n    /**\n     * @notice Used to return all delegates with a given permission and module\n     * @param _module Ethereum contract address of the module\n     * @param _perm Permission flag\n     * @return address[]\n     */\n    function getAllDelegatesWithPerm(address _module, bytes32 _perm) external  returns(address[]) {emit __FunctionCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',9);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',154);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',27);\nuint256 counter = 0;\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',155);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',28);\nuint256 i = 0;\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',156);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',29);\nfor (i = 0; i < allDelegates.length; i++) {\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',157);\n            emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',30);\nif (perms[_module][allDelegates[i]][_perm]) {emit __BranchCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',14,0);\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',158);\n                counter++;\n            }else { emit __BranchCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',14,1);}\n\n        }\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',161);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',31);\naddress[] memory allDelegatesWithPerm = new address[](counter);\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',162);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',32);\ncounter = 0;\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',163);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',33);\nfor (i = 0; i < allDelegates.length; i++) {\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',164);\n            emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',34);\nif (perms[_module][allDelegates[i]][_perm]){emit __BranchCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',15,0);\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',165);\n                emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',35);\nallDelegatesWithPerm[counter] = allDelegates[i];\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',166);\n                counter++;\n            }else { emit __BranchCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',15,1);}\n\n        }\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',169);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',36);\nreturn allDelegatesWithPerm;\n    }\n\n    /**\n     * @notice Used to return all permission of a single or multiple module\n     * @dev possible that function get out of gas is there are lot of modules and perm related to them\n     * @param _delegate Ethereum address of the delegate\n     * @param _types uint8[] of types\n     * @return address[] the address array of Modules this delegate has permission\n     * @return bytes32[] the permission array of the corresponding Modules\n     */\n    function getAllModulesAndPermsFromTypes(address _delegate, uint8[] _types) external  returns(address[], bytes32[]) {emit __FunctionCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',10);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',181);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',37);\nuint256 counter = 0;\n        // loop through _types and get their modules from securityToken->getModulesByType\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',183);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',38);\nfor (uint256 i = 0; i < _types.length; i++) {\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',184);\n            emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',39);\naddress[] memory _currentTypeModules = ISecurityToken(securityToken).getModulesByType(_types[i]);\n            // loop through each modules to get their perms from IModule->getPermissions\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',186);\n            emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',40);\nfor (uint256 j = 0; j < _currentTypeModules.length; j++){\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',187);\n                emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',41);\nbytes32[] memory _allModulePerms = IModule(_currentTypeModules[j]).getPermissions();\n                // loop through each perm, if it is true, push results into arrays\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',189);\n                emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',42);\nfor (uint256 k = 0; k < _allModulePerms.length; k++) {\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',190);\n                    emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',43);\nif (perms[_currentTypeModules[j]][_delegate][_allModulePerms[k]]) {emit __BranchCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',16,0);\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',191);\n                        counter ++;\n                    }else { emit __BranchCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',16,1);}\n\n                }\n            }\n        }\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',197);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',44);\naddress[] memory _allModules = new address[](counter);\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',198);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',45);\nbytes32[] memory _allPerms = new bytes32[](counter);\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',199);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',46);\ncounter = 0;\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',201);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',47);\nfor (i = 0; i < _types.length; i++){\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',202);\n            emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',48);\n_currentTypeModules = ISecurityToken(securityToken).getModulesByType(_types[i]);\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',203);\n            emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',49);\nfor (j = 0; j < _currentTypeModules.length; j++) {\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',204);\n                emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',50);\n_allModulePerms = IModule(_currentTypeModules[j]).getPermissions();\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',205);\n                emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',51);\nfor (k = 0; k < _allModulePerms.length; k++) {\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',206);\n                    emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',52);\nif (perms[_currentTypeModules[j]][_delegate][_allModulePerms[k]]) {emit __BranchCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',17,0);\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',207);\n                        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',53);\n_allModules[counter] = _currentTypeModules[j];\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',208);\n                        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',54);\n_allPerms[counter] = _allModulePerms[k];\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',209);\n                        counter++;\n                    }else { emit __BranchCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',17,1);}\n\n                }\n            }\n        }\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',215);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',55);\nreturn(_allModules, _allPerms);\n    }\n\n    /**\n     * @notice Used to provide/change the permission to the delegate corresponds to the module contract\n     * @param _delegate Ethereum address of the delegate\n     * @param _module Ethereum contract address of the module\n     * @param _perm Permission flag\n     * @param _valid Bool flag use to switch on/off the permission\n     * @return bool\n     */\n    function _changePermission(\n        address _delegate,\n        address _module,\n        bytes32 _perm,\n        bool _valid\n    )\n     internal\n    {emit __FunctionCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',11);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',234);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',56);\nperms[_module][_delegate][_perm] = _valid;\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',236);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',57);\nemit ChangePermission(_delegate, _module, _perm, _valid, now);\n    }\n\n    /**\n     * @notice Used to get all delegates\n     * @return address[]\n     */\n    function getAllDelegates() external  returns(address[]) {emit __FunctionCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',12);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',244);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',58);\nreturn allDelegates;\n    }\n    \n    /**\n    * @notice Returns the Permission flag related the `this` contract\n    * @return Array of permission flags\n    */\n    function getPermissions() public  returns(bytes32[]) {emit __FunctionCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',13);\n\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',252);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',59);\nbytes32[] memory allPermissions = new bytes32[](1);\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',253);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',60);\nallPermissions[0] = CHANGE_PERMISSION;\nemit __CoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',254);\n        emit __StatementCoverageGeneralPermissionManager('./contracts/modules/PermissionManager/GeneralPermissionManager.sol',61);\nreturn allPermissions;\n    }\n\n}\n"},"/home/max/Desktop/Ethereum/polymath-core/contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./GeneralPermissionManager.sol\";\nimport \"../ModuleFactory.sol\";\n\n/**\n * @title Factory for deploying GeneralPermissionManager module\n */\ncontract GeneralPermissionManagerFactory is ModuleFactory {event __CoverageGeneralPermissionManagerFactory(string fileName, uint256 lineNumber);\nevent __FunctionCoverageGeneralPermissionManagerFactory(string fileName, uint256 fnId);\nevent __StatementCoverageGeneralPermissionManagerFactory(string fileName, uint256 statementId);\nevent __BranchCoverageGeneralPermissionManagerFactory(string fileName, uint256 branchId, uint256 locationIdx);\nevent __AssertPreCoverageGeneralPermissionManagerFactory(string fileName, uint256 branchId);\nevent __AssertPostCoverageGeneralPermissionManagerFactory(string fileName, uint256 branchId);\n\n\n    /**\n     * @notice Constructor\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\n    {emit __FunctionCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',1);\n\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',18);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',1);\nversion = \"1.0.0\";\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',19);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',2);\nname = \"GeneralPermissionManager\";\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',20);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',3);\ntitle = \"General Permission Manager\";\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',21);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',4);\ndescription = \"Manage permissions within the Security Token and attached modules\";\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',22);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',5);\ncompatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',23);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',6);\ncompatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\n    }\n\n    /**\n     * @notice Used to launch the Module with the help of factory\n     * @return address Contract address of the Module\n     */\n    function deploy(bytes /* _data */) external returns(address) {emit __FunctionCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',2);\n\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',31);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',7);\nif(setupCost > 0)\n            {emit __AssertPreCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',2);\nemit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',8);\nemit __BranchCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',1,0);emit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',32);\nrequire(polyToken.transferFrom(msg.sender, owner, setupCost), \"Failed transferFrom due to insufficent Allowance provided\");emit __AssertPostCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',2);\n}else { emit __BranchCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',1,1);}\n\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',33);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',9);\naddress permissionManager = new GeneralPermissionManager(msg.sender, address(polyToken));\n        /*solium-disable-next-line security/no-block-members*/\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',35);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',10);\nemit GenerateModuleFromFactory(address(permissionManager), getName(), address(this), msg.sender, setupCost, now);\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',36);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',11);\nreturn permissionManager;\n    }\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external  returns(uint8[]) {emit __FunctionCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',3);\n\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',43);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',12);\nuint8[] memory res = new uint8[](1);\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',44);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',13);\nres[0] = 1;\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',45);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',14);\nreturn res;\n    }\n\n    /**\n     * @notice Returns the instructions associated with the module\n     */\n    function getInstructions() external  returns(string) {emit __FunctionCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',4);\n\n        /*solium-disable-next-line max-len*/\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',53);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',15);\nreturn \"Add and remove permissions for the SecurityToken and associated modules. Permission types should be encoded as bytes32 values and attached using withPerm modifier to relevant functions. No initFunction required.\";\n    }\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external  returns(bytes32[]) {emit __FunctionCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',5);\n\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',60);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',16);\nbytes32[] memory availableTags = new bytes32[](0);\nemit __CoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',61);\n        emit __StatementCoverageGeneralPermissionManagerFactory('./contracts/modules/PermissionManager/GeneralPermissionManagerFactory.sol',17);\nreturn availableTags;\n    }\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"":["legacyAST","ast"],"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap"]}}}}